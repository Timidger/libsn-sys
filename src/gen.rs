/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const XlibSpecificationRelease: libc::c_uint = 6;
pub const _SYS_TYPES_H: libc::c_uint = 1;
pub const _FEATURES_H: libc::c_uint = 1;
pub const _DEFAULT_SOURCE: libc::c_uint = 1;
pub const __USE_ISOC11: libc::c_uint = 1;
pub const __USE_ISOC99: libc::c_uint = 1;
pub const __USE_ISOC95: libc::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: libc::c_uint = 1;
pub const _POSIX_SOURCE: libc::c_uint = 1;
pub const _POSIX_C_SOURCE: libc::c_uint = 200809;
pub const __USE_POSIX: libc::c_uint = 1;
pub const __USE_POSIX2: libc::c_uint = 1;
pub const __USE_POSIX199309: libc::c_uint = 1;
pub const __USE_POSIX199506: libc::c_uint = 1;
pub const __USE_XOPEN2K: libc::c_uint = 1;
pub const __USE_XOPEN2K8: libc::c_uint = 1;
pub const _ATFILE_SOURCE: libc::c_uint = 1;
pub const __USE_MISC: libc::c_uint = 1;
pub const __USE_ATFILE: libc::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: libc::c_uint = 0;
pub const _STDC_PREDEF_H: libc::c_uint = 1;
pub const __STDC_IEC_559__: libc::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: libc::c_uint = 1;
pub const __STDC_ISO_10646__: libc::c_uint = 201505;
pub const __STDC_NO_THREADS__: libc::c_uint = 1;
pub const __GNU_LIBRARY__: libc::c_uint = 6;
pub const __GLIBC__: libc::c_uint = 2;
pub const __GLIBC_MINOR__: libc::c_uint = 25;
pub const _SYS_CDEFS_H: libc::c_uint = 1;
pub const __glibc_c99_flexarr_available: libc::c_uint = 1;
pub const __WORDSIZE: libc::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: libc::c_uint = 1;
pub const __SYSCALL_WORDSIZE: libc::c_uint = 64;
pub const _BITS_TYPES_H: libc::c_uint = 1;
pub const _BITS_TYPESIZES_H: libc::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: libc::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: libc::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: libc::c_uint = 1;
pub const __FD_SETSIZE: libc::c_uint = 1024;
pub const __clock_t_defined: libc::c_uint = 1;
pub const __clockid_t_defined: libc::c_uint = 1;
pub const __time_t_defined: libc::c_uint = 1;
pub const __timer_t_defined: libc::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: libc::c_uint = 1;
pub const _ENDIAN_H: libc::c_uint = 1;
pub const __LITTLE_ENDIAN: libc::c_uint = 1234;
pub const __BIG_ENDIAN: libc::c_uint = 4321;
pub const __PDP_ENDIAN: libc::c_uint = 3412;
pub const __BYTE_ORDER: libc::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: libc::c_uint = 1234;
pub const LITTLE_ENDIAN: libc::c_uint = 1234;
pub const BIG_ENDIAN: libc::c_uint = 4321;
pub const PDP_ENDIAN: libc::c_uint = 3412;
pub const BYTE_ORDER: libc::c_uint = 1234;
pub const _BITS_BYTESWAP_H: libc::c_uint = 1;
pub const _BITS_UINTN_IDENTITY_H: libc::c_uint = 1;
pub const _SYS_SELECT_H: libc::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: libc::c_uint = 1;
pub const __timeval_defined: libc::c_uint = 1;
pub const __timespec_defined: libc::c_uint = 1;
pub const FD_SETSIZE: libc::c_uint = 1024;
pub const _SYS_SYSMACROS_H: libc::c_uint = 1;
pub const _BITS_SYSMACROS_H: libc::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: libc::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: libc::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: libc::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: libc::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: libc::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: libc::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: libc::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: libc::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: libc::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: libc::c_uint = 4;
pub const __have_pthread_attr_t: libc::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: libc::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: libc::c_uint = 1;
pub const X_PROTOCOL: libc::c_uint = 11;
pub const X_PROTOCOL_REVISION: libc::c_uint = 0;
pub const None: libc::c_uint = 0;
pub const ParentRelative: libc::c_uint = 1;
pub const CopyFromParent: libc::c_uint = 0;
pub const PointerWindow: libc::c_uint = 0;
pub const InputFocus: libc::c_uint = 1;
pub const PointerRoot: libc::c_uint = 1;
pub const AnyPropertyType: libc::c_uint = 0;
pub const AnyKey: libc::c_uint = 0;
pub const AnyButton: libc::c_uint = 0;
pub const AllTemporary: libc::c_uint = 0;
pub const CurrentTime: libc::c_uint = 0;
pub const NoSymbol: libc::c_uint = 0;
pub const NoEventMask: libc::c_uint = 0;
pub const KeyPressMask: libc::c_uint = 1;
pub const KeyReleaseMask: libc::c_uint = 2;
pub const ButtonPressMask: libc::c_uint = 4;
pub const ButtonReleaseMask: libc::c_uint = 8;
pub const EnterWindowMask: libc::c_uint = 16;
pub const LeaveWindowMask: libc::c_uint = 32;
pub const PointerMotionMask: libc::c_uint = 64;
pub const PointerMotionHintMask: libc::c_uint = 128;
pub const Button1MotionMask: libc::c_uint = 256;
pub const Button2MotionMask: libc::c_uint = 512;
pub const Button3MotionMask: libc::c_uint = 1024;
pub const Button4MotionMask: libc::c_uint = 2048;
pub const Button5MotionMask: libc::c_uint = 4096;
pub const ButtonMotionMask: libc::c_uint = 8192;
pub const KeymapStateMask: libc::c_uint = 16384;
pub const ExposureMask: libc::c_uint = 32768;
pub const VisibilityChangeMask: libc::c_uint = 65536;
pub const StructureNotifyMask: libc::c_uint = 131072;
pub const ResizeRedirectMask: libc::c_uint = 262144;
pub const SubstructureNotifyMask: libc::c_uint = 524288;
pub const SubstructureRedirectMask: libc::c_uint = 1048576;
pub const FocusChangeMask: libc::c_uint = 2097152;
pub const PropertyChangeMask: libc::c_uint = 4194304;
pub const ColormapChangeMask: libc::c_uint = 8388608;
pub const OwnerGrabButtonMask: libc::c_uint = 16777216;
pub const KeyPress: libc::c_uint = 2;
pub const KeyRelease: libc::c_uint = 3;
pub const ButtonPress: libc::c_uint = 4;
pub const ButtonRelease: libc::c_uint = 5;
pub const MotionNotify: libc::c_uint = 6;
pub const EnterNotify: libc::c_uint = 7;
pub const LeaveNotify: libc::c_uint = 8;
pub const FocusIn: libc::c_uint = 9;
pub const FocusOut: libc::c_uint = 10;
pub const KeymapNotify: libc::c_uint = 11;
pub const Expose: libc::c_uint = 12;
pub const GraphicsExpose: libc::c_uint = 13;
pub const NoExpose: libc::c_uint = 14;
pub const VisibilityNotify: libc::c_uint = 15;
pub const CreateNotify: libc::c_uint = 16;
pub const DestroyNotify: libc::c_uint = 17;
pub const UnmapNotify: libc::c_uint = 18;
pub const MapNotify: libc::c_uint = 19;
pub const MapRequest: libc::c_uint = 20;
pub const ReparentNotify: libc::c_uint = 21;
pub const ConfigureNotify: libc::c_uint = 22;
pub const ConfigureRequest: libc::c_uint = 23;
pub const GravityNotify: libc::c_uint = 24;
pub const ResizeRequest: libc::c_uint = 25;
pub const CirculateNotify: libc::c_uint = 26;
pub const CirculateRequest: libc::c_uint = 27;
pub const PropertyNotify: libc::c_uint = 28;
pub const SelectionClear: libc::c_uint = 29;
pub const SelectionRequest: libc::c_uint = 30;
pub const SelectionNotify: libc::c_uint = 31;
pub const ColormapNotify: libc::c_uint = 32;
pub const ClientMessage: libc::c_uint = 33;
pub const MappingNotify: libc::c_uint = 34;
pub const GenericEvent: libc::c_uint = 35;
pub const LASTEvent: libc::c_uint = 36;
pub const ShiftMask: libc::c_uint = 1;
pub const LockMask: libc::c_uint = 2;
pub const ControlMask: libc::c_uint = 4;
pub const Mod1Mask: libc::c_uint = 8;
pub const Mod2Mask: libc::c_uint = 16;
pub const Mod3Mask: libc::c_uint = 32;
pub const Mod4Mask: libc::c_uint = 64;
pub const Mod5Mask: libc::c_uint = 128;
pub const ShiftMapIndex: libc::c_uint = 0;
pub const LockMapIndex: libc::c_uint = 1;
pub const ControlMapIndex: libc::c_uint = 2;
pub const Mod1MapIndex: libc::c_uint = 3;
pub const Mod2MapIndex: libc::c_uint = 4;
pub const Mod3MapIndex: libc::c_uint = 5;
pub const Mod4MapIndex: libc::c_uint = 6;
pub const Mod5MapIndex: libc::c_uint = 7;
pub const Button1Mask: libc::c_uint = 256;
pub const Button2Mask: libc::c_uint = 512;
pub const Button3Mask: libc::c_uint = 1024;
pub const Button4Mask: libc::c_uint = 2048;
pub const Button5Mask: libc::c_uint = 4096;
pub const AnyModifier: libc::c_uint = 32768;
pub const Button1: libc::c_uint = 1;
pub const Button2: libc::c_uint = 2;
pub const Button3: libc::c_uint = 3;
pub const Button4: libc::c_uint = 4;
pub const Button5: libc::c_uint = 5;
pub const NotifyNormal: libc::c_uint = 0;
pub const NotifyGrab: libc::c_uint = 1;
pub const NotifyUngrab: libc::c_uint = 2;
pub const NotifyWhileGrabbed: libc::c_uint = 3;
pub const NotifyHint: libc::c_uint = 1;
pub const NotifyAncestor: libc::c_uint = 0;
pub const NotifyVirtual: libc::c_uint = 1;
pub const NotifyInferior: libc::c_uint = 2;
pub const NotifyNonlinear: libc::c_uint = 3;
pub const NotifyNonlinearVirtual: libc::c_uint = 4;
pub const NotifyPointer: libc::c_uint = 5;
pub const NotifyPointerRoot: libc::c_uint = 6;
pub const NotifyDetailNone: libc::c_uint = 7;
pub const VisibilityUnobscured: libc::c_uint = 0;
pub const VisibilityPartiallyObscured: libc::c_uint = 1;
pub const VisibilityFullyObscured: libc::c_uint = 2;
pub const PlaceOnTop: libc::c_uint = 0;
pub const PlaceOnBottom: libc::c_uint = 1;
pub const FamilyInternet: libc::c_uint = 0;
pub const FamilyDECnet: libc::c_uint = 1;
pub const FamilyChaos: libc::c_uint = 2;
pub const FamilyInternet6: libc::c_uint = 6;
pub const FamilyServerInterpreted: libc::c_uint = 5;
pub const PropertyNewValue: libc::c_uint = 0;
pub const PropertyDelete: libc::c_uint = 1;
pub const ColormapUninstalled: libc::c_uint = 0;
pub const ColormapInstalled: libc::c_uint = 1;
pub const GrabModeSync: libc::c_uint = 0;
pub const GrabModeAsync: libc::c_uint = 1;
pub const GrabSuccess: libc::c_uint = 0;
pub const AlreadyGrabbed: libc::c_uint = 1;
pub const GrabInvalidTime: libc::c_uint = 2;
pub const GrabNotViewable: libc::c_uint = 3;
pub const GrabFrozen: libc::c_uint = 4;
pub const AsyncPointer: libc::c_uint = 0;
pub const SyncPointer: libc::c_uint = 1;
pub const ReplayPointer: libc::c_uint = 2;
pub const AsyncKeyboard: libc::c_uint = 3;
pub const SyncKeyboard: libc::c_uint = 4;
pub const ReplayKeyboard: libc::c_uint = 5;
pub const AsyncBoth: libc::c_uint = 6;
pub const SyncBoth: libc::c_uint = 7;
pub const RevertToParent: libc::c_uint = 2;
pub const Success: libc::c_uint = 0;
pub const BadRequest: libc::c_uint = 1;
pub const BadValue: libc::c_uint = 2;
pub const BadWindow: libc::c_uint = 3;
pub const BadPixmap: libc::c_uint = 4;
pub const BadAtom: libc::c_uint = 5;
pub const BadCursor: libc::c_uint = 6;
pub const BadFont: libc::c_uint = 7;
pub const BadMatch: libc::c_uint = 8;
pub const BadDrawable: libc::c_uint = 9;
pub const BadAccess: libc::c_uint = 10;
pub const BadAlloc: libc::c_uint = 11;
pub const BadColor: libc::c_uint = 12;
pub const BadGC: libc::c_uint = 13;
pub const BadIDChoice: libc::c_uint = 14;
pub const BadName: libc::c_uint = 15;
pub const BadLength: libc::c_uint = 16;
pub const BadImplementation: libc::c_uint = 17;
pub const FirstExtensionError: libc::c_uint = 128;
pub const LastExtensionError: libc::c_uint = 255;
pub const InputOutput: libc::c_uint = 1;
pub const InputOnly: libc::c_uint = 2;
pub const CWBackPixmap: libc::c_uint = 1;
pub const CWBackPixel: libc::c_uint = 2;
pub const CWBorderPixmap: libc::c_uint = 4;
pub const CWBorderPixel: libc::c_uint = 8;
pub const CWBitGravity: libc::c_uint = 16;
pub const CWWinGravity: libc::c_uint = 32;
pub const CWBackingStore: libc::c_uint = 64;
pub const CWBackingPlanes: libc::c_uint = 128;
pub const CWBackingPixel: libc::c_uint = 256;
pub const CWOverrideRedirect: libc::c_uint = 512;
pub const CWSaveUnder: libc::c_uint = 1024;
pub const CWEventMask: libc::c_uint = 2048;
pub const CWDontPropagate: libc::c_uint = 4096;
pub const CWColormap: libc::c_uint = 8192;
pub const CWCursor: libc::c_uint = 16384;
pub const CWX: libc::c_uint = 1;
pub const CWY: libc::c_uint = 2;
pub const CWWidth: libc::c_uint = 4;
pub const CWHeight: libc::c_uint = 8;
pub const CWBorderWidth: libc::c_uint = 16;
pub const CWSibling: libc::c_uint = 32;
pub const CWStackMode: libc::c_uint = 64;
pub const ForgetGravity: libc::c_uint = 0;
pub const NorthWestGravity: libc::c_uint = 1;
pub const NorthGravity: libc::c_uint = 2;
pub const NorthEastGravity: libc::c_uint = 3;
pub const WestGravity: libc::c_uint = 4;
pub const CenterGravity: libc::c_uint = 5;
pub const EastGravity: libc::c_uint = 6;
pub const SouthWestGravity: libc::c_uint = 7;
pub const SouthGravity: libc::c_uint = 8;
pub const SouthEastGravity: libc::c_uint = 9;
pub const StaticGravity: libc::c_uint = 10;
pub const UnmapGravity: libc::c_uint = 0;
pub const NotUseful: libc::c_uint = 0;
pub const WhenMapped: libc::c_uint = 1;
pub const Always: libc::c_uint = 2;
pub const IsUnmapped: libc::c_uint = 0;
pub const IsUnviewable: libc::c_uint = 1;
pub const IsViewable: libc::c_uint = 2;
pub const SetModeInsert: libc::c_uint = 0;
pub const SetModeDelete: libc::c_uint = 1;
pub const DestroyAll: libc::c_uint = 0;
pub const RetainPermanent: libc::c_uint = 1;
pub const RetainTemporary: libc::c_uint = 2;
pub const Above: libc::c_uint = 0;
pub const Below: libc::c_uint = 1;
pub const TopIf: libc::c_uint = 2;
pub const BottomIf: libc::c_uint = 3;
pub const Opposite: libc::c_uint = 4;
pub const RaiseLowest: libc::c_uint = 0;
pub const LowerHighest: libc::c_uint = 1;
pub const PropModeReplace: libc::c_uint = 0;
pub const PropModePrepend: libc::c_uint = 1;
pub const PropModeAppend: libc::c_uint = 2;
pub const GXclear: libc::c_uint = 0;
pub const GXand: libc::c_uint = 1;
pub const GXandReverse: libc::c_uint = 2;
pub const GXcopy: libc::c_uint = 3;
pub const GXandInverted: libc::c_uint = 4;
pub const GXnoop: libc::c_uint = 5;
pub const GXxor: libc::c_uint = 6;
pub const GXor: libc::c_uint = 7;
pub const GXnor: libc::c_uint = 8;
pub const GXequiv: libc::c_uint = 9;
pub const GXinvert: libc::c_uint = 10;
pub const GXorReverse: libc::c_uint = 11;
pub const GXcopyInverted: libc::c_uint = 12;
pub const GXorInverted: libc::c_uint = 13;
pub const GXnand: libc::c_uint = 14;
pub const GXset: libc::c_uint = 15;
pub const LineSolid: libc::c_uint = 0;
pub const LineOnOffDash: libc::c_uint = 1;
pub const LineDoubleDash: libc::c_uint = 2;
pub const CapNotLast: libc::c_uint = 0;
pub const CapButt: libc::c_uint = 1;
pub const CapRound: libc::c_uint = 2;
pub const CapProjecting: libc::c_uint = 3;
pub const JoinMiter: libc::c_uint = 0;
pub const JoinRound: libc::c_uint = 1;
pub const JoinBevel: libc::c_uint = 2;
pub const FillSolid: libc::c_uint = 0;
pub const FillTiled: libc::c_uint = 1;
pub const FillStippled: libc::c_uint = 2;
pub const FillOpaqueStippled: libc::c_uint = 3;
pub const EvenOddRule: libc::c_uint = 0;
pub const WindingRule: libc::c_uint = 1;
pub const ClipByChildren: libc::c_uint = 0;
pub const IncludeInferiors: libc::c_uint = 1;
pub const Unsorted: libc::c_uint = 0;
pub const YSorted: libc::c_uint = 1;
pub const YXSorted: libc::c_uint = 2;
pub const YXBanded: libc::c_uint = 3;
pub const CoordModeOrigin: libc::c_uint = 0;
pub const CoordModePrevious: libc::c_uint = 1;
pub const Complex: libc::c_uint = 0;
pub const Nonconvex: libc::c_uint = 1;
pub const Convex: libc::c_uint = 2;
pub const ArcChord: libc::c_uint = 0;
pub const ArcPieSlice: libc::c_uint = 1;
pub const GCFunction: libc::c_uint = 1;
pub const GCPlaneMask: libc::c_uint = 2;
pub const GCForeground: libc::c_uint = 4;
pub const GCBackground: libc::c_uint = 8;
pub const GCLineWidth: libc::c_uint = 16;
pub const GCLineStyle: libc::c_uint = 32;
pub const GCCapStyle: libc::c_uint = 64;
pub const GCJoinStyle: libc::c_uint = 128;
pub const GCFillStyle: libc::c_uint = 256;
pub const GCFillRule: libc::c_uint = 512;
pub const GCTile: libc::c_uint = 1024;
pub const GCStipple: libc::c_uint = 2048;
pub const GCTileStipXOrigin: libc::c_uint = 4096;
pub const GCTileStipYOrigin: libc::c_uint = 8192;
pub const GCFont: libc::c_uint = 16384;
pub const GCSubwindowMode: libc::c_uint = 32768;
pub const GCGraphicsExposures: libc::c_uint = 65536;
pub const GCClipXOrigin: libc::c_uint = 131072;
pub const GCClipYOrigin: libc::c_uint = 262144;
pub const GCClipMask: libc::c_uint = 524288;
pub const GCDashOffset: libc::c_uint = 1048576;
pub const GCDashList: libc::c_uint = 2097152;
pub const GCArcMode: libc::c_uint = 4194304;
pub const GCLastBit: libc::c_uint = 22;
pub const FontLeftToRight: libc::c_uint = 0;
pub const FontRightToLeft: libc::c_uint = 1;
pub const FontChange: libc::c_uint = 255;
pub const XYBitmap: libc::c_uint = 0;
pub const XYPixmap: libc::c_uint = 1;
pub const ZPixmap: libc::c_uint = 2;
pub const AllocNone: libc::c_uint = 0;
pub const AllocAll: libc::c_uint = 1;
pub const DoRed: libc::c_uint = 1;
pub const DoGreen: libc::c_uint = 2;
pub const DoBlue: libc::c_uint = 4;
pub const CursorShape: libc::c_uint = 0;
pub const TileShape: libc::c_uint = 1;
pub const StippleShape: libc::c_uint = 2;
pub const AutoRepeatModeOff: libc::c_uint = 0;
pub const AutoRepeatModeOn: libc::c_uint = 1;
pub const AutoRepeatModeDefault: libc::c_uint = 2;
pub const LedModeOff: libc::c_uint = 0;
pub const LedModeOn: libc::c_uint = 1;
pub const KBKeyClickPercent: libc::c_uint = 1;
pub const KBBellPercent: libc::c_uint = 2;
pub const KBBellPitch: libc::c_uint = 4;
pub const KBBellDuration: libc::c_uint = 8;
pub const KBLed: libc::c_uint = 16;
pub const KBLedMode: libc::c_uint = 32;
pub const KBKey: libc::c_uint = 64;
pub const KBAutoRepeatMode: libc::c_uint = 128;
pub const MappingSuccess: libc::c_uint = 0;
pub const MappingBusy: libc::c_uint = 1;
pub const MappingFailed: libc::c_uint = 2;
pub const MappingModifier: libc::c_uint = 0;
pub const MappingKeyboard: libc::c_uint = 1;
pub const MappingPointer: libc::c_uint = 2;
pub const DontPreferBlanking: libc::c_uint = 0;
pub const PreferBlanking: libc::c_uint = 1;
pub const DefaultBlanking: libc::c_uint = 2;
pub const DisableScreenSaver: libc::c_uint = 0;
pub const DisableScreenInterval: libc::c_uint = 0;
pub const DontAllowExposures: libc::c_uint = 0;
pub const AllowExposures: libc::c_uint = 1;
pub const DefaultExposures: libc::c_uint = 2;
pub const ScreenSaverReset: libc::c_uint = 0;
pub const ScreenSaverActive: libc::c_uint = 1;
pub const HostInsert: libc::c_uint = 0;
pub const HostDelete: libc::c_uint = 1;
pub const EnableAccess: libc::c_uint = 1;
pub const DisableAccess: libc::c_uint = 0;
pub const StaticGray: libc::c_uint = 0;
pub const GrayScale: libc::c_uint = 1;
pub const StaticColor: libc::c_uint = 2;
pub const PseudoColor: libc::c_uint = 3;
pub const TrueColor: libc::c_uint = 4;
pub const DirectColor: libc::c_uint = 5;
pub const LSBFirst: libc::c_uint = 0;
pub const MSBFirst: libc::c_uint = 1;
pub const NeedFunctionPrototypes: libc::c_uint = 1;
pub const NeedVarargsPrototypes: libc::c_uint = 1;
pub const NeedNestedPrototypes: libc::c_uint = 1;
pub const FUNCPROTO: libc::c_uint = 15;
pub const NeedWidePrototypes: libc::c_uint = 0;
pub const X_HAVE_UTF8_STRING: libc::c_uint = 1;
pub const True: libc::c_uint = 1;
pub const False: libc::c_uint = 0;
pub const QueuedAlready: libc::c_uint = 0;
pub const QueuedAfterReading: libc::c_uint = 1;
pub const QueuedAfterFlush: libc::c_uint = 2;
pub const XNRequiredCharSet: &'static [u8; 16usize] = b"requiredCharSet\x00";
pub const XNQueryOrientation: &'static [u8; 17usize] =
    b"queryOrientation\x00";
pub const XNBaseFontName: &'static [u8; 13usize] = b"baseFontName\x00";
pub const XNOMAutomatic: &'static [u8; 12usize] = b"omAutomatic\x00";
pub const XNMissingCharSet: &'static [u8; 15usize] = b"missingCharSet\x00";
pub const XNDefaultString: &'static [u8; 14usize] = b"defaultString\x00";
pub const XNOrientation: &'static [u8; 12usize] = b"orientation\x00";
pub const XNDirectionalDependentDrawing: &'static [u8; 28usize] =
    b"directionalDependentDrawing\x00";
pub const XNContextualDrawing: &'static [u8; 18usize] =
    b"contextualDrawing\x00";
pub const XNFontInfo: &'static [u8; 9usize] = b"fontInfo\x00";
pub const XIMPreeditArea: libc::c_uint = 1;
pub const XIMPreeditCallbacks: libc::c_uint = 2;
pub const XIMPreeditPosition: libc::c_uint = 4;
pub const XIMPreeditNothing: libc::c_uint = 8;
pub const XIMPreeditNone: libc::c_uint = 16;
pub const XIMStatusArea: libc::c_uint = 256;
pub const XIMStatusCallbacks: libc::c_uint = 512;
pub const XIMStatusNothing: libc::c_uint = 1024;
pub const XIMStatusNone: libc::c_uint = 2048;
pub const XNVaNestedList: &'static [u8; 15usize] = b"XNVaNestedList\x00";
pub const XNQueryInputStyle: &'static [u8; 16usize] = b"queryInputStyle\x00";
pub const XNClientWindow: &'static [u8; 13usize] = b"clientWindow\x00";
pub const XNInputStyle: &'static [u8; 11usize] = b"inputStyle\x00";
pub const XNFocusWindow: &'static [u8; 12usize] = b"focusWindow\x00";
pub const XNResourceName: &'static [u8; 13usize] = b"resourceName\x00";
pub const XNResourceClass: &'static [u8; 14usize] = b"resourceClass\x00";
pub const XNGeometryCallback: &'static [u8; 17usize] =
    b"geometryCallback\x00";
pub const XNDestroyCallback: &'static [u8; 16usize] = b"destroyCallback\x00";
pub const XNFilterEvents: &'static [u8; 13usize] = b"filterEvents\x00";
pub const XNPreeditStartCallback: &'static [u8; 21usize] =
    b"preeditStartCallback\x00";
pub const XNPreeditDoneCallback: &'static [u8; 20usize] =
    b"preeditDoneCallback\x00";
pub const XNPreeditDrawCallback: &'static [u8; 20usize] =
    b"preeditDrawCallback\x00";
pub const XNPreeditCaretCallback: &'static [u8; 21usize] =
    b"preeditCaretCallback\x00";
pub const XNPreeditStateNotifyCallback: &'static [u8; 27usize] =
    b"preeditStateNotifyCallback\x00";
pub const XNPreeditAttributes: &'static [u8; 18usize] =
    b"preeditAttributes\x00";
pub const XNStatusStartCallback: &'static [u8; 20usize] =
    b"statusStartCallback\x00";
pub const XNStatusDoneCallback: &'static [u8; 19usize] =
    b"statusDoneCallback\x00";
pub const XNStatusDrawCallback: &'static [u8; 19usize] =
    b"statusDrawCallback\x00";
pub const XNStatusAttributes: &'static [u8; 17usize] =
    b"statusAttributes\x00";
pub const XNArea: &'static [u8; 5usize] = b"area\x00";
pub const XNAreaNeeded: &'static [u8; 11usize] = b"areaNeeded\x00";
pub const XNSpotLocation: &'static [u8; 13usize] = b"spotLocation\x00";
pub const XNColormap: &'static [u8; 9usize] = b"colorMap\x00";
pub const XNStdColormap: &'static [u8; 12usize] = b"stdColorMap\x00";
pub const XNForeground: &'static [u8; 11usize] = b"foreground\x00";
pub const XNBackground: &'static [u8; 11usize] = b"background\x00";
pub const XNBackgroundPixmap: &'static [u8; 17usize] =
    b"backgroundPixmap\x00";
pub const XNFontSet: &'static [u8; 8usize] = b"fontSet\x00";
pub const XNLineSpace: &'static [u8; 10usize] = b"lineSpace\x00";
pub const XNCursor: &'static [u8; 7usize] = b"cursor\x00";
pub const XNQueryIMValuesList: &'static [u8; 18usize] =
    b"queryIMValuesList\x00";
pub const XNQueryICValuesList: &'static [u8; 18usize] =
    b"queryICValuesList\x00";
pub const XNVisiblePosition: &'static [u8; 16usize] = b"visiblePosition\x00";
pub const XNR6PreeditCallback: &'static [u8; 18usize] =
    b"r6PreeditCallback\x00";
pub const XNStringConversionCallback: &'static [u8; 25usize] =
    b"stringConversionCallback\x00";
pub const XNStringConversion: &'static [u8; 17usize] =
    b"stringConversion\x00";
pub const XNResetState: &'static [u8; 11usize] = b"resetState\x00";
pub const XNHotKey: &'static [u8; 7usize] = b"hotKey\x00";
pub const XNHotKeyState: &'static [u8; 12usize] = b"hotKeyState\x00";
pub const XNPreeditState: &'static [u8; 13usize] = b"preeditState\x00";
pub const XNSeparatorofNestedList: &'static [u8; 22usize] =
    b"separatorofNestedList\x00";
pub const XBufferOverflow: libc::c_int = -1;
pub const XLookupNone: libc::c_uint = 1;
pub const XLookupChars: libc::c_uint = 2;
pub const XLookupKeySym: libc::c_uint = 3;
pub const XLookupBoth: libc::c_uint = 4;
pub const XIMReverse: libc::c_uint = 1;
pub const XIMUnderline: libc::c_uint = 2;
pub const XIMHighlight: libc::c_uint = 4;
pub const XIMPrimary: libc::c_uint = 32;
pub const XIMSecondary: libc::c_uint = 64;
pub const XIMTertiary: libc::c_uint = 128;
pub const XIMVisibleToForward: libc::c_uint = 256;
pub const XIMVisibleToBackword: libc::c_uint = 512;
pub const XIMVisibleToCenter: libc::c_uint = 1024;
pub const XIMPreeditUnKnown: libc::c_uint = 0;
pub const XIMPreeditEnable: libc::c_uint = 1;
pub const XIMPreeditDisable: libc::c_uint = 2;
pub const XIMInitialState: libc::c_uint = 1;
pub const XIMPreserveState: libc::c_uint = 2;
pub const XIMStringConversionLeftEdge: libc::c_uint = 1;
pub const XIMStringConversionRightEdge: libc::c_uint = 2;
pub const XIMStringConversionTopEdge: libc::c_uint = 4;
pub const XIMStringConversionBottomEdge: libc::c_uint = 8;
pub const XIMStringConversionConcealed: libc::c_uint = 16;
pub const XIMStringConversionWrapped: libc::c_uint = 32;
pub const XIMStringConversionBuffer: libc::c_uint = 1;
pub const XIMStringConversionLine: libc::c_uint = 2;
pub const XIMStringConversionWord: libc::c_uint = 3;
pub const XIMStringConversionChar: libc::c_uint = 4;
pub const XIMStringConversionSubstitution: libc::c_uint = 1;
pub const XIMStringConversionRetrieval: libc::c_uint = 2;
pub const XIMHotKeyStateON: libc::c_uint = 1;
pub const XIMHotKeyStateOFF: libc::c_uint = 2;
pub const _STDINT_H: libc::c_uint = 1;
pub const __GLIBC_USE_LIB_EXT2: libc::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: libc::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: libc::c_uint = 0;
pub const _BITS_WCHAR_H: libc::c_uint = 1;
pub const INT8_MIN: libc::c_int = -128;
pub const INT16_MIN: libc::c_int = -32768;
pub const INT32_MIN: libc::c_int = -2147483648;
pub const INT8_MAX: libc::c_uint = 127;
pub const INT16_MAX: libc::c_uint = 32767;
pub const INT32_MAX: libc::c_uint = 2147483647;
pub const UINT8_MAX: libc::c_uint = 255;
pub const UINT16_MAX: libc::c_uint = 65535;
pub const UINT32_MAX: libc::c_uint = 4294967295;
pub const INT_LEAST8_MIN: libc::c_int = -128;
pub const INT_LEAST16_MIN: libc::c_int = -32768;
pub const INT_LEAST32_MIN: libc::c_int = -2147483648;
pub const INT_LEAST8_MAX: libc::c_uint = 127;
pub const INT_LEAST16_MAX: libc::c_uint = 32767;
pub const INT_LEAST32_MAX: libc::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: libc::c_uint = 255;
pub const UINT_LEAST16_MAX: libc::c_uint = 65535;
pub const UINT_LEAST32_MAX: libc::c_uint = 4294967295;
pub const INT_FAST8_MIN: libc::c_int = -128;
pub const INT_FAST16_MIN: libc::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: libc::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: libc::c_uint = 127;
pub const INT_FAST16_MAX: libc::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: libc::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: libc::c_uint = 255;
pub const UINT_FAST16_MAX: libc::c_int = -1;
pub const UINT_FAST32_MAX: libc::c_int = -1;
pub const INTPTR_MIN: libc::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: libc::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: libc::c_int = -1;
pub const PTRDIFF_MIN: libc::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: libc::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: libc::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: libc::c_uint = 2147483647;
pub const SIZE_MAX: libc::c_int = -1;
pub const WINT_MIN: libc::c_uint = 0;
pub const WINT_MAX: libc::c_uint = 4294967295;
pub const _SYS_UIO_H: libc::c_uint = 1;
pub const _BITS_UIO_H: libc::c_uint = 1;
pub const UIO_MAXIOV: libc::c_uint = 1024;
pub const _PTHREAD_H: libc::c_uint = 1;
pub const _SCHED_H: libc::c_uint = 1;
pub const SCHED_OTHER: libc::c_uint = 0;
pub const SCHED_FIFO: libc::c_uint = 1;
pub const SCHED_RR: libc::c_uint = 2;
pub const __defined_schedparam: libc::c_uint = 1;
pub const __CPU_SETSIZE: libc::c_uint = 1024;
pub const _TIME_H: libc::c_uint = 1;
pub const _BITS_TIME_H: libc::c_uint = 1;
pub const CLOCK_REALTIME: libc::c_uint = 0;
pub const CLOCK_MONOTONIC: libc::c_uint = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: libc::c_uint = 2;
pub const CLOCK_THREAD_CPUTIME_ID: libc::c_uint = 3;
pub const CLOCK_MONOTONIC_RAW: libc::c_uint = 4;
pub const CLOCK_REALTIME_COARSE: libc::c_uint = 5;
pub const CLOCK_MONOTONIC_COARSE: libc::c_uint = 6;
pub const CLOCK_BOOTTIME: libc::c_uint = 7;
pub const CLOCK_REALTIME_ALARM: libc::c_uint = 8;
pub const CLOCK_BOOTTIME_ALARM: libc::c_uint = 9;
pub const CLOCK_TAI: libc::c_uint = 11;
pub const TIMER_ABSTIME: libc::c_uint = 1;
pub const __struct_tm_defined: libc::c_uint = 1;
pub const __itimerspec_defined: libc::c_uint = 1;
pub const _XLOCALE_H: libc::c_uint = 1;
pub const TIME_UTC: libc::c_uint = 1;
pub const _BITS_SETJMP_H: libc::c_uint = 1;
pub const PTHREAD_ONCE_INIT: libc::c_uint = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: libc::c_int = -1;
pub const X_TCP_PORT: libc::c_uint = 6000;
pub const XCB_CONN_ERROR: libc::c_uint = 1;
pub const XCB_CONN_CLOSED_EXT_NOTSUPPORTED: libc::c_uint = 2;
pub const XCB_CONN_CLOSED_MEM_INSUFFICIENT: libc::c_uint = 3;
pub const XCB_CONN_CLOSED_REQ_LEN_EXCEED: libc::c_uint = 4;
pub const XCB_CONN_CLOSED_PARSE_ERR: libc::c_uint = 5;
pub const XCB_CONN_CLOSED_INVALID_SCREEN: libc::c_uint = 6;
pub const XCB_CONN_CLOSED_FDPASSING_FAILED: libc::c_uint = 7;
pub const XCB_KEY_PRESS: libc::c_uint = 2;
pub const XCB_KEY_RELEASE: libc::c_uint = 3;
pub const XCB_BUTTON_PRESS: libc::c_uint = 4;
pub const XCB_BUTTON_RELEASE: libc::c_uint = 5;
pub const XCB_MOTION_NOTIFY: libc::c_uint = 6;
pub const XCB_ENTER_NOTIFY: libc::c_uint = 7;
pub const XCB_LEAVE_NOTIFY: libc::c_uint = 8;
pub const XCB_FOCUS_IN: libc::c_uint = 9;
pub const XCB_FOCUS_OUT: libc::c_uint = 10;
pub const XCB_KEYMAP_NOTIFY: libc::c_uint = 11;
pub const XCB_EXPOSE: libc::c_uint = 12;
pub const XCB_GRAPHICS_EXPOSURE: libc::c_uint = 13;
pub const XCB_NO_EXPOSURE: libc::c_uint = 14;
pub const XCB_VISIBILITY_NOTIFY: libc::c_uint = 15;
pub const XCB_CREATE_NOTIFY: libc::c_uint = 16;
pub const XCB_DESTROY_NOTIFY: libc::c_uint = 17;
pub const XCB_UNMAP_NOTIFY: libc::c_uint = 18;
pub const XCB_MAP_NOTIFY: libc::c_uint = 19;
pub const XCB_MAP_REQUEST: libc::c_uint = 20;
pub const XCB_REPARENT_NOTIFY: libc::c_uint = 21;
pub const XCB_CONFIGURE_NOTIFY: libc::c_uint = 22;
pub const XCB_CONFIGURE_REQUEST: libc::c_uint = 23;
pub const XCB_GRAVITY_NOTIFY: libc::c_uint = 24;
pub const XCB_RESIZE_REQUEST: libc::c_uint = 25;
pub const XCB_CIRCULATE_NOTIFY: libc::c_uint = 26;
pub const XCB_CIRCULATE_REQUEST: libc::c_uint = 27;
pub const XCB_PROPERTY_NOTIFY: libc::c_uint = 28;
pub const XCB_SELECTION_CLEAR: libc::c_uint = 29;
pub const XCB_SELECTION_REQUEST: libc::c_uint = 30;
pub const XCB_SELECTION_NOTIFY: libc::c_uint = 31;
pub const XCB_COLORMAP_NOTIFY: libc::c_uint = 32;
pub const XCB_CLIENT_MESSAGE: libc::c_uint = 33;
pub const XCB_MAPPING_NOTIFY: libc::c_uint = 34;
pub const XCB_GE_GENERIC: libc::c_uint = 35;
pub const XCB_REQUEST: libc::c_uint = 1;
pub const XCB_VALUE: libc::c_uint = 2;
pub const XCB_WINDOW: libc::c_uint = 3;
pub const XCB_PIXMAP: libc::c_uint = 4;
pub const XCB_ATOM: libc::c_uint = 5;
pub const XCB_CURSOR: libc::c_uint = 6;
pub const XCB_FONT: libc::c_uint = 7;
pub const XCB_MATCH: libc::c_uint = 8;
pub const XCB_DRAWABLE: libc::c_uint = 9;
pub const XCB_ACCESS: libc::c_uint = 10;
pub const XCB_ALLOC: libc::c_uint = 11;
pub const XCB_COLORMAP: libc::c_uint = 12;
pub const XCB_G_CONTEXT: libc::c_uint = 13;
pub const XCB_ID_CHOICE: libc::c_uint = 14;
pub const XCB_NAME: libc::c_uint = 15;
pub const XCB_LENGTH: libc::c_uint = 16;
pub const XCB_IMPLEMENTATION: libc::c_uint = 17;
pub const XCB_CREATE_WINDOW: libc::c_uint = 1;
pub const XCB_CHANGE_WINDOW_ATTRIBUTES: libc::c_uint = 2;
pub const XCB_GET_WINDOW_ATTRIBUTES: libc::c_uint = 3;
pub const XCB_DESTROY_WINDOW: libc::c_uint = 4;
pub const XCB_DESTROY_SUBWINDOWS: libc::c_uint = 5;
pub const XCB_CHANGE_SAVE_SET: libc::c_uint = 6;
pub const XCB_REPARENT_WINDOW: libc::c_uint = 7;
pub const XCB_MAP_WINDOW: libc::c_uint = 8;
pub const XCB_MAP_SUBWINDOWS: libc::c_uint = 9;
pub const XCB_UNMAP_WINDOW: libc::c_uint = 10;
pub const XCB_UNMAP_SUBWINDOWS: libc::c_uint = 11;
pub const XCB_CONFIGURE_WINDOW: libc::c_uint = 12;
pub const XCB_CIRCULATE_WINDOW: libc::c_uint = 13;
pub const XCB_GET_GEOMETRY: libc::c_uint = 14;
pub const XCB_QUERY_TREE: libc::c_uint = 15;
pub const XCB_INTERN_ATOM: libc::c_uint = 16;
pub const XCB_GET_ATOM_NAME: libc::c_uint = 17;
pub const XCB_CHANGE_PROPERTY: libc::c_uint = 18;
pub const XCB_DELETE_PROPERTY: libc::c_uint = 19;
pub const XCB_GET_PROPERTY: libc::c_uint = 20;
pub const XCB_LIST_PROPERTIES: libc::c_uint = 21;
pub const XCB_SET_SELECTION_OWNER: libc::c_uint = 22;
pub const XCB_GET_SELECTION_OWNER: libc::c_uint = 23;
pub const XCB_CONVERT_SELECTION: libc::c_uint = 24;
pub const XCB_SEND_EVENT: libc::c_uint = 25;
pub const XCB_GRAB_POINTER: libc::c_uint = 26;
pub const XCB_UNGRAB_POINTER: libc::c_uint = 27;
pub const XCB_GRAB_BUTTON: libc::c_uint = 28;
pub const XCB_UNGRAB_BUTTON: libc::c_uint = 29;
pub const XCB_CHANGE_ACTIVE_POINTER_GRAB: libc::c_uint = 30;
pub const XCB_GRAB_KEYBOARD: libc::c_uint = 31;
pub const XCB_UNGRAB_KEYBOARD: libc::c_uint = 32;
pub const XCB_GRAB_KEY: libc::c_uint = 33;
pub const XCB_UNGRAB_KEY: libc::c_uint = 34;
pub const XCB_ALLOW_EVENTS: libc::c_uint = 35;
pub const XCB_GRAB_SERVER: libc::c_uint = 36;
pub const XCB_UNGRAB_SERVER: libc::c_uint = 37;
pub const XCB_QUERY_POINTER: libc::c_uint = 38;
pub const XCB_GET_MOTION_EVENTS: libc::c_uint = 39;
pub const XCB_TRANSLATE_COORDINATES: libc::c_uint = 40;
pub const XCB_WARP_POINTER: libc::c_uint = 41;
pub const XCB_SET_INPUT_FOCUS: libc::c_uint = 42;
pub const XCB_GET_INPUT_FOCUS: libc::c_uint = 43;
pub const XCB_QUERY_KEYMAP: libc::c_uint = 44;
pub const XCB_OPEN_FONT: libc::c_uint = 45;
pub const XCB_CLOSE_FONT: libc::c_uint = 46;
pub const XCB_QUERY_FONT: libc::c_uint = 47;
pub const XCB_QUERY_TEXT_EXTENTS: libc::c_uint = 48;
pub const XCB_LIST_FONTS: libc::c_uint = 49;
pub const XCB_LIST_FONTS_WITH_INFO: libc::c_uint = 50;
pub const XCB_SET_FONT_PATH: libc::c_uint = 51;
pub const XCB_GET_FONT_PATH: libc::c_uint = 52;
pub const XCB_CREATE_PIXMAP: libc::c_uint = 53;
pub const XCB_FREE_PIXMAP: libc::c_uint = 54;
pub const XCB_CREATE_GC: libc::c_uint = 55;
pub const XCB_CHANGE_GC: libc::c_uint = 56;
pub const XCB_COPY_GC: libc::c_uint = 57;
pub const XCB_SET_DASHES: libc::c_uint = 58;
pub const XCB_SET_CLIP_RECTANGLES: libc::c_uint = 59;
pub const XCB_FREE_GC: libc::c_uint = 60;
pub const XCB_CLEAR_AREA: libc::c_uint = 61;
pub const XCB_COPY_AREA: libc::c_uint = 62;
pub const XCB_COPY_PLANE: libc::c_uint = 63;
pub const XCB_POLY_POINT: libc::c_uint = 64;
pub const XCB_POLY_LINE: libc::c_uint = 65;
pub const XCB_POLY_SEGMENT: libc::c_uint = 66;
pub const XCB_POLY_RECTANGLE: libc::c_uint = 67;
pub const XCB_POLY_ARC: libc::c_uint = 68;
pub const XCB_FILL_POLY: libc::c_uint = 69;
pub const XCB_POLY_FILL_RECTANGLE: libc::c_uint = 70;
pub const XCB_POLY_FILL_ARC: libc::c_uint = 71;
pub const XCB_PUT_IMAGE: libc::c_uint = 72;
pub const XCB_GET_IMAGE: libc::c_uint = 73;
pub const XCB_POLY_TEXT_8: libc::c_uint = 74;
pub const XCB_POLY_TEXT_16: libc::c_uint = 75;
pub const XCB_IMAGE_TEXT_8: libc::c_uint = 76;
pub const XCB_IMAGE_TEXT_16: libc::c_uint = 77;
pub const XCB_CREATE_COLORMAP: libc::c_uint = 78;
pub const XCB_FREE_COLORMAP: libc::c_uint = 79;
pub const XCB_COPY_COLORMAP_AND_FREE: libc::c_uint = 80;
pub const XCB_INSTALL_COLORMAP: libc::c_uint = 81;
pub const XCB_UNINSTALL_COLORMAP: libc::c_uint = 82;
pub const XCB_LIST_INSTALLED_COLORMAPS: libc::c_uint = 83;
pub const XCB_ALLOC_COLOR: libc::c_uint = 84;
pub const XCB_ALLOC_NAMED_COLOR: libc::c_uint = 85;
pub const XCB_ALLOC_COLOR_CELLS: libc::c_uint = 86;
pub const XCB_ALLOC_COLOR_PLANES: libc::c_uint = 87;
pub const XCB_FREE_COLORS: libc::c_uint = 88;
pub const XCB_STORE_COLORS: libc::c_uint = 89;
pub const XCB_STORE_NAMED_COLOR: libc::c_uint = 90;
pub const XCB_QUERY_COLORS: libc::c_uint = 91;
pub const XCB_LOOKUP_COLOR: libc::c_uint = 92;
pub const XCB_CREATE_CURSOR: libc::c_uint = 93;
pub const XCB_CREATE_GLYPH_CURSOR: libc::c_uint = 94;
pub const XCB_FREE_CURSOR: libc::c_uint = 95;
pub const XCB_RECOLOR_CURSOR: libc::c_uint = 96;
pub const XCB_QUERY_BEST_SIZE: libc::c_uint = 97;
pub const XCB_QUERY_EXTENSION: libc::c_uint = 98;
pub const XCB_LIST_EXTENSIONS: libc::c_uint = 99;
pub const XCB_CHANGE_KEYBOARD_MAPPING: libc::c_uint = 100;
pub const XCB_GET_KEYBOARD_MAPPING: libc::c_uint = 101;
pub const XCB_CHANGE_KEYBOARD_CONTROL: libc::c_uint = 102;
pub const XCB_GET_KEYBOARD_CONTROL: libc::c_uint = 103;
pub const XCB_BELL: libc::c_uint = 104;
pub const XCB_CHANGE_POINTER_CONTROL: libc::c_uint = 105;
pub const XCB_GET_POINTER_CONTROL: libc::c_uint = 106;
pub const XCB_SET_SCREEN_SAVER: libc::c_uint = 107;
pub const XCB_GET_SCREEN_SAVER: libc::c_uint = 108;
pub const XCB_CHANGE_HOSTS: libc::c_uint = 109;
pub const XCB_LIST_HOSTS: libc::c_uint = 110;
pub const XCB_SET_ACCESS_CONTROL: libc::c_uint = 111;
pub const XCB_SET_CLOSE_DOWN_MODE: libc::c_uint = 112;
pub const XCB_KILL_CLIENT: libc::c_uint = 113;
pub const XCB_ROTATE_PROPERTIES: libc::c_uint = 114;
pub const XCB_FORCE_SCREEN_SAVER: libc::c_uint = 115;
pub const XCB_SET_POINTER_MAPPING: libc::c_uint = 116;
pub const XCB_GET_POINTER_MAPPING: libc::c_uint = 117;
pub const XCB_SET_MODIFIER_MAPPING: libc::c_uint = 118;
pub const XCB_GET_MODIFIER_MAPPING: libc::c_uint = 119;
pub const XCB_NO_OPERATION: libc::c_uint = 127;
pub const XCB_NONE: libc::c_uint = 0;
pub const XCB_COPY_FROM_PARENT: libc::c_uint = 0;
pub const XCB_CURRENT_TIME: libc::c_uint = 0;
pub const XCB_NO_SYMBOL: libc::c_uint = 0;
pub type sn_size_t = libc::c_ulong;
pub type sn_bool_t = libc::c_int;
pub type SnPaddingFunc = ::std::option::Option<unsafe extern "C" fn()>;
pub type SnFreeFunc =
    ::std::option::Option<unsafe extern "C" fn(data: *mut libc::c_void)>;
extern "C" {
    pub fn sn_malloc(n_bytes: sn_size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn sn_malloc0(n_bytes: sn_size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn sn_realloc(mem: *mut libc::c_void, n_bytes: sn_size_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn sn_free(mem: *mut libc::c_void);
}
extern "C" {
    pub fn sn_try_malloc(n_bytes: sn_size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn sn_try_realloc(mem: *mut libc::c_void, n_bytes: sn_size_t)
     -> *mut libc::c_void;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_1 {
    pub malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: sn_size_t)
                                          -> *mut libc::c_void>,
    pub realloc: ::std::option::Option<unsafe extern "C" fn(mem:
                                                                *mut libc::c_void,
                                                            n_bytes:
                                                                sn_size_t)
                                           -> *mut libc::c_void>,
    pub free: ::std::option::Option<unsafe extern "C" fn(mem:
                                                             *mut libc::c_void)>,
    pub calloc: ::std::option::Option<unsafe extern "C" fn(n_blocks:
                                                               sn_size_t,
                                                           n_block_bytes:
                                                               sn_size_t)
                                          -> *mut libc::c_void>,
    pub try_malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes:
                                                                   sn_size_t)
                                              -> *mut libc::c_void>,
    pub try_realloc: ::std::option::Option<unsafe extern "C" fn(mem:
                                                                    *mut libc::c_void,
                                                                n_bytes:
                                                                    sn_size_t)
                                               -> *mut libc::c_void>,
    pub padding1: SnPaddingFunc,
    pub padding2: SnPaddingFunc,
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_1>() , 64usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_1>() , 8usize);
}
impl Clone for _bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
pub type SnMemVTable = _bindgen_ty_1;
extern "C" {
    pub fn sn_mem_set_vtable(vtable: *mut SnMemVTable);
}
extern "C" {
    pub fn sn_mem_is_system_malloc() -> sn_bool_t;
}
pub type SnUtf8ValidateFunc =
    ::std::option::Option<unsafe extern "C" fn(str: *const libc::c_char,
                                               max_len: libc::c_int)
                              -> libc::c_int>;
extern "C" {
    pub fn sn_set_utf8_validator(validate_func: SnUtf8ValidateFunc);
}
pub type __u_char = libc::c_uchar;
pub type __u_short = libc::c_ushort;
pub type __u_int = libc::c_uint;
pub type __u_long = libc::c_ulong;
pub type __int8_t = libc::c_char;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __quad_t = libc::c_long;
pub type __u_quad_t = libc::c_ulong;
pub type __intmax_t = libc::c_long;
pub type __uintmax_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_2 {
    pub __val: [libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_2>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_2>() , 4usize);
}
impl Clone for _bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
pub type __fsid_t = _bindgen_ty_2;
pub type __clock_t = libc::c_long;
pub type __rlim_t = libc::c_ulong;
pub type __rlim64_t = libc::c_ulong;
pub type __id_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __useconds_t = libc::c_uint;
pub type __suseconds_t = libc::c_long;
pub type __daddr_t = libc::c_int;
pub type __key_t = libc::c_int;
pub type __clockid_t = libc::c_int;
pub type __timer_t = *mut libc::c_void;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __blkcnt64_t = libc::c_long;
pub type __fsblkcnt_t = libc::c_ulong;
pub type __fsblkcnt64_t = libc::c_ulong;
pub type __fsfilcnt_t = libc::c_ulong;
pub type __fsfilcnt64_t = libc::c_ulong;
pub type __fsword_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __syscall_ulong_t = libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut libc::c_char;
pub type __intptr_t = libc::c_long;
pub type __socklen_t = libc::c_uint;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = libc::c_ulong;
pub type ushort = libc::c_ushort;
pub type uint = libc::c_uint;
pub type u_int8_t = libc::c_uchar;
pub type u_int16_t = libc::c_ushort;
pub type u_int32_t = libc::c_uint;
pub type u_int64_t = libc::c_ulong;
pub type register_t = libc::c_long;
pub type __sig_atomic_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_3 {
    pub __val: [libc::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_3>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_3>() , 8usize);
}
impl Clone for _bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
pub type __sigset_t = _bindgen_ty_3;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize);
    assert_eq!(::std::mem::align_of::<timeval>() , 8usize);
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize);
    assert_eq!(::std::mem::align_of::<timespec>() , 8usize);
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = libc::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_4 {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_4>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_4>() , 8usize);
}
impl Clone for _bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
pub type fd_set = _bindgen_ty_4;
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: libc::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> libc::c_int;
}
extern "C" {
    pub fn pselect(__nfds: libc::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> libc::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> libc::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> libc::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: libc::c_uint, __minor: libc::c_uint)
     -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_attr_t {
    pub __size: __BindgenUnionField<[libc::c_char; 56usize]>,
    pub __align: __BindgenUnionField<libc::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize);
    assert_eq!(::std::mem::align_of::<pthread_attr_t>() , 8usize);
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize);
    assert_eq!(::std::mem::align_of::<__pthread_internal_list>() , 8usize);
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_5 {
    pub __data: __BindgenUnionField<_bindgen_ty_5___pthread_mutex_s>,
    pub __size: __BindgenUnionField<[libc::c_char; 40usize]>,
    pub __align: __BindgenUnionField<libc::c_long>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_5___pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout__bindgen_ty_5___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_5___pthread_mutex_s>() ,
               40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_5___pthread_mutex_s>() ,
               8usize);
}
impl Clone for _bindgen_ty_5___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_5>() , 40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_5>() , 8usize);
}
impl Clone for _bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_mutex_t = _bindgen_ty_5;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_6 {
    pub __size: __BindgenUnionField<[libc::c_char; 4usize]>,
    pub __align: __BindgenUnionField<libc::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_6>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_6>() , 4usize);
}
impl Clone for _bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_mutexattr_t = _bindgen_ty_6;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_7 {
    pub __data: __BindgenUnionField<_bindgen_ty_7__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[libc::c_char; 48usize]>,
    pub __align: __BindgenUnionField<libc::c_longlong>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_7__bindgen_ty_1 {
    pub __bindgen_anon_1: _bindgen_ty_7__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _bindgen_ty_7__bindgen_ty_1__bindgen_ty_2,
    pub __g_refs: [libc::c_uint; 2usize],
    pub __g_size: [libc::c_uint; 2usize],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_7__bindgen_ty_1__bindgen_ty_1 {
    pub __wseq: __BindgenUnionField<libc::c_ulonglong>,
    pub __wseq32: __BindgenUnionField<_bindgen_ty_7__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_7__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[test]
fn bindgen_test_layout__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_7__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_7__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _bindgen_ty_7__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_7__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_7__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _bindgen_ty_7__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_7__bindgen_ty_1__bindgen_ty_2 {
    pub __g1_start: __BindgenUnionField<libc::c_ulonglong>,
    pub __g1_start32: __BindgenUnionField<_bindgen_ty_7__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_7__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[test]
fn bindgen_test_layout__bindgen_ty_7__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_7__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_7__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _bindgen_ty_7__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_7__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_7__bindgen_ty_1__bindgen_ty_2>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_7__bindgen_ty_1__bindgen_ty_2>()
               , 8usize);
}
impl Clone for _bindgen_ty_7__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_7__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_7__bindgen_ty_1>() ,
               48usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_7__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _bindgen_ty_7__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_7>() , 48usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_7>() , 8usize);
}
impl Clone for _bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_cond_t = _bindgen_ty_7;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_8 {
    pub __size: __BindgenUnionField<[libc::c_char; 4usize]>,
    pub __align: __BindgenUnionField<libc::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_8() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_8>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_8>() , 4usize);
}
impl Clone for _bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_condattr_t = _bindgen_ty_8;
pub type pthread_key_t = libc::c_uint;
pub type pthread_once_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_9 {
    pub __data: __BindgenUnionField<_bindgen_ty_9__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[libc::c_char; 56usize]>,
    pub __align: __BindgenUnionField<libc::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_9__bindgen_ty_1 {
    pub __readers: libc::c_uint,
    pub __writers: libc::c_uint,
    pub __wrphase_futex: libc::c_uint,
    pub __writers_futex: libc::c_uint,
    pub __pad3: libc::c_uint,
    pub __pad4: libc::c_uint,
    pub __cur_writer: libc::c_int,
    pub __shared: libc::c_int,
    pub __rwelision: libc::c_char,
    pub __pad1: [libc::c_uchar; 7usize],
    pub __pad2: libc::c_ulong,
    pub __flags: libc::c_uint,
}
#[test]
fn bindgen_test_layout__bindgen_ty_9__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_9__bindgen_ty_1>() ,
               56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_9__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _bindgen_ty_9__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_9() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_9>() , 56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_9>() , 8usize);
}
impl Clone for _bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_rwlock_t = _bindgen_ty_9;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_10 {
    pub __size: __BindgenUnionField<[libc::c_char; 8usize]>,
    pub __align: __BindgenUnionField<libc::c_long>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_10() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_10>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_10>() , 8usize);
}
impl Clone for _bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_rwlockattr_t = _bindgen_ty_10;
pub type pthread_spinlock_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_11 {
    pub __size: __BindgenUnionField<[libc::c_char; 32usize]>,
    pub __align: __BindgenUnionField<libc::c_long>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_11() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_11>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_11>() , 8usize);
}
impl Clone for _bindgen_ty_11 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_barrier_t = _bindgen_ty_11;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_12 {
    pub __size: __BindgenUnionField<[libc::c_char; 4usize]>,
    pub __align: __BindgenUnionField<libc::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_12() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_12>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_12>() , 4usize);
}
impl Clone for _bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_barrierattr_t = _bindgen_ty_12;
pub type XID = libc::c_ulong;
pub type Mask = libc::c_ulong;
pub type Atom = libc::c_ulong;
pub type VisualID = libc::c_ulong;
pub type Time = libc::c_ulong;
pub type Window = XID;
pub type Drawable = XID;
pub type Font = XID;
pub type Pixmap = XID;
pub type Cursor = XID;
pub type Colormap = XID;
pub type GContext = XID;
pub type KeySym = XID;
pub type KeyCode = libc::c_uchar;
pub type wchar_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_13 {
    pub __clang_max_align_nonce1: libc::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
impl Clone for _bindgen_ty_13 {
    fn clone(&self) -> Self { *self }
}
pub type max_align_t = _bindgen_ty_13;
extern "C" {
    pub fn _Xmblen(str: *mut libc::c_char, len: libc::c_int) -> libc::c_int;
}
pub type XPointer = *mut libc::c_char;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XExtData {
    pub number: libc::c_int,
    pub next: *mut _XExtData,
    pub free_private: ::std::option::Option<unsafe extern "C" fn(extension:
                                                                     *mut _XExtData)
                                                -> libc::c_int>,
    pub private_data: XPointer,
}
#[test]
fn bindgen_test_layout__XExtData() {
    assert_eq!(::std::mem::size_of::<_XExtData>() , 32usize);
    assert_eq!(::std::mem::align_of::<_XExtData>() , 8usize);
}
impl Clone for _XExtData {
    fn clone(&self) -> Self { *self }
}
pub type XExtData = _XExtData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_14 {
    pub extension: libc::c_int,
    pub major_opcode: libc::c_int,
    pub first_event: libc::c_int,
    pub first_error: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_14() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_14>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_14>() , 4usize);
}
impl Clone for _bindgen_ty_14 {
    fn clone(&self) -> Self { *self }
}
pub type XExtCodes = _bindgen_ty_14;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_15 {
    pub depth: libc::c_int,
    pub bits_per_pixel: libc::c_int,
    pub scanline_pad: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_15() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_15>() , 12usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_15>() , 4usize);
}
impl Clone for _bindgen_ty_15 {
    fn clone(&self) -> Self { *self }
}
pub type XPixmapFormatValues = _bindgen_ty_15;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_16 {
    pub function: libc::c_int,
    pub plane_mask: libc::c_ulong,
    pub foreground: libc::c_ulong,
    pub background: libc::c_ulong,
    pub line_width: libc::c_int,
    pub line_style: libc::c_int,
    pub cap_style: libc::c_int,
    pub join_style: libc::c_int,
    pub fill_style: libc::c_int,
    pub fill_rule: libc::c_int,
    pub arc_mode: libc::c_int,
    pub tile: Pixmap,
    pub stipple: Pixmap,
    pub ts_x_origin: libc::c_int,
    pub ts_y_origin: libc::c_int,
    pub font: Font,
    pub subwindow_mode: libc::c_int,
    pub graphics_exposures: libc::c_int,
    pub clip_x_origin: libc::c_int,
    pub clip_y_origin: libc::c_int,
    pub clip_mask: Pixmap,
    pub dash_offset: libc::c_int,
    pub dashes: libc::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_16() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_16>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_16>() , 8usize);
}
impl Clone for _bindgen_ty_16 {
    fn clone(&self) -> Self { *self }
}
pub type XGCValues = _bindgen_ty_16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XGC([u8; 0]);
pub type GC = *mut _XGC;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_17 {
    pub ext_data: *mut XExtData,
    pub visualid: VisualID,
    pub class: libc::c_int,
    pub red_mask: libc::c_ulong,
    pub green_mask: libc::c_ulong,
    pub blue_mask: libc::c_ulong,
    pub bits_per_rgb: libc::c_int,
    pub map_entries: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_17() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_17>() , 56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_17>() , 8usize);
}
impl Clone for _bindgen_ty_17 {
    fn clone(&self) -> Self { *self }
}
pub type Visual = _bindgen_ty_17;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_18 {
    pub depth: libc::c_int,
    pub nvisuals: libc::c_int,
    pub visuals: *mut Visual,
}
#[test]
fn bindgen_test_layout__bindgen_ty_18() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_18>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_18>() , 8usize);
}
impl Clone for _bindgen_ty_18 {
    fn clone(&self) -> Self { *self }
}
pub type Depth = _bindgen_ty_18;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XDisplay([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_19 {
    pub ext_data: *mut XExtData,
    pub display: *mut _XDisplay,
    pub root: Window,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub mwidth: libc::c_int,
    pub mheight: libc::c_int,
    pub ndepths: libc::c_int,
    pub depths: *mut Depth,
    pub root_depth: libc::c_int,
    pub root_visual: *mut Visual,
    pub default_gc: GC,
    pub cmap: Colormap,
    pub white_pixel: libc::c_ulong,
    pub black_pixel: libc::c_ulong,
    pub max_maps: libc::c_int,
    pub min_maps: libc::c_int,
    pub backing_store: libc::c_int,
    pub save_unders: libc::c_int,
    pub root_input_mask: libc::c_long,
}
#[test]
fn bindgen_test_layout__bindgen_ty_19() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_19>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_19>() , 8usize);
}
impl Clone for _bindgen_ty_19 {
    fn clone(&self) -> Self { *self }
}
pub type Screen = _bindgen_ty_19;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_20 {
    pub ext_data: *mut XExtData,
    pub depth: libc::c_int,
    pub bits_per_pixel: libc::c_int,
    pub scanline_pad: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_20() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_20>() , 24usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_20>() , 8usize);
}
impl Clone for _bindgen_ty_20 {
    fn clone(&self) -> Self { *self }
}
pub type ScreenFormat = _bindgen_ty_20;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_21 {
    pub background_pixmap: Pixmap,
    pub background_pixel: libc::c_ulong,
    pub border_pixmap: Pixmap,
    pub border_pixel: libc::c_ulong,
    pub bit_gravity: libc::c_int,
    pub win_gravity: libc::c_int,
    pub backing_store: libc::c_int,
    pub backing_planes: libc::c_ulong,
    pub backing_pixel: libc::c_ulong,
    pub save_under: libc::c_int,
    pub event_mask: libc::c_long,
    pub do_not_propagate_mask: libc::c_long,
    pub override_redirect: libc::c_int,
    pub colormap: Colormap,
    pub cursor: Cursor,
}
#[test]
fn bindgen_test_layout__bindgen_ty_21() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_21>() , 112usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_21>() , 8usize);
}
impl Clone for _bindgen_ty_21 {
    fn clone(&self) -> Self { *self }
}
pub type XSetWindowAttributes = _bindgen_ty_21;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_22 {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub border_width: libc::c_int,
    pub depth: libc::c_int,
    pub visual: *mut Visual,
    pub root: Window,
    pub class: libc::c_int,
    pub bit_gravity: libc::c_int,
    pub win_gravity: libc::c_int,
    pub backing_store: libc::c_int,
    pub backing_planes: libc::c_ulong,
    pub backing_pixel: libc::c_ulong,
    pub save_under: libc::c_int,
    pub colormap: Colormap,
    pub map_installed: libc::c_int,
    pub map_state: libc::c_int,
    pub all_event_masks: libc::c_long,
    pub your_event_mask: libc::c_long,
    pub do_not_propagate_mask: libc::c_long,
    pub override_redirect: libc::c_int,
    pub screen: *mut Screen,
}
#[test]
fn bindgen_test_layout__bindgen_ty_22() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_22>() , 136usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_22>() , 8usize);
}
impl Clone for _bindgen_ty_22 {
    fn clone(&self) -> Self { *self }
}
pub type XWindowAttributes = _bindgen_ty_22;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_23 {
    pub family: libc::c_int,
    pub length: libc::c_int,
    pub address: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_23() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_23>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_23>() , 8usize);
}
impl Clone for _bindgen_ty_23 {
    fn clone(&self) -> Self { *self }
}
pub type XHostAddress = _bindgen_ty_23;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_24 {
    pub typelength: libc::c_int,
    pub valuelength: libc::c_int,
    pub type_: *mut libc::c_char,
    pub value: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_24() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_24>() , 24usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_24>() , 8usize);
}
impl Clone for _bindgen_ty_24 {
    fn clone(&self) -> Self { *self }
}
pub type XServerInterpretedAddress = _bindgen_ty_24;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XImage {
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub xoffset: libc::c_int,
    pub format: libc::c_int,
    pub data: *mut libc::c_char,
    pub byte_order: libc::c_int,
    pub bitmap_unit: libc::c_int,
    pub bitmap_bit_order: libc::c_int,
    pub bitmap_pad: libc::c_int,
    pub depth: libc::c_int,
    pub bytes_per_line: libc::c_int,
    pub bits_per_pixel: libc::c_int,
    pub red_mask: libc::c_ulong,
    pub green_mask: libc::c_ulong,
    pub blue_mask: libc::c_ulong,
    pub obdata: XPointer,
    pub f: _XImage_funcs,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XImage_funcs {
    pub create_image: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut _XDisplay,
                                                                 arg2:
                                                                     *mut Visual,
                                                                 arg3:
                                                                     libc::c_uint,
                                                                 arg4:
                                                                     libc::c_int,
                                                                 arg5:
                                                                     libc::c_int,
                                                                 arg6:
                                                                     *mut libc::c_char,
                                                                 arg7:
                                                                     libc::c_uint,
                                                                 arg8:
                                                                     libc::c_uint,
                                                                 arg9:
                                                                     libc::c_int,
                                                                 arg10:
                                                                     libc::c_int)
                                                -> *mut _XImage>,
    pub destroy_image: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut _XImage)
                                                 -> libc::c_int>,
    pub get_pixel: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut _XImage,
                                                              arg2:
                                                                  libc::c_int,
                                                              arg3:
                                                                  libc::c_int)
                                             -> libc::c_ulong>,
    pub put_pixel: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut _XImage,
                                                              arg2:
                                                                  libc::c_int,
                                                              arg3:
                                                                  libc::c_int,
                                                              arg4:
                                                                  libc::c_ulong)
                                             -> libc::c_int>,
    pub sub_image: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut _XImage,
                                                              arg2:
                                                                  libc::c_int,
                                                              arg3:
                                                                  libc::c_int,
                                                              arg4:
                                                                  libc::c_uint,
                                                              arg5:
                                                                  libc::c_uint)
                                             -> *mut _XImage>,
    pub add_pixel: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut _XImage,
                                                              arg2:
                                                                  libc::c_long)
                                             -> libc::c_int>,
}
#[test]
fn bindgen_test_layout__XImage_funcs() {
    assert_eq!(::std::mem::size_of::<_XImage_funcs>() , 48usize);
    assert_eq!(::std::mem::align_of::<_XImage_funcs>() , 8usize);
}
impl Clone for _XImage_funcs {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__XImage() {
    assert_eq!(::std::mem::size_of::<_XImage>() , 136usize);
    assert_eq!(::std::mem::align_of::<_XImage>() , 8usize);
}
impl Clone for _XImage {
    fn clone(&self) -> Self { *self }
}
pub type XImage = _XImage;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_25 {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub border_width: libc::c_int,
    pub sibling: Window,
    pub stack_mode: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_25() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_25>() , 40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_25>() , 8usize);
}
impl Clone for _bindgen_ty_25 {
    fn clone(&self) -> Self { *self }
}
pub type XWindowChanges = _bindgen_ty_25;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_26 {
    pub pixel: libc::c_ulong,
    pub red: libc::c_ushort,
    pub green: libc::c_ushort,
    pub blue: libc::c_ushort,
    pub flags: libc::c_char,
    pub pad: libc::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_26() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_26>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_26>() , 8usize);
}
impl Clone for _bindgen_ty_26 {
    fn clone(&self) -> Self { *self }
}
pub type XColor = _bindgen_ty_26;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_27 {
    pub x1: libc::c_short,
    pub y1: libc::c_short,
    pub x2: libc::c_short,
    pub y2: libc::c_short,
}
#[test]
fn bindgen_test_layout__bindgen_ty_27() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_27>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_27>() , 2usize);
}
impl Clone for _bindgen_ty_27 {
    fn clone(&self) -> Self { *self }
}
pub type XSegment = _bindgen_ty_27;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_28 {
    pub x: libc::c_short,
    pub y: libc::c_short,
}
#[test]
fn bindgen_test_layout__bindgen_ty_28() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_28>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_28>() , 2usize);
}
impl Clone for _bindgen_ty_28 {
    fn clone(&self) -> Self { *self }
}
pub type XPoint = _bindgen_ty_28;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_29 {
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub width: libc::c_ushort,
    pub height: libc::c_ushort,
}
#[test]
fn bindgen_test_layout__bindgen_ty_29() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_29>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_29>() , 2usize);
}
impl Clone for _bindgen_ty_29 {
    fn clone(&self) -> Self { *self }
}
pub type XRectangle = _bindgen_ty_29;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_30 {
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub width: libc::c_ushort,
    pub height: libc::c_ushort,
    pub angle1: libc::c_short,
    pub angle2: libc::c_short,
}
#[test]
fn bindgen_test_layout__bindgen_ty_30() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_30>() , 12usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_30>() , 2usize);
}
impl Clone for _bindgen_ty_30 {
    fn clone(&self) -> Self { *self }
}
pub type XArc = _bindgen_ty_30;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_31 {
    pub key_click_percent: libc::c_int,
    pub bell_percent: libc::c_int,
    pub bell_pitch: libc::c_int,
    pub bell_duration: libc::c_int,
    pub led: libc::c_int,
    pub led_mode: libc::c_int,
    pub key: libc::c_int,
    pub auto_repeat_mode: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_31() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_31>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_31>() , 4usize);
}
impl Clone for _bindgen_ty_31 {
    fn clone(&self) -> Self { *self }
}
pub type XKeyboardControl = _bindgen_ty_31;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_32 {
    pub key_click_percent: libc::c_int,
    pub bell_percent: libc::c_int,
    pub bell_pitch: libc::c_uint,
    pub bell_duration: libc::c_uint,
    pub led_mask: libc::c_ulong,
    pub global_auto_repeat: libc::c_int,
    pub auto_repeats: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_32() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_32>() , 64usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_32>() , 8usize);
}
impl Clone for _bindgen_ty_32 {
    fn clone(&self) -> Self { *self }
}
pub type XKeyboardState = _bindgen_ty_32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_33 {
    pub time: Time,
    pub x: libc::c_short,
    pub y: libc::c_short,
}
#[test]
fn bindgen_test_layout__bindgen_ty_33() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_33>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_33>() , 8usize);
}
impl Clone for _bindgen_ty_33 {
    fn clone(&self) -> Self { *self }
}
pub type XTimeCoord = _bindgen_ty_33;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_34 {
    pub max_keypermod: libc::c_int,
    pub modifiermap: *mut KeyCode,
}
#[test]
fn bindgen_test_layout__bindgen_ty_34() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_34>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_34>() , 8usize);
}
impl Clone for _bindgen_ty_34 {
    fn clone(&self) -> Self { *self }
}
pub type XModifierKeymap = _bindgen_ty_34;
pub type Display = _XDisplay;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XPrivate([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XrmHashBucketRec([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_35 {
    pub ext_data: *mut XExtData,
    pub private1: *mut _XPrivate,
    pub fd: libc::c_int,
    pub private2: libc::c_int,
    pub proto_major_version: libc::c_int,
    pub proto_minor_version: libc::c_int,
    pub vendor: *mut libc::c_char,
    pub private3: XID,
    pub private4: XID,
    pub private5: XID,
    pub private6: libc::c_int,
    pub resource_alloc: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut _XDisplay)
                                                  -> libc::c_ulong>,
    pub byte_order: libc::c_int,
    pub bitmap_unit: libc::c_int,
    pub bitmap_pad: libc::c_int,
    pub bitmap_bit_order: libc::c_int,
    pub nformats: libc::c_int,
    pub pixmap_format: *mut ScreenFormat,
    pub private8: libc::c_int,
    pub release: libc::c_int,
    pub private9: *mut _XPrivate,
    pub private10: *mut _XPrivate,
    pub qlen: libc::c_int,
    pub last_request_read: libc::c_ulong,
    pub request: libc::c_ulong,
    pub private11: XPointer,
    pub private12: XPointer,
    pub private13: XPointer,
    pub private14: XPointer,
    pub max_request_size: libc::c_uint,
    pub db: *mut _XrmHashBucketRec,
    pub private15: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut _XDisplay)
                                             -> libc::c_int>,
    pub display_name: *mut libc::c_char,
    pub default_screen: libc::c_int,
    pub nscreens: libc::c_int,
    pub screens: *mut Screen,
    pub motion_buffer: libc::c_ulong,
    pub private16: libc::c_ulong,
    pub min_keycode: libc::c_int,
    pub max_keycode: libc::c_int,
    pub private17: XPointer,
    pub private18: XPointer,
    pub private19: libc::c_int,
    pub xdefaults: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_35() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_35>() , 296usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_35>() , 8usize);
}
impl Clone for _bindgen_ty_35 {
    fn clone(&self) -> Self { *self }
}
pub type _XPrivDisplay = *mut _bindgen_ty_35;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_36 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub x_root: libc::c_int,
    pub y_root: libc::c_int,
    pub state: libc::c_uint,
    pub keycode: libc::c_uint,
    pub same_screen: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_36() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_36>() , 96usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_36>() , 8usize);
}
impl Clone for _bindgen_ty_36 {
    fn clone(&self) -> Self { *self }
}
pub type XKeyEvent = _bindgen_ty_36;
pub type XKeyPressedEvent = XKeyEvent;
pub type XKeyReleasedEvent = XKeyEvent;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_37 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub x_root: libc::c_int,
    pub y_root: libc::c_int,
    pub state: libc::c_uint,
    pub button: libc::c_uint,
    pub same_screen: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_37() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_37>() , 96usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_37>() , 8usize);
}
impl Clone for _bindgen_ty_37 {
    fn clone(&self) -> Self { *self }
}
pub type XButtonEvent = _bindgen_ty_37;
pub type XButtonPressedEvent = XButtonEvent;
pub type XButtonReleasedEvent = XButtonEvent;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_38 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub x_root: libc::c_int,
    pub y_root: libc::c_int,
    pub state: libc::c_uint,
    pub is_hint: libc::c_char,
    pub same_screen: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_38() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_38>() , 96usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_38>() , 8usize);
}
impl Clone for _bindgen_ty_38 {
    fn clone(&self) -> Self { *self }
}
pub type XMotionEvent = _bindgen_ty_38;
pub type XPointerMovedEvent = XMotionEvent;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_39 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub x_root: libc::c_int,
    pub y_root: libc::c_int,
    pub mode: libc::c_int,
    pub detail: libc::c_int,
    pub same_screen: libc::c_int,
    pub focus: libc::c_int,
    pub state: libc::c_uint,
}
#[test]
fn bindgen_test_layout__bindgen_ty_39() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_39>() , 104usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_39>() , 8usize);
}
impl Clone for _bindgen_ty_39 {
    fn clone(&self) -> Self { *self }
}
pub type XCrossingEvent = _bindgen_ty_39;
pub type XEnterWindowEvent = XCrossingEvent;
pub type XLeaveWindowEvent = XCrossingEvent;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_40 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub mode: libc::c_int,
    pub detail: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_40() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_40>() , 48usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_40>() , 8usize);
}
impl Clone for _bindgen_ty_40 {
    fn clone(&self) -> Self { *self }
}
pub type XFocusChangeEvent = _bindgen_ty_40;
pub type XFocusInEvent = XFocusChangeEvent;
pub type XFocusOutEvent = XFocusChangeEvent;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_41 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub key_vector: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_41() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_41>() , 72usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_41>() , 8usize);
}
impl Clone for _bindgen_ty_41 {
    fn clone(&self) -> Self { *self }
}
pub type XKeymapEvent = _bindgen_ty_41;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_42 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub count: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_42() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_42>() , 64usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_42>() , 8usize);
}
impl Clone for _bindgen_ty_42 {
    fn clone(&self) -> Self { *self }
}
pub type XExposeEvent = _bindgen_ty_42;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_43 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub drawable: Drawable,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub count: libc::c_int,
    pub major_code: libc::c_int,
    pub minor_code: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_43() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_43>() , 72usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_43>() , 8usize);
}
impl Clone for _bindgen_ty_43 {
    fn clone(&self) -> Self { *self }
}
pub type XGraphicsExposeEvent = _bindgen_ty_43;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_44 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub drawable: Drawable,
    pub major_code: libc::c_int,
    pub minor_code: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_44() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_44>() , 48usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_44>() , 8usize);
}
impl Clone for _bindgen_ty_44 {
    fn clone(&self) -> Self { *self }
}
pub type XNoExposeEvent = _bindgen_ty_44;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_45 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub state: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_45() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_45>() , 48usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_45>() , 8usize);
}
impl Clone for _bindgen_ty_45 {
    fn clone(&self) -> Self { *self }
}
pub type XVisibilityEvent = _bindgen_ty_45;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_46 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub border_width: libc::c_int,
    pub override_redirect: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_46() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_46>() , 72usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_46>() , 8usize);
}
impl Clone for _bindgen_ty_46 {
    fn clone(&self) -> Self { *self }
}
pub type XCreateWindowEvent = _bindgen_ty_46;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_47 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
}
#[test]
fn bindgen_test_layout__bindgen_ty_47() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_47>() , 48usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_47>() , 8usize);
}
impl Clone for _bindgen_ty_47 {
    fn clone(&self) -> Self { *self }
}
pub type XDestroyWindowEvent = _bindgen_ty_47;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_48 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub from_configure: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_48() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_48>() , 56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_48>() , 8usize);
}
impl Clone for _bindgen_ty_48 {
    fn clone(&self) -> Self { *self }
}
pub type XUnmapEvent = _bindgen_ty_48;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_49 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub override_redirect: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_49() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_49>() , 56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_49>() , 8usize);
}
impl Clone for _bindgen_ty_49 {
    fn clone(&self) -> Self { *self }
}
pub type XMapEvent = _bindgen_ty_49;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_50 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
}
#[test]
fn bindgen_test_layout__bindgen_ty_50() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_50>() , 48usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_50>() , 8usize);
}
impl Clone for _bindgen_ty_50 {
    fn clone(&self) -> Self { *self }
}
pub type XMapRequestEvent = _bindgen_ty_50;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_51 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub parent: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub override_redirect: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_51() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_51>() , 72usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_51>() , 8usize);
}
impl Clone for _bindgen_ty_51 {
    fn clone(&self) -> Self { *self }
}
pub type XReparentEvent = _bindgen_ty_51;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_52 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub border_width: libc::c_int,
    pub above: Window,
    pub override_redirect: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_52() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_52>() , 88usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_52>() , 8usize);
}
impl Clone for _bindgen_ty_52 {
    fn clone(&self) -> Self { *self }
}
pub type XConfigureEvent = _bindgen_ty_52;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_53 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_53() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_53>() , 56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_53>() , 8usize);
}
impl Clone for _bindgen_ty_53 {
    fn clone(&self) -> Self { *self }
}
pub type XGravityEvent = _bindgen_ty_53;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_54 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub width: libc::c_int,
    pub height: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_54() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_54>() , 48usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_54>() , 8usize);
}
impl Clone for _bindgen_ty_54 {
    fn clone(&self) -> Self { *self }
}
pub type XResizeRequestEvent = _bindgen_ty_54;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_55 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub border_width: libc::c_int,
    pub above: Window,
    pub detail: libc::c_int,
    pub value_mask: libc::c_ulong,
}
#[test]
fn bindgen_test_layout__bindgen_ty_55() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_55>() , 96usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_55>() , 8usize);
}
impl Clone for _bindgen_ty_55 {
    fn clone(&self) -> Self { *self }
}
pub type XConfigureRequestEvent = _bindgen_ty_55;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_56 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub place: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_56() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_56>() , 56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_56>() , 8usize);
}
impl Clone for _bindgen_ty_56 {
    fn clone(&self) -> Self { *self }
}
pub type XCirculateEvent = _bindgen_ty_56;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_57 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
    pub place: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_57() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_57>() , 56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_57>() , 8usize);
}
impl Clone for _bindgen_ty_57 {
    fn clone(&self) -> Self { *self }
}
pub type XCirculateRequestEvent = _bindgen_ty_57;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_58 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub atom: Atom,
    pub time: Time,
    pub state: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_58() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_58>() , 64usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_58>() , 8usize);
}
impl Clone for _bindgen_ty_58 {
    fn clone(&self) -> Self { *self }
}
pub type XPropertyEvent = _bindgen_ty_58;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_59 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub selection: Atom,
    pub time: Time,
}
#[test]
fn bindgen_test_layout__bindgen_ty_59() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_59>() , 56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_59>() , 8usize);
}
impl Clone for _bindgen_ty_59 {
    fn clone(&self) -> Self { *self }
}
pub type XSelectionClearEvent = _bindgen_ty_59;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_60 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub owner: Window,
    pub requestor: Window,
    pub selection: Atom,
    pub target: Atom,
    pub property: Atom,
    pub time: Time,
}
#[test]
fn bindgen_test_layout__bindgen_ty_60() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_60>() , 80usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_60>() , 8usize);
}
impl Clone for _bindgen_ty_60 {
    fn clone(&self) -> Self { *self }
}
pub type XSelectionRequestEvent = _bindgen_ty_60;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_61 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub requestor: Window,
    pub selection: Atom,
    pub target: Atom,
    pub property: Atom,
    pub time: Time,
}
#[test]
fn bindgen_test_layout__bindgen_ty_61() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_61>() , 72usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_61>() , 8usize);
}
impl Clone for _bindgen_ty_61 {
    fn clone(&self) -> Self { *self }
}
pub type XSelectionEvent = _bindgen_ty_61;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_62 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub colormap: Colormap,
    pub new: libc::c_int,
    pub state: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_62() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_62>() , 56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_62>() , 8usize);
}
impl Clone for _bindgen_ty_62 {
    fn clone(&self) -> Self { *self }
}
pub type XColormapEvent = _bindgen_ty_62;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_63 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub message_type: Atom,
    pub format: libc::c_int,
    pub data: _bindgen_ty_63__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_63__bindgen_ty_1 {
    pub b: __BindgenUnionField<[libc::c_char; 20usize]>,
    pub s: __BindgenUnionField<[libc::c_short; 10usize]>,
    pub l: __BindgenUnionField<[libc::c_long; 5usize]>,
    pub bindgen_union_field: [u64; 5usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_63__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_63__bindgen_ty_1>() ,
               40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_63__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _bindgen_ty_63__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_63() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_63>() , 96usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_63>() , 8usize);
}
impl Clone for _bindgen_ty_63 {
    fn clone(&self) -> Self { *self }
}
pub type XClientMessageEvent = _bindgen_ty_63;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_64 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub request: libc::c_int,
    pub first_keycode: libc::c_int,
    pub count: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_64() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_64>() , 56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_64>() , 8usize);
}
impl Clone for _bindgen_ty_64 {
    fn clone(&self) -> Self { *self }
}
pub type XMappingEvent = _bindgen_ty_64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_65 {
    pub type_: libc::c_int,
    pub display: *mut Display,
    pub resourceid: XID,
    pub serial: libc::c_ulong,
    pub error_code: libc::c_uchar,
    pub request_code: libc::c_uchar,
    pub minor_code: libc::c_uchar,
}
#[test]
fn bindgen_test_layout__bindgen_ty_65() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_65>() , 40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_65>() , 8usize);
}
impl Clone for _bindgen_ty_65 {
    fn clone(&self) -> Self { *self }
}
pub type XErrorEvent = _bindgen_ty_65;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_66 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
}
#[test]
fn bindgen_test_layout__bindgen_ty_66() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_66>() , 40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_66>() , 8usize);
}
impl Clone for _bindgen_ty_66 {
    fn clone(&self) -> Self { *self }
}
pub type XAnyEvent = _bindgen_ty_66;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_67 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub extension: libc::c_int,
    pub evtype: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_67() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_67>() , 40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_67>() , 8usize);
}
impl Clone for _bindgen_ty_67 {
    fn clone(&self) -> Self { *self }
}
pub type XGenericEvent = _bindgen_ty_67;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_68 {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub extension: libc::c_int,
    pub evtype: libc::c_int,
    pub cookie: libc::c_uint,
    pub data: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout__bindgen_ty_68() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_68>() , 56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_68>() , 8usize);
}
impl Clone for _bindgen_ty_68 {
    fn clone(&self) -> Self { *self }
}
pub type XGenericEventCookie = _bindgen_ty_68;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XEvent {
    pub type_: __BindgenUnionField<libc::c_int>,
    pub xany: __BindgenUnionField<XAnyEvent>,
    pub xkey: __BindgenUnionField<XKeyEvent>,
    pub xbutton: __BindgenUnionField<XButtonEvent>,
    pub xmotion: __BindgenUnionField<XMotionEvent>,
    pub xcrossing: __BindgenUnionField<XCrossingEvent>,
    pub xfocus: __BindgenUnionField<XFocusChangeEvent>,
    pub xexpose: __BindgenUnionField<XExposeEvent>,
    pub xgraphicsexpose: __BindgenUnionField<XGraphicsExposeEvent>,
    pub xnoexpose: __BindgenUnionField<XNoExposeEvent>,
    pub xvisibility: __BindgenUnionField<XVisibilityEvent>,
    pub xcreatewindow: __BindgenUnionField<XCreateWindowEvent>,
    pub xdestroywindow: __BindgenUnionField<XDestroyWindowEvent>,
    pub xunmap: __BindgenUnionField<XUnmapEvent>,
    pub xmap: __BindgenUnionField<XMapEvent>,
    pub xmaprequest: __BindgenUnionField<XMapRequestEvent>,
    pub xreparent: __BindgenUnionField<XReparentEvent>,
    pub xconfigure: __BindgenUnionField<XConfigureEvent>,
    pub xgravity: __BindgenUnionField<XGravityEvent>,
    pub xresizerequest: __BindgenUnionField<XResizeRequestEvent>,
    pub xconfigurerequest: __BindgenUnionField<XConfigureRequestEvent>,
    pub xcirculate: __BindgenUnionField<XCirculateEvent>,
    pub xcirculaterequest: __BindgenUnionField<XCirculateRequestEvent>,
    pub xproperty: __BindgenUnionField<XPropertyEvent>,
    pub xselectionclear: __BindgenUnionField<XSelectionClearEvent>,
    pub xselectionrequest: __BindgenUnionField<XSelectionRequestEvent>,
    pub xselection: __BindgenUnionField<XSelectionEvent>,
    pub xcolormap: __BindgenUnionField<XColormapEvent>,
    pub xclient: __BindgenUnionField<XClientMessageEvent>,
    pub xmapping: __BindgenUnionField<XMappingEvent>,
    pub xerror: __BindgenUnionField<XErrorEvent>,
    pub xkeymap: __BindgenUnionField<XKeymapEvent>,
    pub xgeneric: __BindgenUnionField<XGenericEvent>,
    pub xcookie: __BindgenUnionField<XGenericEventCookie>,
    pub pad: __BindgenUnionField<[libc::c_long; 24usize]>,
    pub bindgen_union_field: [u64; 24usize],
}
#[test]
fn bindgen_test_layout__XEvent() {
    assert_eq!(::std::mem::size_of::<_XEvent>() , 192usize);
    assert_eq!(::std::mem::align_of::<_XEvent>() , 8usize);
}
impl Clone for _XEvent {
    fn clone(&self) -> Self { *self }
}
pub type XEvent = _XEvent;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_69 {
    pub lbearing: libc::c_short,
    pub rbearing: libc::c_short,
    pub width: libc::c_short,
    pub ascent: libc::c_short,
    pub descent: libc::c_short,
    pub attributes: libc::c_ushort,
}
#[test]
fn bindgen_test_layout__bindgen_ty_69() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_69>() , 12usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_69>() , 2usize);
}
impl Clone for _bindgen_ty_69 {
    fn clone(&self) -> Self { *self }
}
pub type XCharStruct = _bindgen_ty_69;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_70 {
    pub name: Atom,
    pub card32: libc::c_ulong,
}
#[test]
fn bindgen_test_layout__bindgen_ty_70() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_70>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_70>() , 8usize);
}
impl Clone for _bindgen_ty_70 {
    fn clone(&self) -> Self { *self }
}
pub type XFontProp = _bindgen_ty_70;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_71 {
    pub ext_data: *mut XExtData,
    pub fid: Font,
    pub direction: libc::c_uint,
    pub min_char_or_byte2: libc::c_uint,
    pub max_char_or_byte2: libc::c_uint,
    pub min_byte1: libc::c_uint,
    pub max_byte1: libc::c_uint,
    pub all_chars_exist: libc::c_int,
    pub default_char: libc::c_uint,
    pub n_properties: libc::c_int,
    pub properties: *mut XFontProp,
    pub min_bounds: XCharStruct,
    pub max_bounds: XCharStruct,
    pub per_char: *mut XCharStruct,
    pub ascent: libc::c_int,
    pub descent: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_71() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_71>() , 96usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_71>() , 8usize);
}
impl Clone for _bindgen_ty_71 {
    fn clone(&self) -> Self { *self }
}
pub type XFontStruct = _bindgen_ty_71;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_72 {
    pub chars: *mut libc::c_char,
    pub nchars: libc::c_int,
    pub delta: libc::c_int,
    pub font: Font,
}
#[test]
fn bindgen_test_layout__bindgen_ty_72() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_72>() , 24usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_72>() , 8usize);
}
impl Clone for _bindgen_ty_72 {
    fn clone(&self) -> Self { *self }
}
pub type XTextItem = _bindgen_ty_72;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_73 {
    pub byte1: libc::c_uchar,
    pub byte2: libc::c_uchar,
}
#[test]
fn bindgen_test_layout__bindgen_ty_73() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_73>() , 2usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_73>() , 1usize);
}
impl Clone for _bindgen_ty_73 {
    fn clone(&self) -> Self { *self }
}
pub type XChar2b = _bindgen_ty_73;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_74 {
    pub chars: *mut XChar2b,
    pub nchars: libc::c_int,
    pub delta: libc::c_int,
    pub font: Font,
}
#[test]
fn bindgen_test_layout__bindgen_ty_74() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_74>() , 24usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_74>() , 8usize);
}
impl Clone for _bindgen_ty_74 {
    fn clone(&self) -> Self { *self }
}
pub type XTextItem16 = _bindgen_ty_74;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_75 {
    pub display: __BindgenUnionField<*mut Display>,
    pub gc: __BindgenUnionField<GC>,
    pub visual: __BindgenUnionField<*mut Visual>,
    pub screen: __BindgenUnionField<*mut Screen>,
    pub pixmap_format: __BindgenUnionField<*mut ScreenFormat>,
    pub font: __BindgenUnionField<*mut XFontStruct>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_75() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_75>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_75>() , 8usize);
}
impl Clone for _bindgen_ty_75 {
    fn clone(&self) -> Self { *self }
}
pub type XEDataObject = _bindgen_ty_75;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_76 {
    pub max_ink_extent: XRectangle,
    pub max_logical_extent: XRectangle,
}
#[test]
fn bindgen_test_layout__bindgen_ty_76() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_76>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_76>() , 2usize);
}
impl Clone for _bindgen_ty_76 {
    fn clone(&self) -> Self { *self }
}
pub type XFontSetExtents = _bindgen_ty_76;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XOM([u8; 0]);
pub type XOM = *mut _XOM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XOC([u8; 0]);
pub type XOC = *mut _XOC;
pub type XFontSet = *mut _XOC;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_77 {
    pub chars: *mut libc::c_char,
    pub nchars: libc::c_int,
    pub delta: libc::c_int,
    pub font_set: XFontSet,
}
#[test]
fn bindgen_test_layout__bindgen_ty_77() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_77>() , 24usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_77>() , 8usize);
}
impl Clone for _bindgen_ty_77 {
    fn clone(&self) -> Self { *self }
}
pub type XmbTextItem = _bindgen_ty_77;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_78 {
    pub chars: *mut wchar_t,
    pub nchars: libc::c_int,
    pub delta: libc::c_int,
    pub font_set: XFontSet,
}
#[test]
fn bindgen_test_layout__bindgen_ty_78() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_78>() , 24usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_78>() , 8usize);
}
impl Clone for _bindgen_ty_78 {
    fn clone(&self) -> Self { *self }
}
pub type XwcTextItem = _bindgen_ty_78;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_79 {
    pub charset_count: libc::c_int,
    pub charset_list: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_79() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_79>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_79>() , 8usize);
}
impl Clone for _bindgen_ty_79 {
    fn clone(&self) -> Self { *self }
}
pub type XOMCharSetList = _bindgen_ty_79;
pub const XOMOrientation_LTR_TTB: _bindgen_ty_80 =
    _bindgen_ty_80::XOMOrientation_LTR_TTB;
pub const XOMOrientation_RTL_TTB: _bindgen_ty_80 =
    _bindgen_ty_80::XOMOrientation_RTL_TTB;
pub const XOMOrientation_TTB_LTR: _bindgen_ty_80 =
    _bindgen_ty_80::XOMOrientation_TTB_LTR;
pub const XOMOrientation_TTB_RTL: _bindgen_ty_80 =
    _bindgen_ty_80::XOMOrientation_TTB_RTL;
pub const XOMOrientation_Context: _bindgen_ty_80 =
    _bindgen_ty_80::XOMOrientation_Context;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_80 {
    XOMOrientation_LTR_TTB = 0,
    XOMOrientation_RTL_TTB = 1,
    XOMOrientation_TTB_LTR = 2,
    XOMOrientation_TTB_RTL = 3,
    XOMOrientation_Context = 4,
}
pub use self::_bindgen_ty_80 as XOrientation;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_81 {
    pub num_orientation: libc::c_int,
    pub orientation: *mut XOrientation,
}
#[test]
fn bindgen_test_layout__bindgen_ty_81() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_81>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_81>() , 8usize);
}
impl Clone for _bindgen_ty_81 {
    fn clone(&self) -> Self { *self }
}
pub type XOMOrientation = _bindgen_ty_81;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_82 {
    pub num_font: libc::c_int,
    pub font_struct_list: *mut *mut XFontStruct,
    pub font_name_list: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_82() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_82>() , 24usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_82>() , 8usize);
}
impl Clone for _bindgen_ty_82 {
    fn clone(&self) -> Self { *self }
}
pub type XOMFontInfo = _bindgen_ty_82;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XIM([u8; 0]);
pub type XIM = *mut _XIM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XIC([u8; 0]);
pub type XIC = *mut _XIC;
pub type XIMProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: XIM, arg2: XPointer,
                                               arg3: XPointer)>;
pub type XICProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: XIC, arg2: XPointer,
                                               arg3: XPointer)
                              -> libc::c_int>;
pub type XIDProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Display,
                                               arg2: XPointer,
                                               arg3: XPointer)>;
pub type XIMStyle = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_83 {
    pub count_styles: libc::c_ushort,
    pub supported_styles: *mut XIMStyle,
}
#[test]
fn bindgen_test_layout__bindgen_ty_83() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_83>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_83>() , 8usize);
}
impl Clone for _bindgen_ty_83 {
    fn clone(&self) -> Self { *self }
}
pub type XIMStyles = _bindgen_ty_83;
pub type XVaNestedList = *mut libc::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_84 {
    pub client_data: XPointer,
    pub callback: XIMProc,
}
#[test]
fn bindgen_test_layout__bindgen_ty_84() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_84>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_84>() , 8usize);
}
impl Clone for _bindgen_ty_84 {
    fn clone(&self) -> Self { *self }
}
pub type XIMCallback = _bindgen_ty_84;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_85 {
    pub client_data: XPointer,
    pub callback: XICProc,
}
#[test]
fn bindgen_test_layout__bindgen_ty_85() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_85>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_85>() , 8usize);
}
impl Clone for _bindgen_ty_85 {
    fn clone(&self) -> Self { *self }
}
pub type XICCallback = _bindgen_ty_85;
pub type XIMFeedback = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XIMText {
    pub length: libc::c_ushort,
    pub feedback: *mut XIMFeedback,
    pub encoding_is_wchar: libc::c_int,
    pub string: _XIMText__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XIMText__bindgen_ty_1 {
    pub multi_byte: __BindgenUnionField<*mut libc::c_char>,
    pub wide_char: __BindgenUnionField<*mut wchar_t>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__XIMText__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_XIMText__bindgen_ty_1>() , 8usize);
    assert_eq!(::std::mem::align_of::<_XIMText__bindgen_ty_1>() , 8usize);
}
impl Clone for _XIMText__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__XIMText() {
    assert_eq!(::std::mem::size_of::<_XIMText>() , 32usize);
    assert_eq!(::std::mem::align_of::<_XIMText>() , 8usize);
}
impl Clone for _XIMText {
    fn clone(&self) -> Self { *self }
}
pub type XIMText = _XIMText;
pub type XIMPreeditState = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XIMPreeditStateNotifyCallbackStruct {
    pub state: XIMPreeditState,
}
#[test]
fn bindgen_test_layout__XIMPreeditStateNotifyCallbackStruct() {
    assert_eq!(::std::mem::size_of::<_XIMPreeditStateNotifyCallbackStruct>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<_XIMPreeditStateNotifyCallbackStruct>()
               , 8usize);
}
impl Clone for _XIMPreeditStateNotifyCallbackStruct {
    fn clone(&self) -> Self { *self }
}
pub type XIMPreeditStateNotifyCallbackStruct =
    _XIMPreeditStateNotifyCallbackStruct;
pub type XIMResetState = libc::c_ulong;
pub type XIMStringConversionFeedback = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XIMStringConversionText {
    pub length: libc::c_ushort,
    pub feedback: *mut XIMStringConversionFeedback,
    pub encoding_is_wchar: libc::c_int,
    pub string: _XIMStringConversionText__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XIMStringConversionText__bindgen_ty_1 {
    pub mbs: __BindgenUnionField<*mut libc::c_char>,
    pub wcs: __BindgenUnionField<*mut wchar_t>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__XIMStringConversionText__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_XIMStringConversionText__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<_XIMStringConversionText__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _XIMStringConversionText__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__XIMStringConversionText() {
    assert_eq!(::std::mem::size_of::<_XIMStringConversionText>() , 32usize);
    assert_eq!(::std::mem::align_of::<_XIMStringConversionText>() , 8usize);
}
impl Clone for _XIMStringConversionText {
    fn clone(&self) -> Self { *self }
}
pub type XIMStringConversionText = _XIMStringConversionText;
pub type XIMStringConversionPosition = libc::c_ushort;
pub type XIMStringConversionType = libc::c_ushort;
pub type XIMStringConversionOperation = libc::c_ushort;
pub const XIMForwardChar: _bindgen_ty_86 = _bindgen_ty_86::XIMForwardChar;
pub const XIMBackwardChar: _bindgen_ty_86 = _bindgen_ty_86::XIMBackwardChar;
pub const XIMForwardWord: _bindgen_ty_86 = _bindgen_ty_86::XIMForwardWord;
pub const XIMBackwardWord: _bindgen_ty_86 = _bindgen_ty_86::XIMBackwardWord;
pub const XIMCaretUp: _bindgen_ty_86 = _bindgen_ty_86::XIMCaretUp;
pub const XIMCaretDown: _bindgen_ty_86 = _bindgen_ty_86::XIMCaretDown;
pub const XIMNextLine: _bindgen_ty_86 = _bindgen_ty_86::XIMNextLine;
pub const XIMPreviousLine: _bindgen_ty_86 = _bindgen_ty_86::XIMPreviousLine;
pub const XIMLineStart: _bindgen_ty_86 = _bindgen_ty_86::XIMLineStart;
pub const XIMLineEnd: _bindgen_ty_86 = _bindgen_ty_86::XIMLineEnd;
pub const XIMAbsolutePosition: _bindgen_ty_86 =
    _bindgen_ty_86::XIMAbsolutePosition;
pub const XIMDontChange: _bindgen_ty_86 = _bindgen_ty_86::XIMDontChange;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_86 {
    XIMForwardChar = 0,
    XIMBackwardChar = 1,
    XIMForwardWord = 2,
    XIMBackwardWord = 3,
    XIMCaretUp = 4,
    XIMCaretDown = 5,
    XIMNextLine = 6,
    XIMPreviousLine = 7,
    XIMLineStart = 8,
    XIMLineEnd = 9,
    XIMAbsolutePosition = 10,
    XIMDontChange = 11,
}
pub use self::_bindgen_ty_86 as XIMCaretDirection;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XIMStringConversionCallbackStruct {
    pub position: XIMStringConversionPosition,
    pub direction: XIMCaretDirection,
    pub operation: XIMStringConversionOperation,
    pub factor: libc::c_ushort,
    pub text: *mut XIMStringConversionText,
}
#[test]
fn bindgen_test_layout__XIMStringConversionCallbackStruct() {
    assert_eq!(::std::mem::size_of::<_XIMStringConversionCallbackStruct>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<_XIMStringConversionCallbackStruct>() ,
               8usize);
}
impl Clone for _XIMStringConversionCallbackStruct {
    fn clone(&self) -> Self { *self }
}
pub type XIMStringConversionCallbackStruct =
    _XIMStringConversionCallbackStruct;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XIMPreeditDrawCallbackStruct {
    pub caret: libc::c_int,
    pub chg_first: libc::c_int,
    pub chg_length: libc::c_int,
    pub text: *mut XIMText,
}
#[test]
fn bindgen_test_layout__XIMPreeditDrawCallbackStruct() {
    assert_eq!(::std::mem::size_of::<_XIMPreeditDrawCallbackStruct>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<_XIMPreeditDrawCallbackStruct>() ,
               8usize);
}
impl Clone for _XIMPreeditDrawCallbackStruct {
    fn clone(&self) -> Self { *self }
}
pub type XIMPreeditDrawCallbackStruct = _XIMPreeditDrawCallbackStruct;
pub const XIMIsInvisible: _bindgen_ty_87 = _bindgen_ty_87::XIMIsInvisible;
pub const XIMIsPrimary: _bindgen_ty_87 = _bindgen_ty_87::XIMIsPrimary;
pub const XIMIsSecondary: _bindgen_ty_87 = _bindgen_ty_87::XIMIsSecondary;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_87 {
    XIMIsInvisible = 0,
    XIMIsPrimary = 1,
    XIMIsSecondary = 2,
}
pub use self::_bindgen_ty_87 as XIMCaretStyle;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XIMPreeditCaretCallbackStruct {
    pub position: libc::c_int,
    pub direction: XIMCaretDirection,
    pub style: XIMCaretStyle,
}
#[test]
fn bindgen_test_layout__XIMPreeditCaretCallbackStruct() {
    assert_eq!(::std::mem::size_of::<_XIMPreeditCaretCallbackStruct>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<_XIMPreeditCaretCallbackStruct>() ,
               4usize);
}
impl Clone for _XIMPreeditCaretCallbackStruct {
    fn clone(&self) -> Self { *self }
}
pub type XIMPreeditCaretCallbackStruct = _XIMPreeditCaretCallbackStruct;
pub const XIMTextType: _bindgen_ty_88 = _bindgen_ty_88::XIMTextType;
pub const XIMBitmapType: _bindgen_ty_88 = _bindgen_ty_88::XIMBitmapType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_88 { XIMTextType = 0, XIMBitmapType = 1, }
pub use self::_bindgen_ty_88 as XIMStatusDataType;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XIMStatusDrawCallbackStruct {
    pub type_: XIMStatusDataType,
    pub data: _XIMStatusDrawCallbackStruct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XIMStatusDrawCallbackStruct__bindgen_ty_1 {
    pub text: __BindgenUnionField<*mut XIMText>,
    pub bitmap: __BindgenUnionField<Pixmap>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__XIMStatusDrawCallbackStruct__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_XIMStatusDrawCallbackStruct__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<_XIMStatusDrawCallbackStruct__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _XIMStatusDrawCallbackStruct__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__XIMStatusDrawCallbackStruct() {
    assert_eq!(::std::mem::size_of::<_XIMStatusDrawCallbackStruct>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<_XIMStatusDrawCallbackStruct>() ,
               8usize);
}
impl Clone for _XIMStatusDrawCallbackStruct {
    fn clone(&self) -> Self { *self }
}
pub type XIMStatusDrawCallbackStruct = _XIMStatusDrawCallbackStruct;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XIMHotKeyTrigger {
    pub keysym: KeySym,
    pub modifier: libc::c_int,
    pub modifier_mask: libc::c_int,
}
#[test]
fn bindgen_test_layout__XIMHotKeyTrigger() {
    assert_eq!(::std::mem::size_of::<_XIMHotKeyTrigger>() , 16usize);
    assert_eq!(::std::mem::align_of::<_XIMHotKeyTrigger>() , 8usize);
}
impl Clone for _XIMHotKeyTrigger {
    fn clone(&self) -> Self { *self }
}
pub type XIMHotKeyTrigger = _XIMHotKeyTrigger;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _XIMHotKeyTriggers {
    pub num_hot_key: libc::c_int,
    pub key: *mut XIMHotKeyTrigger,
}
#[test]
fn bindgen_test_layout__XIMHotKeyTriggers() {
    assert_eq!(::std::mem::size_of::<_XIMHotKeyTriggers>() , 16usize);
    assert_eq!(::std::mem::align_of::<_XIMHotKeyTriggers>() , 8usize);
}
impl Clone for _XIMHotKeyTriggers {
    fn clone(&self) -> Self { *self }
}
pub type XIMHotKeyTriggers = _XIMHotKeyTriggers;
pub type XIMHotKeyState = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_89 {
    pub count_values: libc::c_ushort,
    pub supported_values: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_89() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_89>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_89>() , 8usize);
}
impl Clone for _bindgen_ty_89 {
    fn clone(&self) -> Self { *self }
}
pub type XIMValuesList = _bindgen_ty_89;
extern "C" {
    #[link_name = "_Xdebug"]
    pub static mut _Xdebug: libc::c_int;
}
extern "C" {
    pub fn XLoadQueryFont(arg1: *mut Display, arg2: *const libc::c_char)
     -> *mut XFontStruct;
}
extern "C" {
    pub fn XQueryFont(arg1: *mut Display, arg2: XID) -> *mut XFontStruct;
}
extern "C" {
    pub fn XGetMotionEvents(arg1: *mut Display, arg2: Window, arg3: Time,
                            arg4: Time, arg5: *mut libc::c_int)
     -> *mut XTimeCoord;
}
extern "C" {
    pub fn XDeleteModifiermapEntry(arg1: *mut XModifierKeymap, arg2: KeyCode,
                                   arg3: libc::c_int) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XGetModifierMapping(arg1: *mut Display) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XInsertModifiermapEntry(arg1: *mut XModifierKeymap, arg2: KeyCode,
                                   arg3: libc::c_int) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XNewModifiermap(arg1: libc::c_int) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XCreateImage(arg1: *mut Display, arg2: *mut Visual,
                        arg3: libc::c_uint, arg4: libc::c_int,
                        arg5: libc::c_int, arg6: *mut libc::c_char,
                        arg7: libc::c_uint, arg8: libc::c_uint,
                        arg9: libc::c_int, arg10: libc::c_int) -> *mut XImage;
}
extern "C" {
    pub fn XInitImage(arg1: *mut XImage) -> libc::c_int;
}
extern "C" {
    pub fn XGetImage(arg1: *mut Display, arg2: Drawable, arg3: libc::c_int,
                     arg4: libc::c_int, arg5: libc::c_uint,
                     arg6: libc::c_uint, arg7: libc::c_ulong,
                     arg8: libc::c_int) -> *mut XImage;
}
extern "C" {
    pub fn XGetSubImage(arg1: *mut Display, arg2: Drawable, arg3: libc::c_int,
                        arg4: libc::c_int, arg5: libc::c_uint,
                        arg6: libc::c_uint, arg7: libc::c_ulong,
                        arg8: libc::c_int, arg9: *mut XImage,
                        arg10: libc::c_int, arg11: libc::c_int)
     -> *mut XImage;
}
extern "C" {
    pub fn XOpenDisplay(arg1: *const libc::c_char) -> *mut Display;
}
extern "C" {
    pub fn XrmInitialize();
}
extern "C" {
    pub fn XFetchBytes(arg1: *mut Display, arg2: *mut libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn XFetchBuffer(arg1: *mut Display, arg2: *mut libc::c_int,
                        arg3: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn XGetAtomName(arg1: *mut Display, arg2: Atom) -> *mut libc::c_char;
}
extern "C" {
    pub fn XGetAtomNames(arg1: *mut Display, arg2: *mut Atom,
                         arg3: libc::c_int, arg4: *mut *mut libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn XGetDefault(arg1: *mut Display, arg2: *const libc::c_char,
                       arg3: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDisplayName(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn XKeysymToString(arg1: KeySym) -> *mut libc::c_char;
}
extern "C" {
    pub fn XSynchronize(arg1: *mut Display, arg2: libc::c_int)
     -> ::std::option::Option<unsafe extern "C" fn() -> libc::c_int>;
}
extern "C" {
    pub fn XSetAfterFunction(arg1: *mut Display,
                             arg2:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                *mut Display)
                                                           -> libc::c_int>)
     -> ::std::option::Option<unsafe extern "C" fn() -> libc::c_int>;
}
extern "C" {
    pub fn XInternAtom(arg1: *mut Display, arg2: *const libc::c_char,
                       arg3: libc::c_int) -> Atom;
}
extern "C" {
    pub fn XInternAtoms(arg1: *mut Display, arg2: *mut *mut libc::c_char,
                        arg3: libc::c_int, arg4: libc::c_int, arg5: *mut Atom)
     -> libc::c_int;
}
extern "C" {
    pub fn XCopyColormapAndFree(arg1: *mut Display, arg2: Colormap)
     -> Colormap;
}
extern "C" {
    pub fn XCreateColormap(arg1: *mut Display, arg2: Window,
                           arg3: *mut Visual, arg4: libc::c_int) -> Colormap;
}
extern "C" {
    pub fn XCreatePixmapCursor(arg1: *mut Display, arg2: Pixmap, arg3: Pixmap,
                               arg4: *mut XColor, arg5: *mut XColor,
                               arg6: libc::c_uint, arg7: libc::c_uint)
     -> Cursor;
}
extern "C" {
    pub fn XCreateGlyphCursor(arg1: *mut Display, arg2: Font, arg3: Font,
                              arg4: libc::c_uint, arg5: libc::c_uint,
                              arg6: *const XColor, arg7: *const XColor)
     -> Cursor;
}
extern "C" {
    pub fn XCreateFontCursor(arg1: *mut Display, arg2: libc::c_uint)
     -> Cursor;
}
extern "C" {
    pub fn XLoadFont(arg1: *mut Display, arg2: *const libc::c_char) -> Font;
}
extern "C" {
    pub fn XCreateGC(arg1: *mut Display, arg2: Drawable, arg3: libc::c_ulong,
                     arg4: *mut XGCValues) -> GC;
}
extern "C" {
    pub fn XGContextFromGC(arg1: GC) -> GContext;
}
extern "C" {
    pub fn XFlushGC(arg1: *mut Display, arg2: GC);
}
extern "C" {
    pub fn XCreatePixmap(arg1: *mut Display, arg2: Drawable,
                         arg3: libc::c_uint, arg4: libc::c_uint,
                         arg5: libc::c_uint) -> Pixmap;
}
extern "C" {
    pub fn XCreateBitmapFromData(arg1: *mut Display, arg2: Drawable,
                                 arg3: *const libc::c_char,
                                 arg4: libc::c_uint, arg5: libc::c_uint)
     -> Pixmap;
}
extern "C" {
    pub fn XCreatePixmapFromBitmapData(arg1: *mut Display, arg2: Drawable,
                                       arg3: *mut libc::c_char,
                                       arg4: libc::c_uint, arg5: libc::c_uint,
                                       arg6: libc::c_ulong,
                                       arg7: libc::c_ulong,
                                       arg8: libc::c_uint) -> Pixmap;
}
extern "C" {
    pub fn XCreateSimpleWindow(arg1: *mut Display, arg2: Window,
                               arg3: libc::c_int, arg4: libc::c_int,
                               arg5: libc::c_uint, arg6: libc::c_uint,
                               arg7: libc::c_uint, arg8: libc::c_ulong,
                               arg9: libc::c_ulong) -> Window;
}
extern "C" {
    pub fn XGetSelectionOwner(arg1: *mut Display, arg2: Atom) -> Window;
}
extern "C" {
    pub fn XCreateWindow(arg1: *mut Display, arg2: Window, arg3: libc::c_int,
                         arg4: libc::c_int, arg5: libc::c_uint,
                         arg6: libc::c_uint, arg7: libc::c_uint,
                         arg8: libc::c_int, arg9: libc::c_uint,
                         arg10: *mut Visual, arg11: libc::c_ulong,
                         arg12: *mut XSetWindowAttributes) -> Window;
}
extern "C" {
    pub fn XListInstalledColormaps(arg1: *mut Display, arg2: Window,
                                   arg3: *mut libc::c_int) -> *mut Colormap;
}
extern "C" {
    pub fn XListFonts(arg1: *mut Display, arg2: *const libc::c_char,
                      arg3: libc::c_int, arg4: *mut libc::c_int)
     -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn XListFontsWithInfo(arg1: *mut Display, arg2: *const libc::c_char,
                              arg3: libc::c_int, arg4: *mut libc::c_int,
                              arg5: *mut *mut XFontStruct)
     -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn XGetFontPath(arg1: *mut Display, arg2: *mut libc::c_int)
     -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn XListExtensions(arg1: *mut Display, arg2: *mut libc::c_int)
     -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn XListProperties(arg1: *mut Display, arg2: Window,
                           arg3: *mut libc::c_int) -> *mut Atom;
}
extern "C" {
    pub fn XListHosts(arg1: *mut Display, arg2: *mut libc::c_int,
                      arg3: *mut libc::c_int) -> *mut XHostAddress;
}
extern "C" {
    pub fn XKeycodeToKeysym(arg1: *mut Display, arg2: KeyCode,
                            arg3: libc::c_int) -> KeySym;
}
extern "C" {
    pub fn XLookupKeysym(arg1: *mut XKeyEvent, arg2: libc::c_int) -> KeySym;
}
extern "C" {
    pub fn XGetKeyboardMapping(arg1: *mut Display, arg2: KeyCode,
                               arg3: libc::c_int, arg4: *mut libc::c_int)
     -> *mut KeySym;
}
extern "C" {
    pub fn XStringToKeysym(arg1: *const libc::c_char) -> KeySym;
}
extern "C" {
    pub fn XMaxRequestSize(arg1: *mut Display) -> libc::c_long;
}
extern "C" {
    pub fn XExtendedMaxRequestSize(arg1: *mut Display) -> libc::c_long;
}
extern "C" {
    pub fn XResourceManagerString(arg1: *mut Display) -> *mut libc::c_char;
}
extern "C" {
    pub fn XScreenResourceString(arg1: *mut Screen) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDisplayMotionBufferSize(arg1: *mut Display) -> libc::c_ulong;
}
extern "C" {
    pub fn XVisualIDFromVisual(arg1: *mut Visual) -> VisualID;
}
extern "C" {
    pub fn XInitThreads() -> libc::c_int;
}
extern "C" {
    pub fn XLockDisplay(arg1: *mut Display);
}
extern "C" {
    pub fn XUnlockDisplay(arg1: *mut Display);
}
extern "C" {
    pub fn XInitExtension(arg1: *mut Display, arg2: *const libc::c_char)
     -> *mut XExtCodes;
}
extern "C" {
    pub fn XAddExtension(arg1: *mut Display) -> *mut XExtCodes;
}
extern "C" {
    pub fn XFindOnExtensionList(arg1: *mut *mut XExtData, arg2: libc::c_int)
     -> *mut XExtData;
}
extern "C" {
    pub fn XEHeadOfExtensionList(arg1: XEDataObject) -> *mut *mut XExtData;
}
extern "C" {
    pub fn XRootWindow(arg1: *mut Display, arg2: libc::c_int) -> Window;
}
extern "C" {
    pub fn XDefaultRootWindow(arg1: *mut Display) -> Window;
}
extern "C" {
    pub fn XRootWindowOfScreen(arg1: *mut Screen) -> Window;
}
extern "C" {
    pub fn XDefaultVisual(arg1: *mut Display, arg2: libc::c_int)
     -> *mut Visual;
}
extern "C" {
    pub fn XDefaultVisualOfScreen(arg1: *mut Screen) -> *mut Visual;
}
extern "C" {
    pub fn XDefaultGC(arg1: *mut Display, arg2: libc::c_int) -> GC;
}
extern "C" {
    pub fn XDefaultGCOfScreen(arg1: *mut Screen) -> GC;
}
extern "C" {
    pub fn XBlackPixel(arg1: *mut Display, arg2: libc::c_int)
     -> libc::c_ulong;
}
extern "C" {
    pub fn XWhitePixel(arg1: *mut Display, arg2: libc::c_int)
     -> libc::c_ulong;
}
extern "C" {
    pub fn XAllPlanes() -> libc::c_ulong;
}
extern "C" {
    pub fn XBlackPixelOfScreen(arg1: *mut Screen) -> libc::c_ulong;
}
extern "C" {
    pub fn XWhitePixelOfScreen(arg1: *mut Screen) -> libc::c_ulong;
}
extern "C" {
    pub fn XNextRequest(arg1: *mut Display) -> libc::c_ulong;
}
extern "C" {
    pub fn XLastKnownRequestProcessed(arg1: *mut Display) -> libc::c_ulong;
}
extern "C" {
    pub fn XServerVendor(arg1: *mut Display) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDisplayString(arg1: *mut Display) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDefaultColormap(arg1: *mut Display, arg2: libc::c_int)
     -> Colormap;
}
extern "C" {
    pub fn XDefaultColormapOfScreen(arg1: *mut Screen) -> Colormap;
}
extern "C" {
    pub fn XDisplayOfScreen(arg1: *mut Screen) -> *mut Display;
}
extern "C" {
    pub fn XScreenOfDisplay(arg1: *mut Display, arg2: libc::c_int)
     -> *mut Screen;
}
extern "C" {
    pub fn XDefaultScreenOfDisplay(arg1: *mut Display) -> *mut Screen;
}
extern "C" {
    pub fn XEventMaskOfScreen(arg1: *mut Screen) -> libc::c_long;
}
extern "C" {
    pub fn XScreenNumberOfScreen(arg1: *mut Screen) -> libc::c_int;
}
pub type XErrorHandler =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Display,
                                               arg2: *mut XErrorEvent)
                              -> libc::c_int>;
extern "C" {
    pub fn XSetErrorHandler(arg1: XErrorHandler) -> XErrorHandler;
}
pub type XIOErrorHandler =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Display)
                              -> libc::c_int>;
extern "C" {
    pub fn XSetIOErrorHandler(arg1: XIOErrorHandler) -> XIOErrorHandler;
}
extern "C" {
    pub fn XListPixmapFormats(arg1: *mut Display, arg2: *mut libc::c_int)
     -> *mut XPixmapFormatValues;
}
extern "C" {
    pub fn XListDepths(arg1: *mut Display, arg2: libc::c_int,
                       arg3: *mut libc::c_int) -> *mut libc::c_int;
}
extern "C" {
    pub fn XReconfigureWMWindow(arg1: *mut Display, arg2: Window,
                                arg3: libc::c_int, arg4: libc::c_uint,
                                arg5: *mut XWindowChanges) -> libc::c_int;
}
extern "C" {
    pub fn XGetWMProtocols(arg1: *mut Display, arg2: Window,
                           arg3: *mut *mut Atom, arg4: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetWMProtocols(arg1: *mut Display, arg2: Window, arg3: *mut Atom,
                           arg4: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XIconifyWindow(arg1: *mut Display, arg2: Window, arg3: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XWithdrawWindow(arg1: *mut Display, arg2: Window,
                           arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XGetCommand(arg1: *mut Display, arg2: Window,
                       arg3: *mut *mut *mut libc::c_char,
                       arg4: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XGetWMColormapWindows(arg1: *mut Display, arg2: Window,
                                 arg3: *mut *mut Window,
                                 arg4: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetWMColormapWindows(arg1: *mut Display, arg2: Window,
                                 arg3: *mut Window, arg4: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XFreeStringList(arg1: *mut *mut libc::c_char);
}
extern "C" {
    pub fn XSetTransientForHint(arg1: *mut Display, arg2: Window,
                                arg3: Window) -> libc::c_int;
}
extern "C" {
    pub fn XActivateScreenSaver(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XAddHost(arg1: *mut Display, arg2: *mut XHostAddress)
     -> libc::c_int;
}
extern "C" {
    pub fn XAddHosts(arg1: *mut Display, arg2: *mut XHostAddress,
                     arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XAddToExtensionList(arg1: *mut *mut _XExtData, arg2: *mut XExtData)
     -> libc::c_int;
}
extern "C" {
    pub fn XAddToSaveSet(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XAllocColor(arg1: *mut Display, arg2: Colormap, arg3: *mut XColor)
     -> libc::c_int;
}
extern "C" {
    pub fn XAllocColorCells(arg1: *mut Display, arg2: Colormap,
                            arg3: libc::c_int, arg4: *mut libc::c_ulong,
                            arg5: libc::c_uint, arg6: *mut libc::c_ulong,
                            arg7: libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn XAllocColorPlanes(arg1: *mut Display, arg2: Colormap,
                             arg3: libc::c_int, arg4: *mut libc::c_ulong,
                             arg5: libc::c_int, arg6: libc::c_int,
                             arg7: libc::c_int, arg8: libc::c_int,
                             arg9: *mut libc::c_ulong,
                             arg10: *mut libc::c_ulong,
                             arg11: *mut libc::c_ulong) -> libc::c_int;
}
extern "C" {
    pub fn XAllocNamedColor(arg1: *mut Display, arg2: Colormap,
                            arg3: *const libc::c_char, arg4: *mut XColor,
                            arg5: *mut XColor) -> libc::c_int;
}
extern "C" {
    pub fn XAllowEvents(arg1: *mut Display, arg2: libc::c_int, arg3: Time)
     -> libc::c_int;
}
extern "C" {
    pub fn XAutoRepeatOff(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XAutoRepeatOn(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XBell(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XBitmapBitOrder(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XBitmapPad(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XBitmapUnit(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XCellsOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XChangeActivePointerGrab(arg1: *mut Display, arg2: libc::c_uint,
                                    arg3: Cursor, arg4: Time) -> libc::c_int;
}
extern "C" {
    pub fn XChangeGC(arg1: *mut Display, arg2: GC, arg3: libc::c_ulong,
                     arg4: *mut XGCValues) -> libc::c_int;
}
extern "C" {
    pub fn XChangeKeyboardControl(arg1: *mut Display, arg2: libc::c_ulong,
                                  arg3: *mut XKeyboardControl) -> libc::c_int;
}
extern "C" {
    pub fn XChangeKeyboardMapping(arg1: *mut Display, arg2: libc::c_int,
                                  arg3: libc::c_int, arg4: *mut KeySym,
                                  arg5: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XChangePointerControl(arg1: *mut Display, arg2: libc::c_int,
                                 arg3: libc::c_int, arg4: libc::c_int,
                                 arg5: libc::c_int, arg6: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XChangeProperty(arg1: *mut Display, arg2: Window, arg3: Atom,
                           arg4: Atom, arg5: libc::c_int, arg6: libc::c_int,
                           arg7: *const libc::c_uchar, arg8: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XChangeSaveSet(arg1: *mut Display, arg2: Window, arg3: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XChangeWindowAttributes(arg1: *mut Display, arg2: Window,
                                   arg3: libc::c_ulong,
                                   arg4: *mut XSetWindowAttributes)
     -> libc::c_int;
}
extern "C" {
    pub fn XCheckIfEvent(arg1: *mut Display, arg2: *mut XEvent,
                         arg3:
                             ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut Display,
                                                                        arg2:
                                                                            *mut XEvent,
                                                                        arg3:
                                                                            XPointer)
                                                       -> libc::c_int>,
                         arg4: XPointer) -> libc::c_int;
}
extern "C" {
    pub fn XCheckMaskEvent(arg1: *mut Display, arg2: libc::c_long,
                           arg3: *mut XEvent) -> libc::c_int;
}
extern "C" {
    pub fn XCheckTypedEvent(arg1: *mut Display, arg2: libc::c_int,
                            arg3: *mut XEvent) -> libc::c_int;
}
extern "C" {
    pub fn XCheckTypedWindowEvent(arg1: *mut Display, arg2: Window,
                                  arg3: libc::c_int, arg4: *mut XEvent)
     -> libc::c_int;
}
extern "C" {
    pub fn XCheckWindowEvent(arg1: *mut Display, arg2: Window,
                             arg3: libc::c_long, arg4: *mut XEvent)
     -> libc::c_int;
}
extern "C" {
    pub fn XCirculateSubwindows(arg1: *mut Display, arg2: Window,
                                arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XCirculateSubwindowsDown(arg1: *mut Display, arg2: Window)
     -> libc::c_int;
}
extern "C" {
    pub fn XCirculateSubwindowsUp(arg1: *mut Display, arg2: Window)
     -> libc::c_int;
}
extern "C" {
    pub fn XClearArea(arg1: *mut Display, arg2: Window, arg3: libc::c_int,
                      arg4: libc::c_int, arg5: libc::c_uint,
                      arg6: libc::c_uint, arg7: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XClearWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XCloseDisplay(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XConfigureWindow(arg1: *mut Display, arg2: Window,
                            arg3: libc::c_uint, arg4: *mut XWindowChanges)
     -> libc::c_int;
}
extern "C" {
    pub fn XConnectionNumber(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XConvertSelection(arg1: *mut Display, arg2: Atom, arg3: Atom,
                             arg4: Atom, arg5: Window, arg6: Time)
     -> libc::c_int;
}
extern "C" {
    pub fn XCopyArea(arg1: *mut Display, arg2: Drawable, arg3: Drawable,
                     arg4: GC, arg5: libc::c_int, arg6: libc::c_int,
                     arg7: libc::c_uint, arg8: libc::c_uint,
                     arg9: libc::c_int, arg10: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XCopyGC(arg1: *mut Display, arg2: GC, arg3: libc::c_ulong,
                   arg4: GC) -> libc::c_int;
}
extern "C" {
    pub fn XCopyPlane(arg1: *mut Display, arg2: Drawable, arg3: Drawable,
                      arg4: GC, arg5: libc::c_int, arg6: libc::c_int,
                      arg7: libc::c_uint, arg8: libc::c_uint,
                      arg9: libc::c_int, arg10: libc::c_int,
                      arg11: libc::c_ulong) -> libc::c_int;
}
extern "C" {
    pub fn XDefaultDepth(arg1: *mut Display, arg2: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XDefaultDepthOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XDefaultScreen(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XDefineCursor(arg1: *mut Display, arg2: Window, arg3: Cursor)
     -> libc::c_int;
}
extern "C" {
    pub fn XDeleteProperty(arg1: *mut Display, arg2: Window, arg3: Atom)
     -> libc::c_int;
}
extern "C" {
    pub fn XDestroyWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XDestroySubwindows(arg1: *mut Display, arg2: Window)
     -> libc::c_int;
}
extern "C" {
    pub fn XDoesBackingStore(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XDoesSaveUnders(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XDisableAccessControl(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XDisplayCells(arg1: *mut Display, arg2: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XDisplayHeight(arg1: *mut Display, arg2: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XDisplayHeightMM(arg1: *mut Display, arg2: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XDisplayKeycodes(arg1: *mut Display, arg2: *mut libc::c_int,
                            arg3: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDisplayPlanes(arg1: *mut Display, arg2: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XDisplayWidth(arg1: *mut Display, arg2: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XDisplayWidthMM(arg1: *mut Display, arg2: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XDrawArc(arg1: *mut Display, arg2: Drawable, arg3: GC,
                    arg4: libc::c_int, arg5: libc::c_int, arg6: libc::c_uint,
                    arg7: libc::c_uint, arg8: libc::c_int, arg9: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XDrawArcs(arg1: *mut Display, arg2: Drawable, arg3: GC,
                     arg4: *mut XArc, arg5: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDrawImageString(arg1: *mut Display, arg2: Drawable, arg3: GC,
                            arg4: libc::c_int, arg5: libc::c_int,
                            arg6: *const libc::c_char, arg7: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XDrawImageString16(arg1: *mut Display, arg2: Drawable, arg3: GC,
                              arg4: libc::c_int, arg5: libc::c_int,
                              arg6: *const XChar2b, arg7: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XDrawLine(arg1: *mut Display, arg2: Drawable, arg3: GC,
                     arg4: libc::c_int, arg5: libc::c_int, arg6: libc::c_int,
                     arg7: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDrawLines(arg1: *mut Display, arg2: Drawable, arg3: GC,
                      arg4: *mut XPoint, arg5: libc::c_int, arg6: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XDrawPoint(arg1: *mut Display, arg2: Drawable, arg3: GC,
                      arg4: libc::c_int, arg5: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDrawPoints(arg1: *mut Display, arg2: Drawable, arg3: GC,
                       arg4: *mut XPoint, arg5: libc::c_int,
                       arg6: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDrawRectangle(arg1: *mut Display, arg2: Drawable, arg3: GC,
                          arg4: libc::c_int, arg5: libc::c_int,
                          arg6: libc::c_uint, arg7: libc::c_uint)
     -> libc::c_int;
}
extern "C" {
    pub fn XDrawRectangles(arg1: *mut Display, arg2: Drawable, arg3: GC,
                           arg4: *mut XRectangle, arg5: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XDrawSegments(arg1: *mut Display, arg2: Drawable, arg3: GC,
                         arg4: *mut XSegment, arg5: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XDrawString(arg1: *mut Display, arg2: Drawable, arg3: GC,
                       arg4: libc::c_int, arg5: libc::c_int,
                       arg6: *const libc::c_char, arg7: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XDrawString16(arg1: *mut Display, arg2: Drawable, arg3: GC,
                         arg4: libc::c_int, arg5: libc::c_int,
                         arg6: *const XChar2b, arg7: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XDrawText(arg1: *mut Display, arg2: Drawable, arg3: GC,
                     arg4: libc::c_int, arg5: libc::c_int,
                     arg6: *mut XTextItem, arg7: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDrawText16(arg1: *mut Display, arg2: Drawable, arg3: GC,
                       arg4: libc::c_int, arg5: libc::c_int,
                       arg6: *mut XTextItem16, arg7: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XEnableAccessControl(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XEventsQueued(arg1: *mut Display, arg2: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XFetchName(arg1: *mut Display, arg2: Window,
                      arg3: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XFillArc(arg1: *mut Display, arg2: Drawable, arg3: GC,
                    arg4: libc::c_int, arg5: libc::c_int, arg6: libc::c_uint,
                    arg7: libc::c_uint, arg8: libc::c_int, arg9: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XFillArcs(arg1: *mut Display, arg2: Drawable, arg3: GC,
                     arg4: *mut XArc, arg5: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XFillPolygon(arg1: *mut Display, arg2: Drawable, arg3: GC,
                        arg4: *mut XPoint, arg5: libc::c_int,
                        arg6: libc::c_int, arg7: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XFillRectangle(arg1: *mut Display, arg2: Drawable, arg3: GC,
                          arg4: libc::c_int, arg5: libc::c_int,
                          arg6: libc::c_uint, arg7: libc::c_uint)
     -> libc::c_int;
}
extern "C" {
    pub fn XFillRectangles(arg1: *mut Display, arg2: Drawable, arg3: GC,
                           arg4: *mut XRectangle, arg5: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XFlush(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XForceScreenSaver(arg1: *mut Display, arg2: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XFree(arg1: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn XFreeColormap(arg1: *mut Display, arg2: Colormap) -> libc::c_int;
}
extern "C" {
    pub fn XFreeColors(arg1: *mut Display, arg2: Colormap,
                       arg3: *mut libc::c_ulong, arg4: libc::c_int,
                       arg5: libc::c_ulong) -> libc::c_int;
}
extern "C" {
    pub fn XFreeCursor(arg1: *mut Display, arg2: Cursor) -> libc::c_int;
}
extern "C" {
    pub fn XFreeExtensionList(arg1: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XFreeFont(arg1: *mut Display, arg2: *mut XFontStruct)
     -> libc::c_int;
}
extern "C" {
    pub fn XFreeFontInfo(arg1: *mut *mut libc::c_char, arg2: *mut XFontStruct,
                         arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XFreeFontNames(arg1: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XFreeFontPath(arg1: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XFreeGC(arg1: *mut Display, arg2: GC) -> libc::c_int;
}
extern "C" {
    pub fn XFreeModifiermap(arg1: *mut XModifierKeymap) -> libc::c_int;
}
extern "C" {
    pub fn XFreePixmap(arg1: *mut Display, arg2: Pixmap) -> libc::c_int;
}
extern "C" {
    pub fn XGeometry(arg1: *mut Display, arg2: libc::c_int,
                     arg3: *const libc::c_char, arg4: *const libc::c_char,
                     arg5: libc::c_uint, arg6: libc::c_uint,
                     arg7: libc::c_uint, arg8: libc::c_int, arg9: libc::c_int,
                     arg10: *mut libc::c_int, arg11: *mut libc::c_int,
                     arg12: *mut libc::c_int, arg13: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XGetErrorDatabaseText(arg1: *mut Display,
                                 arg2: *const libc::c_char,
                                 arg3: *const libc::c_char,
                                 arg4: *const libc::c_char,
                                 arg5: *mut libc::c_char, arg6: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XGetErrorText(arg1: *mut Display, arg2: libc::c_int,
                         arg3: *mut libc::c_char, arg4: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XGetFontProperty(arg1: *mut XFontStruct, arg2: Atom,
                            arg3: *mut libc::c_ulong) -> libc::c_int;
}
extern "C" {
    pub fn XGetGCValues(arg1: *mut Display, arg2: GC, arg3: libc::c_ulong,
                        arg4: *mut XGCValues) -> libc::c_int;
}
extern "C" {
    pub fn XGetGeometry(arg1: *mut Display, arg2: Drawable, arg3: *mut Window,
                        arg4: *mut libc::c_int, arg5: *mut libc::c_int,
                        arg6: *mut libc::c_uint, arg7: *mut libc::c_uint,
                        arg8: *mut libc::c_uint, arg9: *mut libc::c_uint)
     -> libc::c_int;
}
extern "C" {
    pub fn XGetIconName(arg1: *mut Display, arg2: Window,
                        arg3: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XGetInputFocus(arg1: *mut Display, arg2: *mut Window,
                          arg3: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XGetKeyboardControl(arg1: *mut Display, arg2: *mut XKeyboardState)
     -> libc::c_int;
}
extern "C" {
    pub fn XGetPointerControl(arg1: *mut Display, arg2: *mut libc::c_int,
                              arg3: *mut libc::c_int, arg4: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XGetPointerMapping(arg1: *mut Display, arg2: *mut libc::c_uchar,
                              arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XGetScreenSaver(arg1: *mut Display, arg2: *mut libc::c_int,
                           arg3: *mut libc::c_int, arg4: *mut libc::c_int,
                           arg5: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XGetTransientForHint(arg1: *mut Display, arg2: Window,
                                arg3: *mut Window) -> libc::c_int;
}
extern "C" {
    pub fn XGetWindowProperty(arg1: *mut Display, arg2: Window, arg3: Atom,
                              arg4: libc::c_long, arg5: libc::c_long,
                              arg6: libc::c_int, arg7: Atom, arg8: *mut Atom,
                              arg9: *mut libc::c_int,
                              arg10: *mut libc::c_ulong,
                              arg11: *mut libc::c_ulong,
                              arg12: *mut *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    pub fn XGetWindowAttributes(arg1: *mut Display, arg2: Window,
                                arg3: *mut XWindowAttributes) -> libc::c_int;
}
extern "C" {
    pub fn XGrabButton(arg1: *mut Display, arg2: libc::c_uint,
                       arg3: libc::c_uint, arg4: Window, arg5: libc::c_int,
                       arg6: libc::c_uint, arg7: libc::c_int,
                       arg8: libc::c_int, arg9: Window, arg10: Cursor)
     -> libc::c_int;
}
extern "C" {
    pub fn XGrabKey(arg1: *mut Display, arg2: libc::c_int, arg3: libc::c_uint,
                    arg4: Window, arg5: libc::c_int, arg6: libc::c_int,
                    arg7: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XGrabKeyboard(arg1: *mut Display, arg2: Window, arg3: libc::c_int,
                         arg4: libc::c_int, arg5: libc::c_int, arg6: Time)
     -> libc::c_int;
}
extern "C" {
    pub fn XGrabPointer(arg1: *mut Display, arg2: Window, arg3: libc::c_int,
                        arg4: libc::c_uint, arg5: libc::c_int,
                        arg6: libc::c_int, arg7: Window, arg8: Cursor,
                        arg9: Time) -> libc::c_int;
}
extern "C" {
    pub fn XGrabServer(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XHeightMMOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XHeightOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XIfEvent(arg1: *mut Display, arg2: *mut XEvent,
                    arg3:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut Display,
                                                                   arg2:
                                                                       *mut XEvent,
                                                                   arg3:
                                                                       XPointer)
                                                  -> libc::c_int>,
                    arg4: XPointer) -> libc::c_int;
}
extern "C" {
    pub fn XImageByteOrder(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XInstallColormap(arg1: *mut Display, arg2: Colormap)
     -> libc::c_int;
}
extern "C" {
    pub fn XKeysymToKeycode(arg1: *mut Display, arg2: KeySym) -> KeyCode;
}
extern "C" {
    pub fn XKillClient(arg1: *mut Display, arg2: XID) -> libc::c_int;
}
extern "C" {
    pub fn XLookupColor(arg1: *mut Display, arg2: Colormap,
                        arg3: *const libc::c_char, arg4: *mut XColor,
                        arg5: *mut XColor) -> libc::c_int;
}
extern "C" {
    pub fn XLowerWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XMapRaised(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XMapSubwindows(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XMapWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XMaskEvent(arg1: *mut Display, arg2: libc::c_long,
                      arg3: *mut XEvent) -> libc::c_int;
}
extern "C" {
    pub fn XMaxCmapsOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XMinCmapsOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XMoveResizeWindow(arg1: *mut Display, arg2: Window,
                             arg3: libc::c_int, arg4: libc::c_int,
                             arg5: libc::c_uint, arg6: libc::c_uint)
     -> libc::c_int;
}
extern "C" {
    pub fn XMoveWindow(arg1: *mut Display, arg2: Window, arg3: libc::c_int,
                       arg4: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XNextEvent(arg1: *mut Display, arg2: *mut XEvent) -> libc::c_int;
}
extern "C" {
    pub fn XNoOp(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XParseColor(arg1: *mut Display, arg2: Colormap,
                       arg3: *const libc::c_char, arg4: *mut XColor)
     -> libc::c_int;
}
extern "C" {
    pub fn XParseGeometry(arg1: *const libc::c_char, arg2: *mut libc::c_int,
                          arg3: *mut libc::c_int, arg4: *mut libc::c_uint,
                          arg5: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn XPeekEvent(arg1: *mut Display, arg2: *mut XEvent) -> libc::c_int;
}
extern "C" {
    pub fn XPeekIfEvent(arg1: *mut Display, arg2: *mut XEvent,
                        arg3:
                            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut Display,
                                                                       arg2:
                                                                           *mut XEvent,
                                                                       arg3:
                                                                           XPointer)
                                                      -> libc::c_int>,
                        arg4: XPointer) -> libc::c_int;
}
extern "C" {
    pub fn XPending(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XPlanesOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XProtocolRevision(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XProtocolVersion(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XPutBackEvent(arg1: *mut Display, arg2: *mut XEvent)
     -> libc::c_int;
}
extern "C" {
    pub fn XPutImage(arg1: *mut Display, arg2: Drawable, arg3: GC,
                     arg4: *mut XImage, arg5: libc::c_int, arg6: libc::c_int,
                     arg7: libc::c_int, arg8: libc::c_int, arg9: libc::c_uint,
                     arg10: libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn XQLength(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XQueryBestCursor(arg1: *mut Display, arg2: Drawable,
                            arg3: libc::c_uint, arg4: libc::c_uint,
                            arg5: *mut libc::c_uint, arg6: *mut libc::c_uint)
     -> libc::c_int;
}
extern "C" {
    pub fn XQueryBestSize(arg1: *mut Display, arg2: libc::c_int,
                          arg3: Drawable, arg4: libc::c_uint,
                          arg5: libc::c_uint, arg6: *mut libc::c_uint,
                          arg7: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn XQueryBestStipple(arg1: *mut Display, arg2: Drawable,
                             arg3: libc::c_uint, arg4: libc::c_uint,
                             arg5: *mut libc::c_uint, arg6: *mut libc::c_uint)
     -> libc::c_int;
}
extern "C" {
    pub fn XQueryBestTile(arg1: *mut Display, arg2: Drawable,
                          arg3: libc::c_uint, arg4: libc::c_uint,
                          arg5: *mut libc::c_uint, arg6: *mut libc::c_uint)
     -> libc::c_int;
}
extern "C" {
    pub fn XQueryColor(arg1: *mut Display, arg2: Colormap, arg3: *mut XColor)
     -> libc::c_int;
}
extern "C" {
    pub fn XQueryColors(arg1: *mut Display, arg2: Colormap, arg3: *mut XColor,
                        arg4: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XQueryExtension(arg1: *mut Display, arg2: *const libc::c_char,
                           arg3: *mut libc::c_int, arg4: *mut libc::c_int,
                           arg5: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XQueryKeymap(arg1: *mut Display, arg2: *mut libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn XQueryPointer(arg1: *mut Display, arg2: Window, arg3: *mut Window,
                         arg4: *mut Window, arg5: *mut libc::c_int,
                         arg6: *mut libc::c_int, arg7: *mut libc::c_int,
                         arg8: *mut libc::c_int, arg9: *mut libc::c_uint)
     -> libc::c_int;
}
extern "C" {
    pub fn XQueryTextExtents(arg1: *mut Display, arg2: XID,
                             arg3: *const libc::c_char, arg4: libc::c_int,
                             arg5: *mut libc::c_int, arg6: *mut libc::c_int,
                             arg7: *mut libc::c_int, arg8: *mut XCharStruct)
     -> libc::c_int;
}
extern "C" {
    pub fn XQueryTextExtents16(arg1: *mut Display, arg2: XID,
                               arg3: *const XChar2b, arg4: libc::c_int,
                               arg5: *mut libc::c_int, arg6: *mut libc::c_int,
                               arg7: *mut libc::c_int, arg8: *mut XCharStruct)
     -> libc::c_int;
}
extern "C" {
    pub fn XQueryTree(arg1: *mut Display, arg2: Window, arg3: *mut Window,
                      arg4: *mut Window, arg5: *mut *mut Window,
                      arg6: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn XRaiseWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XReadBitmapFile(arg1: *mut Display, arg2: Drawable,
                           arg3: *const libc::c_char, arg4: *mut libc::c_uint,
                           arg5: *mut libc::c_uint, arg6: *mut Pixmap,
                           arg7: *mut libc::c_int, arg8: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XReadBitmapFileData(arg1: *const libc::c_char,
                               arg2: *mut libc::c_uint,
                               arg3: *mut libc::c_uint,
                               arg4: *mut *mut libc::c_uchar,
                               arg5: *mut libc::c_int, arg6: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XRebindKeysym(arg1: *mut Display, arg2: KeySym, arg3: *mut KeySym,
                         arg4: libc::c_int, arg5: *const libc::c_uchar,
                         arg6: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XRecolorCursor(arg1: *mut Display, arg2: Cursor, arg3: *mut XColor,
                          arg4: *mut XColor) -> libc::c_int;
}
extern "C" {
    pub fn XRefreshKeyboardMapping(arg1: *mut XMappingEvent) -> libc::c_int;
}
extern "C" {
    pub fn XRemoveFromSaveSet(arg1: *mut Display, arg2: Window)
     -> libc::c_int;
}
extern "C" {
    pub fn XRemoveHost(arg1: *mut Display, arg2: *mut XHostAddress)
     -> libc::c_int;
}
extern "C" {
    pub fn XRemoveHosts(arg1: *mut Display, arg2: *mut XHostAddress,
                        arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XReparentWindow(arg1: *mut Display, arg2: Window, arg3: Window,
                           arg4: libc::c_int, arg5: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XResetScreenSaver(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XResizeWindow(arg1: *mut Display, arg2: Window, arg3: libc::c_uint,
                         arg4: libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn XRestackWindows(arg1: *mut Display, arg2: *mut Window,
                           arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XRotateBuffers(arg1: *mut Display, arg2: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XRotateWindowProperties(arg1: *mut Display, arg2: Window,
                                   arg3: *mut Atom, arg4: libc::c_int,
                                   arg5: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XScreenCount(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XSelectInput(arg1: *mut Display, arg2: Window, arg3: libc::c_long)
     -> libc::c_int;
}
extern "C" {
    pub fn XSendEvent(arg1: *mut Display, arg2: Window, arg3: libc::c_int,
                      arg4: libc::c_long, arg5: *mut XEvent) -> libc::c_int;
}
extern "C" {
    pub fn XSetAccessControl(arg1: *mut Display, arg2: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetArcMode(arg1: *mut Display, arg2: GC, arg3: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetBackground(arg1: *mut Display, arg2: GC, arg3: libc::c_ulong)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetClipMask(arg1: *mut Display, arg2: GC, arg3: Pixmap)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetClipOrigin(arg1: *mut Display, arg2: GC, arg3: libc::c_int,
                          arg4: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetClipRectangles(arg1: *mut Display, arg2: GC, arg3: libc::c_int,
                              arg4: libc::c_int, arg5: *mut XRectangle,
                              arg6: libc::c_int, arg7: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetCloseDownMode(arg1: *mut Display, arg2: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetCommand(arg1: *mut Display, arg2: Window,
                       arg3: *mut *mut libc::c_char, arg4: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetDashes(arg1: *mut Display, arg2: GC, arg3: libc::c_int,
                      arg4: *const libc::c_char, arg5: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetFillRule(arg1: *mut Display, arg2: GC, arg3: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetFillStyle(arg1: *mut Display, arg2: GC, arg3: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetFont(arg1: *mut Display, arg2: GC, arg3: Font) -> libc::c_int;
}
extern "C" {
    pub fn XSetFontPath(arg1: *mut Display, arg2: *mut *mut libc::c_char,
                        arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetForeground(arg1: *mut Display, arg2: GC, arg3: libc::c_ulong)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetFunction(arg1: *mut Display, arg2: GC, arg3: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetGraphicsExposures(arg1: *mut Display, arg2: GC,
                                 arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetIconName(arg1: *mut Display, arg2: Window,
                        arg3: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XSetInputFocus(arg1: *mut Display, arg2: Window, arg3: libc::c_int,
                          arg4: Time) -> libc::c_int;
}
extern "C" {
    pub fn XSetLineAttributes(arg1: *mut Display, arg2: GC,
                              arg3: libc::c_uint, arg4: libc::c_int,
                              arg5: libc::c_int, arg6: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetModifierMapping(arg1: *mut Display, arg2: *mut XModifierKeymap)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetPlaneMask(arg1: *mut Display, arg2: GC, arg3: libc::c_ulong)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetPointerMapping(arg1: *mut Display, arg2: *const libc::c_uchar,
                              arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetScreenSaver(arg1: *mut Display, arg2: libc::c_int,
                           arg3: libc::c_int, arg4: libc::c_int,
                           arg5: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetSelectionOwner(arg1: *mut Display, arg2: Atom, arg3: Window,
                              arg4: Time) -> libc::c_int;
}
extern "C" {
    pub fn XSetState(arg1: *mut Display, arg2: GC, arg3: libc::c_ulong,
                     arg4: libc::c_ulong, arg5: libc::c_int,
                     arg6: libc::c_ulong) -> libc::c_int;
}
extern "C" {
    pub fn XSetStipple(arg1: *mut Display, arg2: GC, arg3: Pixmap)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetSubwindowMode(arg1: *mut Display, arg2: GC, arg3: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetTSOrigin(arg1: *mut Display, arg2: GC, arg3: libc::c_int,
                        arg4: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetTile(arg1: *mut Display, arg2: GC, arg3: Pixmap)
     -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowBackground(arg1: *mut Display, arg2: Window,
                                arg3: libc::c_ulong) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowBackgroundPixmap(arg1: *mut Display, arg2: Window,
                                      arg3: Pixmap) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowBorder(arg1: *mut Display, arg2: Window,
                            arg3: libc::c_ulong) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowBorderPixmap(arg1: *mut Display, arg2: Window,
                                  arg3: Pixmap) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowBorderWidth(arg1: *mut Display, arg2: Window,
                                 arg3: libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowColormap(arg1: *mut Display, arg2: Window,
                              arg3: Colormap) -> libc::c_int;
}
extern "C" {
    pub fn XStoreBuffer(arg1: *mut Display, arg2: *const libc::c_char,
                        arg3: libc::c_int, arg4: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XStoreBytes(arg1: *mut Display, arg2: *const libc::c_char,
                       arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XStoreColor(arg1: *mut Display, arg2: Colormap, arg3: *mut XColor)
     -> libc::c_int;
}
extern "C" {
    pub fn XStoreColors(arg1: *mut Display, arg2: Colormap, arg3: *mut XColor,
                        arg4: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XStoreName(arg1: *mut Display, arg2: Window,
                      arg3: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XStoreNamedColor(arg1: *mut Display, arg2: Colormap,
                            arg3: *const libc::c_char, arg4: libc::c_ulong,
                            arg5: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSync(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XTextExtents(arg1: *mut XFontStruct, arg2: *const libc::c_char,
                        arg3: libc::c_int, arg4: *mut libc::c_int,
                        arg5: *mut libc::c_int, arg6: *mut libc::c_int,
                        arg7: *mut XCharStruct) -> libc::c_int;
}
extern "C" {
    pub fn XTextExtents16(arg1: *mut XFontStruct, arg2: *const XChar2b,
                          arg3: libc::c_int, arg4: *mut libc::c_int,
                          arg5: *mut libc::c_int, arg6: *mut libc::c_int,
                          arg7: *mut XCharStruct) -> libc::c_int;
}
extern "C" {
    pub fn XTextWidth(arg1: *mut XFontStruct, arg2: *const libc::c_char,
                      arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XTextWidth16(arg1: *mut XFontStruct, arg2: *const XChar2b,
                        arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XTranslateCoordinates(arg1: *mut Display, arg2: Window,
                                 arg3: Window, arg4: libc::c_int,
                                 arg5: libc::c_int, arg6: *mut libc::c_int,
                                 arg7: *mut libc::c_int, arg8: *mut Window)
     -> libc::c_int;
}
extern "C" {
    pub fn XUndefineCursor(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XUngrabButton(arg1: *mut Display, arg2: libc::c_uint,
                         arg3: libc::c_uint, arg4: Window) -> libc::c_int;
}
extern "C" {
    pub fn XUngrabKey(arg1: *mut Display, arg2: libc::c_int,
                      arg3: libc::c_uint, arg4: Window) -> libc::c_int;
}
extern "C" {
    pub fn XUngrabKeyboard(arg1: *mut Display, arg2: Time) -> libc::c_int;
}
extern "C" {
    pub fn XUngrabPointer(arg1: *mut Display, arg2: Time) -> libc::c_int;
}
extern "C" {
    pub fn XUngrabServer(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XUninstallColormap(arg1: *mut Display, arg2: Colormap)
     -> libc::c_int;
}
extern "C" {
    pub fn XUnloadFont(arg1: *mut Display, arg2: Font) -> libc::c_int;
}
extern "C" {
    pub fn XUnmapSubwindows(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XUnmapWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XVendorRelease(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XWarpPointer(arg1: *mut Display, arg2: Window, arg3: Window,
                        arg4: libc::c_int, arg5: libc::c_int,
                        arg6: libc::c_uint, arg7: libc::c_uint,
                        arg8: libc::c_int, arg9: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XWidthMMOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XWidthOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XWindowEvent(arg1: *mut Display, arg2: Window, arg3: libc::c_long,
                        arg4: *mut XEvent) -> libc::c_int;
}
extern "C" {
    pub fn XWriteBitmapFile(arg1: *mut Display, arg2: *const libc::c_char,
                            arg3: Pixmap, arg4: libc::c_uint,
                            arg5: libc::c_uint, arg6: libc::c_int,
                            arg7: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSupportsLocale() -> libc::c_int;
}
extern "C" {
    pub fn XSetLocaleModifiers(arg1: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn XOpenOM(arg1: *mut Display, arg2: *mut _XrmHashBucketRec,
                   arg3: *const libc::c_char, arg4: *const libc::c_char)
     -> XOM;
}
extern "C" {
    pub fn XCloseOM(arg1: XOM) -> libc::c_int;
}
extern "C" {
    pub fn XSetOMValues(arg1: XOM, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XGetOMValues(arg1: XOM, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDisplayOfOM(arg1: XOM) -> *mut Display;
}
extern "C" {
    pub fn XLocaleOfOM(arg1: XOM) -> *mut libc::c_char;
}
extern "C" {
    pub fn XCreateOC(arg1: XOM, ...) -> XOC;
}
extern "C" {
    pub fn XDestroyOC(arg1: XOC);
}
extern "C" {
    pub fn XOMOfOC(arg1: XOC) -> XOM;
}
extern "C" {
    pub fn XSetOCValues(arg1: XOC, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XGetOCValues(arg1: XOC, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XCreateFontSet(arg1: *mut Display, arg2: *const libc::c_char,
                          arg3: *mut *mut *mut libc::c_char,
                          arg4: *mut libc::c_int,
                          arg5: *mut *mut libc::c_char) -> XFontSet;
}
extern "C" {
    pub fn XFreeFontSet(arg1: *mut Display, arg2: XFontSet);
}
extern "C" {
    pub fn XFontsOfFontSet(arg1: XFontSet, arg2: *mut *mut *mut XFontStruct,
                           arg3: *mut *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XBaseFontNameListOfFontSet(arg1: XFontSet) -> *mut libc::c_char;
}
extern "C" {
    pub fn XLocaleOfFontSet(arg1: XFontSet) -> *mut libc::c_char;
}
extern "C" {
    pub fn XContextDependentDrawing(arg1: XFontSet) -> libc::c_int;
}
extern "C" {
    pub fn XDirectionalDependentDrawing(arg1: XFontSet) -> libc::c_int;
}
extern "C" {
    pub fn XContextualDrawing(arg1: XFontSet) -> libc::c_int;
}
extern "C" {
    pub fn XExtentsOfFontSet(arg1: XFontSet) -> *mut XFontSetExtents;
}
extern "C" {
    pub fn XmbTextEscapement(arg1: XFontSet, arg2: *const libc::c_char,
                             arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XwcTextEscapement(arg1: XFontSet, arg2: *const wchar_t,
                             arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn Xutf8TextEscapement(arg1: XFontSet, arg2: *const libc::c_char,
                               arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XmbTextExtents(arg1: XFontSet, arg2: *const libc::c_char,
                          arg3: libc::c_int, arg4: *mut XRectangle,
                          arg5: *mut XRectangle) -> libc::c_int;
}
extern "C" {
    pub fn XwcTextExtents(arg1: XFontSet, arg2: *const wchar_t,
                          arg3: libc::c_int, arg4: *mut XRectangle,
                          arg5: *mut XRectangle) -> libc::c_int;
}
extern "C" {
    pub fn Xutf8TextExtents(arg1: XFontSet, arg2: *const libc::c_char,
                            arg3: libc::c_int, arg4: *mut XRectangle,
                            arg5: *mut XRectangle) -> libc::c_int;
}
extern "C" {
    pub fn XmbTextPerCharExtents(arg1: XFontSet, arg2: *const libc::c_char,
                                 arg3: libc::c_int, arg4: *mut XRectangle,
                                 arg5: *mut XRectangle, arg6: libc::c_int,
                                 arg7: *mut libc::c_int,
                                 arg8: *mut XRectangle, arg9: *mut XRectangle)
     -> libc::c_int;
}
extern "C" {
    pub fn XwcTextPerCharExtents(arg1: XFontSet, arg2: *const wchar_t,
                                 arg3: libc::c_int, arg4: *mut XRectangle,
                                 arg5: *mut XRectangle, arg6: libc::c_int,
                                 arg7: *mut libc::c_int,
                                 arg8: *mut XRectangle, arg9: *mut XRectangle)
     -> libc::c_int;
}
extern "C" {
    pub fn Xutf8TextPerCharExtents(arg1: XFontSet, arg2: *const libc::c_char,
                                   arg3: libc::c_int, arg4: *mut XRectangle,
                                   arg5: *mut XRectangle, arg6: libc::c_int,
                                   arg7: *mut libc::c_int,
                                   arg8: *mut XRectangle,
                                   arg9: *mut XRectangle) -> libc::c_int;
}
extern "C" {
    pub fn XmbDrawText(arg1: *mut Display, arg2: Drawable, arg3: GC,
                       arg4: libc::c_int, arg5: libc::c_int,
                       arg6: *mut XmbTextItem, arg7: libc::c_int);
}
extern "C" {
    pub fn XwcDrawText(arg1: *mut Display, arg2: Drawable, arg3: GC,
                       arg4: libc::c_int, arg5: libc::c_int,
                       arg6: *mut XwcTextItem, arg7: libc::c_int);
}
extern "C" {
    pub fn Xutf8DrawText(arg1: *mut Display, arg2: Drawable, arg3: GC,
                         arg4: libc::c_int, arg5: libc::c_int,
                         arg6: *mut XmbTextItem, arg7: libc::c_int);
}
extern "C" {
    pub fn XmbDrawString(arg1: *mut Display, arg2: Drawable, arg3: XFontSet,
                         arg4: GC, arg5: libc::c_int, arg6: libc::c_int,
                         arg7: *const libc::c_char, arg8: libc::c_int);
}
extern "C" {
    pub fn XwcDrawString(arg1: *mut Display, arg2: Drawable, arg3: XFontSet,
                         arg4: GC, arg5: libc::c_int, arg6: libc::c_int,
                         arg7: *const wchar_t, arg8: libc::c_int);
}
extern "C" {
    pub fn Xutf8DrawString(arg1: *mut Display, arg2: Drawable, arg3: XFontSet,
                           arg4: GC, arg5: libc::c_int, arg6: libc::c_int,
                           arg7: *const libc::c_char, arg8: libc::c_int);
}
extern "C" {
    pub fn XmbDrawImageString(arg1: *mut Display, arg2: Drawable,
                              arg3: XFontSet, arg4: GC, arg5: libc::c_int,
                              arg6: libc::c_int, arg7: *const libc::c_char,
                              arg8: libc::c_int);
}
extern "C" {
    pub fn XwcDrawImageString(arg1: *mut Display, arg2: Drawable,
                              arg3: XFontSet, arg4: GC, arg5: libc::c_int,
                              arg6: libc::c_int, arg7: *const wchar_t,
                              arg8: libc::c_int);
}
extern "C" {
    pub fn Xutf8DrawImageString(arg1: *mut Display, arg2: Drawable,
                                arg3: XFontSet, arg4: GC, arg5: libc::c_int,
                                arg6: libc::c_int, arg7: *const libc::c_char,
                                arg8: libc::c_int);
}
extern "C" {
    pub fn XOpenIM(arg1: *mut Display, arg2: *mut _XrmHashBucketRec,
                   arg3: *mut libc::c_char, arg4: *mut libc::c_char) -> XIM;
}
extern "C" {
    pub fn XCloseIM(arg1: XIM) -> libc::c_int;
}
extern "C" {
    pub fn XGetIMValues(arg1: XIM, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XSetIMValues(arg1: XIM, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDisplayOfIM(arg1: XIM) -> *mut Display;
}
extern "C" {
    pub fn XLocaleOfIM(arg1: XIM) -> *mut libc::c_char;
}
extern "C" {
    pub fn XCreateIC(arg1: XIM, ...) -> XIC;
}
extern "C" {
    pub fn XDestroyIC(arg1: XIC);
}
extern "C" {
    pub fn XSetICFocus(arg1: XIC);
}
extern "C" {
    pub fn XUnsetICFocus(arg1: XIC);
}
extern "C" {
    pub fn XwcResetIC(arg1: XIC) -> *mut wchar_t;
}
extern "C" {
    pub fn XmbResetIC(arg1: XIC) -> *mut libc::c_char;
}
extern "C" {
    pub fn Xutf8ResetIC(arg1: XIC) -> *mut libc::c_char;
}
extern "C" {
    pub fn XSetICValues(arg1: XIC, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XGetICValues(arg1: XIC, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XIMOfIC(arg1: XIC) -> XIM;
}
extern "C" {
    pub fn XFilterEvent(arg1: *mut XEvent, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XmbLookupString(arg1: XIC, arg2: *mut XKeyPressedEvent,
                           arg3: *mut libc::c_char, arg4: libc::c_int,
                           arg5: *mut KeySym, arg6: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XwcLookupString(arg1: XIC, arg2: *mut XKeyPressedEvent,
                           arg3: *mut wchar_t, arg4: libc::c_int,
                           arg5: *mut KeySym, arg6: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn Xutf8LookupString(arg1: XIC, arg2: *mut XKeyPressedEvent,
                             arg3: *mut libc::c_char, arg4: libc::c_int,
                             arg5: *mut KeySym, arg6: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn XVaCreateNestedList(arg1: libc::c_int, ...) -> XVaNestedList;
}
extern "C" {
    pub fn XRegisterIMInstantiateCallback(arg1: *mut Display,
                                          arg2: *mut _XrmHashBucketRec,
                                          arg3: *mut libc::c_char,
                                          arg4: *mut libc::c_char,
                                          arg5: XIDProc, arg6: XPointer)
     -> libc::c_int;
}
extern "C" {
    pub fn XUnregisterIMInstantiateCallback(arg1: *mut Display,
                                            arg2: *mut _XrmHashBucketRec,
                                            arg3: *mut libc::c_char,
                                            arg4: *mut libc::c_char,
                                            arg5: XIDProc, arg6: XPointer)
     -> libc::c_int;
}
pub type XConnectionWatchProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Display,
                                               arg2: XPointer,
                                               arg3: libc::c_int,
                                               arg4: libc::c_int,
                                               arg5: *mut XPointer)>;
extern "C" {
    pub fn XInternalConnectionNumbers(arg1: *mut Display,
                                      arg2: *mut *mut libc::c_int,
                                      arg3: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XProcessInternalConnection(arg1: *mut Display, arg2: libc::c_int);
}
extern "C" {
    pub fn XAddConnectionWatch(arg1: *mut Display, arg2: XConnectionWatchProc,
                               arg3: XPointer) -> libc::c_int;
}
extern "C" {
    pub fn XRemoveConnectionWatch(arg1: *mut Display,
                                  arg2: XConnectionWatchProc, arg3: XPointer);
}
extern "C" {
    pub fn XSetAuthorization(arg1: *mut libc::c_char, arg2: libc::c_int,
                             arg3: *mut libc::c_char, arg4: libc::c_int);
}
extern "C" {
    pub fn _Xmbtowc(arg1: *mut wchar_t, arg2: *mut libc::c_char,
                    arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _Xwctomb(arg1: *mut libc::c_char, arg2: wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn XGetEventData(arg1: *mut Display, arg2: *mut XGenericEventCookie)
     -> libc::c_int;
}
extern "C" {
    pub fn XFreeEventData(arg1: *mut Display, arg2: *mut XGenericEventCookie);
}
pub type int_least8_t = libc::c_char;
pub type int_least16_t = libc::c_short;
pub type int_least32_t = libc::c_int;
pub type int_least64_t = libc::c_long;
pub type uint_least8_t = libc::c_uchar;
pub type uint_least16_t = libc::c_ushort;
pub type uint_least32_t = libc::c_uint;
pub type uint_least64_t = libc::c_ulong;
pub type int_fast8_t = libc::c_char;
pub type int_fast16_t = libc::c_long;
pub type int_fast32_t = libc::c_long;
pub type int_fast64_t = libc::c_long;
pub type uint_fast8_t = libc::c_uchar;
pub type uint_fast16_t = libc::c_ulong;
pub type uint_fast32_t = libc::c_ulong;
pub type uint_fast64_t = libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct iovec {
    pub iov_base: *mut libc::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(::std::mem::size_of::<iovec>() , 16usize);
    assert_eq!(::std::mem::align_of::<iovec>() , 8usize);
}
impl Clone for iovec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn readv(__fd: libc::c_int, __iovec: *const iovec,
                 __count: libc::c_int) -> isize;
}
extern "C" {
    pub fn writev(__fd: libc::c_int, __iovec: *const iovec,
                  __count: libc::c_int) -> isize;
}
extern "C" {
    pub fn preadv(__fd: libc::c_int, __iovec: *const iovec,
                  __count: libc::c_int, __offset: __off_t) -> isize;
}
extern "C" {
    pub fn pwritev(__fd: libc::c_int, __iovec: *const iovec,
                   __count: libc::c_int, __offset: __off_t) -> isize;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sched_param {
    pub __sched_priority: libc::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(::std::mem::size_of::<sched_param>() , 4usize);
    assert_eq!(::std::mem::align_of::<sched_param>() , 4usize);
}
impl Clone for sched_param {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sched_param {
    pub __sched_priority: libc::c_int,
}
#[test]
fn bindgen_test_layout___sched_param() {
    assert_eq!(::std::mem::size_of::<__sched_param>() , 4usize);
    assert_eq!(::std::mem::align_of::<__sched_param>() , 4usize);
}
impl Clone for __sched_param {
    fn clone(&self) -> Self { *self }
}
pub type __cpu_mask = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_90 {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_90() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_90>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_90>() , 8usize);
}
impl Clone for _bindgen_ty_90 {
    fn clone(&self) -> Self { *self }
}
pub type cpu_set_t = _bindgen_ty_90;
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t)
     -> libc::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param)
     -> libc::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param)
     -> libc::c_int;
}
extern "C" {
    pub fn sched_setscheduler(__pid: __pid_t, __policy: libc::c_int,
                              __param: *const sched_param) -> libc::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> libc::c_int;
}
extern "C" {
    pub fn sched_yield() -> libc::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec)
     -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 56usize);
    assert_eq!(::std::mem::align_of::<tm>() , 8usize);
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::std::mem::size_of::<itimerspec>() , 32usize);
    assert_eq!(::std::mem::align_of::<itimerspec>() , 8usize);
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_struct___locale_data; 13usize],
    pub __ctype_b: *const libc::c_ushort,
    pub __ctype_tolower: *const libc::c_int,
    pub __ctype_toupper: *const libc::c_int,
    pub __names: [*const libc::c_char; 13usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct___locale_data([u8; 0]);
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize);
    assert_eq!(::std::mem::align_of::<__locale_struct>() , 8usize);
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(__s: *mut libc::c_char, __maxsize: usize,
                    __format: *const libc::c_char, __tp: *const tm) -> usize;
}
extern "C" {
    pub fn strftime_l(__s: *mut libc::c_char, __maxsize: usize,
                      __format: *const libc::c_char, __tp: *const tm,
                      __loc: __locale_t) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    #[link_name = "__tzname"]
    pub static mut __tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    #[link_name = "__daylight"]
    pub static mut __daylight: libc::c_int;
}
extern "C" {
    #[link_name = "__timezone"]
    pub static mut __timezone: libc::c_long;
}
extern "C" {
    #[link_name = "tzname"]
    pub static mut tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    #[link_name = "daylight"]
    pub static mut daylight: libc::c_int;
}
extern "C" {
    #[link_name = "timezone"]
    pub static mut timezone: libc::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> libc::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec,
                     __remaining: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec)
     -> libc::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec)
     -> libc::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec)
     -> libc::c_int;
}
extern "C" {
    pub fn clock_nanosleep(__clock_id: clockid_t, __flags: libc::c_int,
                           __req: *const timespec, __rem: *mut timespec)
     -> libc::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t)
     -> libc::c_int;
}
extern "C" {
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut sigevent,
                        __timerid: *mut timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timer_settime(__timerid: timer_t, __flags: libc::c_int,
                         __value: *const itimerspec,
                         __ovalue: *mut itimerspec) -> libc::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec)
     -> libc::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: libc::c_int)
     -> libc::c_int;
}
pub type __jmp_buf = [libc::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_91 =
    _bindgen_ty_91::PTHREAD_CREATE_JOINABLE;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_91 =
    _bindgen_ty_91::PTHREAD_CREATE_DETACHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_91 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1,
}
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_92 =
    _bindgen_ty_92::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_92 =
    _bindgen_ty_92::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_92 =
    _bindgen_ty_92::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_92 =
    _bindgen_ty_92::PTHREAD_MUTEX_ADAPTIVE_NP;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_92 =
    _bindgen_ty_92::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_92 =
    _bindgen_ty_92::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_92 =
    _bindgen_ty_92::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_92 =
    _bindgen_ty_92::PTHREAD_MUTEX_TIMED_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_92 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
}
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_93 =
    _bindgen_ty_93::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_93 =
    _bindgen_ty_93::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_93 =
    _bindgen_ty_93::PTHREAD_MUTEX_ROBUST;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_93 =
    _bindgen_ty_93::PTHREAD_MUTEX_ROBUST;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_93 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_ROBUST = 1,
}
pub const PTHREAD_PRIO_NONE: _bindgen_ty_94 =
    _bindgen_ty_94::PTHREAD_PRIO_NONE;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_94 =
    _bindgen_ty_94::PTHREAD_PRIO_INHERIT;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_94 =
    _bindgen_ty_94::PTHREAD_PRIO_PROTECT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_94 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2,
}
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_95 =
    _bindgen_ty_95::PTHREAD_RWLOCK_PREFER_READER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_95 =
    _bindgen_ty_95::PTHREAD_RWLOCK_PREFER_WRITER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_95 =
    _bindgen_ty_95::PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_95 =
    _bindgen_ty_95::PTHREAD_RWLOCK_PREFER_READER_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_95 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
}
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_96 =
    _bindgen_ty_96::PTHREAD_INHERIT_SCHED;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_96 =
    _bindgen_ty_96::PTHREAD_EXPLICIT_SCHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_96 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1,
}
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_97 =
    _bindgen_ty_97::PTHREAD_SCOPE_SYSTEM;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_97 =
    _bindgen_ty_97::PTHREAD_SCOPE_PROCESS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_97 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1,
}
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_98 =
    _bindgen_ty_98::PTHREAD_PROCESS_PRIVATE;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_98 =
    _bindgen_ty_98::PTHREAD_PROCESS_SHARED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_98 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut libc::c_void)>,
    pub __arg: *mut libc::c_void,
    pub __canceltype: libc::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(::std::mem::size_of::<_pthread_cleanup_buffer>() , 32usize);
    assert_eq!(::std::mem::align_of::<_pthread_cleanup_buffer>() , 8usize);
}
impl Clone for _pthread_cleanup_buffer {
    fn clone(&self) -> Self { *self }
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_99 =
    _bindgen_ty_99::PTHREAD_CANCEL_ENABLE;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_99 =
    _bindgen_ty_99::PTHREAD_CANCEL_DISABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_99 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1,
}
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_100 =
    _bindgen_ty_100::PTHREAD_CANCEL_DEFERRED;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_100 =
    _bindgen_ty_100::PTHREAD_CANCEL_ASYNCHRONOUS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_100 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1,
}
extern "C" {
    pub fn pthread_create(__newthread: *mut pthread_t,
                          __attr: *const pthread_attr_t,
                          __start_routine:
                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut libc::c_void)
                                                        -> *mut libc::c_void>,
                          __arg: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut libc::c_void);
}
extern "C" {
    pub fn pthread_join(__th: pthread_t,
                        __thread_return: *mut *mut libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(__attr: *const pthread_attr_t,
                                       __detachstate: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(__attr: *mut pthread_attr_t,
                                       __detachstate: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(__attr: *const pthread_attr_t,
                                     __guardsize: *mut usize) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(__attr: *mut pthread_attr_t,
                                     __guardsize: usize) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(__attr: *const pthread_attr_t,
                                      __param: *mut sched_param)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(__attr: *mut pthread_attr_t,
                                      __param: *const sched_param)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(__attr: *const pthread_attr_t,
                                       __policy: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(__attr: *mut pthread_attr_t,
                                       __policy: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(__attr: *const pthread_attr_t,
                                        __inherit: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(__attr: *mut pthread_attr_t,
                                        __inherit: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(__attr: *const pthread_attr_t,
                                 __scope: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(__attr: *mut pthread_attr_t,
                                 __scope: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(__attr: *const pthread_attr_t,
                                     __stackaddr: *mut *mut libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(__attr: *mut pthread_attr_t,
                                     __stackaddr: *mut libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(__attr: *const pthread_attr_t,
                                     __stacksize: *mut usize) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(__attr: *mut pthread_attr_t,
                                     __stacksize: usize) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(__attr: *const pthread_attr_t,
                                 __stackaddr: *mut *mut libc::c_void,
                                 __stacksize: *mut usize) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(__attr: *mut pthread_attr_t,
                                 __stackaddr: *mut libc::c_void,
                                 __stacksize: usize) -> libc::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(__target_thread: pthread_t,
                                 __policy: libc::c_int,
                                 __param: *const sched_param) -> libc::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(__target_thread: pthread_t,
                                 __policy: *mut libc::c_int,
                                 __param: *mut sched_param) -> libc::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(__target_thread: pthread_t,
                                __prio: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_once(__once_control: *mut pthread_once_t,
                        __init_routine:
                            ::std::option::Option<unsafe extern "C" fn()>)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(__state: libc::c_int,
                                  __oldstate: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(__type: libc::c_int,
                                 __oldtype: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_101 {
    pub __cancel_jmp_buf: [_bindgen_ty_101__bindgen_ty_1; 1usize],
    pub __pad: [*mut libc::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_101__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_101__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_101__bindgen_ty_1>() ,
               72usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_101__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _bindgen_ty_101__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_101() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_101>() , 104usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_101>() , 8usize);
}
impl Clone for _bindgen_ty_101 {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_unwind_buf_t = _bindgen_ty_101;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut libc::c_void)>,
    pub __cancel_arg: *mut libc::c_void,
    pub __do_it: libc::c_int,
    pub __cancel_type: libc::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(::std::mem::size_of::<__pthread_cleanup_frame>() , 24usize);
    assert_eq!(::std::mem::align_of::<__pthread_cleanup_frame>() , 8usize);
}
impl Clone for __pthread_cleanup_frame {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag([u8; 0]);
extern "C" {
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag, __savemask: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(__mutex: *mut pthread_mutex_t,
                              __mutexattr: *const pthread_mutexattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(__mutex: *mut pthread_mutex_t,
                                   __abstime: *const timespec) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(__mutex: *const pthread_mutex_t,
                                        __prioceiling: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(__mutex: *mut pthread_mutex_t,
                                        __prioceiling: libc::c_int,
                                        __old_ceiling: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(__attr: *const pthread_mutexattr_t,
                                        __pshared: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(__attr: *mut pthread_mutexattr_t,
                                        __pshared: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(__attr: *const pthread_mutexattr_t,
                                     __kind: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(__attr: *mut pthread_mutexattr_t,
                                     __kind: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(__attr: *const pthread_mutexattr_t,
                                         __protocol: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(__attr: *mut pthread_mutexattr_t,
                                         __protocol: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(__attr:
                                                *const pthread_mutexattr_t,
                                            __prioceiling: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(__attr: *mut pthread_mutexattr_t,
                                            __prioceiling: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(__attr: *const pthread_mutexattr_t,
                                       __robustness: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(__attr: *mut pthread_mutexattr_t,
                                       __robustness: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(__rwlock: *mut pthread_rwlock_t,
                               __attr: *const pthread_rwlockattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(__rwlock: *mut pthread_rwlock_t,
                                      __abstime: *const timespec)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(__rwlock: *mut pthread_rwlock_t,
                                      __abstime: *const timespec)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(__attr: *const pthread_rwlockattr_t,
                                         __pshared: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(__attr: *mut pthread_rwlockattr_t,
                                         __pshared: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(__attr: *const pthread_rwlockattr_t,
                                         __pref: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(__attr: *mut pthread_rwlockattr_t,
                                         __pref: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_init(__cond: *mut pthread_cond_t,
                             __cond_attr: *const pthread_condattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(__cond: *mut pthread_cond_t,
                             __mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(__cond: *mut pthread_cond_t,
                                  __mutex: *mut pthread_mutex_t,
                                  __abstime: *const timespec) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(__attr: *const pthread_condattr_t,
                                       __pshared: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(__attr: *mut pthread_condattr_t,
                                       __pshared: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(__attr: *const pthread_condattr_t,
                                     __clock_id: *mut __clockid_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(__attr: *mut pthread_condattr_t,
                                     __clock_id: __clockid_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_init(__lock: *mut pthread_spinlock_t,
                             __pshared: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(__barrier: *mut pthread_barrier_t,
                                __attr: *const pthread_barrierattr_t,
                                __count: libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(__attr:
                                              *const pthread_barrierattr_t,
                                          __pshared: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(__attr: *mut pthread_barrierattr_t,
                                          __pshared: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_key_create(__key: *mut pthread_key_t,
                              __destr_function:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *mut libc::c_void)>)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn pthread_setspecific(__key: pthread_key_t,
                               __pointer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(__thread_id: pthread_t,
                                 __clock_id: *mut __clockid_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_atfork(__prepare:
                              ::std::option::Option<unsafe extern "C" fn()>,
                          __parent:
                              ::std::option::Option<unsafe extern "C" fn()>,
                          __child:
                              ::std::option::Option<unsafe extern "C" fn()>)
     -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_connection_t([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_102 {
    pub data: *mut libc::c_void,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_102() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_102>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_102>() , 8usize);
}
impl Clone for _bindgen_ty_102 {
    fn clone(&self) -> Self { *self }
}
pub type xcb_generic_iterator_t = _bindgen_ty_102;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_103 {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_103() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_103>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_103>() , 4usize);
}
impl Clone for _bindgen_ty_103 {
    fn clone(&self) -> Self { *self }
}
pub type xcb_generic_reply_t = _bindgen_ty_103;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_104 {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub pad: [u32; 7usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_104() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_104>() , 36usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_104>() , 4usize);
}
impl Clone for _bindgen_ty_104 {
    fn clone(&self) -> Self { *self }
}
pub type xcb_generic_event_t = _bindgen_ty_104;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_105 {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub event_type: u16,
    pub pad1: u16,
    pub pad: [u32; 5usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_105() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_105>() , 36usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_105>() , 4usize);
}
impl Clone for _bindgen_ty_105 {
    fn clone(&self) -> Self { *self }
}
pub type xcb_ge_event_t = _bindgen_ty_105;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_106 {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub resource_id: u32,
    pub minor_code: u16,
    pub major_code: u8,
    pub pad0: u8,
    pub pad: [u32; 5usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_106() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_106>() , 36usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_106>() , 4usize);
}
impl Clone for _bindgen_ty_106 {
    fn clone(&self) -> Self { *self }
}
pub type xcb_generic_error_t = _bindgen_ty_106;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_107 {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout__bindgen_ty_107() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_107>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_107>() , 4usize);
}
impl Clone for _bindgen_ty_107 {
    fn clone(&self) -> Self { *self }
}
pub type xcb_void_cookie_t = _bindgen_ty_107;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_char2b_t {
    pub byte1: u8,
    pub byte2: u8,
}
#[test]
fn bindgen_test_layout_xcb_char2b_t() {
    assert_eq!(::std::mem::size_of::<xcb_char2b_t>() , 2usize);
    assert_eq!(::std::mem::align_of::<xcb_char2b_t>() , 1usize);
}
impl Clone for xcb_char2b_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_char2b_iterator_t {
    pub data: *mut xcb_char2b_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_char2b_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_char2b_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_char2b_iterator_t>() , 8usize);
}
impl Clone for xcb_char2b_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_window_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_window_iterator_t {
    pub data: *mut xcb_window_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_window_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_window_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_window_iterator_t>() , 8usize);
}
impl Clone for xcb_window_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_pixmap_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_pixmap_iterator_t {
    pub data: *mut xcb_pixmap_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_pixmap_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_pixmap_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_pixmap_iterator_t>() , 8usize);
}
impl Clone for xcb_pixmap_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_cursor_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_cursor_iterator_t {
    pub data: *mut xcb_cursor_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_cursor_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_cursor_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_cursor_iterator_t>() , 8usize);
}
impl Clone for xcb_cursor_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_font_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_font_iterator_t {
    pub data: *mut xcb_font_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_font_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_font_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_font_iterator_t>() , 8usize);
}
impl Clone for xcb_font_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_gcontext_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_gcontext_iterator_t {
    pub data: *mut xcb_gcontext_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_gcontext_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_gcontext_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_gcontext_iterator_t>() , 8usize);
}
impl Clone for xcb_gcontext_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_colormap_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_colormap_iterator_t {
    pub data: *mut xcb_colormap_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_colormap_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_colormap_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_colormap_iterator_t>() , 8usize);
}
impl Clone for xcb_colormap_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_atom_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_atom_iterator_t {
    pub data: *mut xcb_atom_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_atom_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_atom_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_atom_iterator_t>() , 8usize);
}
impl Clone for xcb_atom_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_drawable_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_drawable_iterator_t {
    pub data: *mut xcb_drawable_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_drawable_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_drawable_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_drawable_iterator_t>() , 8usize);
}
impl Clone for xcb_drawable_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_fontable_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_fontable_iterator_t {
    pub data: *mut xcb_fontable_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_fontable_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_fontable_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_fontable_iterator_t>() , 8usize);
}
impl Clone for xcb_fontable_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_bool32_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_bool32_iterator_t {
    pub data: *mut xcb_bool32_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_bool32_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_bool32_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_bool32_iterator_t>() , 8usize);
}
impl Clone for xcb_bool32_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_visualid_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_visualid_iterator_t {
    pub data: *mut xcb_visualid_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_visualid_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_visualid_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_visualid_iterator_t>() , 8usize);
}
impl Clone for xcb_visualid_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_timestamp_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_timestamp_iterator_t {
    pub data: *mut xcb_timestamp_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_timestamp_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_timestamp_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_timestamp_iterator_t>() , 8usize);
}
impl Clone for xcb_timestamp_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_keysym_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_keysym_iterator_t {
    pub data: *mut xcb_keysym_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keysym_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_keysym_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_keysym_iterator_t>() , 8usize);
}
impl Clone for xcb_keysym_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_keycode_t = u8;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_keycode_iterator_t {
    pub data: *mut xcb_keycode_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keycode_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_keycode_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_keycode_iterator_t>() , 8usize);
}
impl Clone for xcb_keycode_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_keycode32_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_keycode32_iterator_t {
    pub data: *mut xcb_keycode32_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keycode32_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_keycode32_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_keycode32_iterator_t>() , 8usize);
}
impl Clone for xcb_keycode32_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_button_t = u8;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_button_iterator_t {
    pub data: *mut xcb_button_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_button_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_button_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_button_iterator_t>() , 8usize);
}
impl Clone for xcb_button_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_point_t {
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_point_t() {
    assert_eq!(::std::mem::size_of::<xcb_point_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_point_t>() , 2usize);
}
impl Clone for xcb_point_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_point_iterator_t {
    pub data: *mut xcb_point_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_point_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_point_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_point_iterator_t>() , 8usize);
}
impl Clone for xcb_point_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_rectangle_t {
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_rectangle_t() {
    assert_eq!(::std::mem::size_of::<xcb_rectangle_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_rectangle_t>() , 2usize);
}
impl Clone for xcb_rectangle_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_rectangle_iterator_t {
    pub data: *mut xcb_rectangle_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_rectangle_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_rectangle_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_rectangle_iterator_t>() , 8usize);
}
impl Clone for xcb_rectangle_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_arc_t {
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub angle1: i16,
    pub angle2: i16,
}
#[test]
fn bindgen_test_layout_xcb_arc_t() {
    assert_eq!(::std::mem::size_of::<xcb_arc_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_arc_t>() , 2usize);
}
impl Clone for xcb_arc_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_arc_iterator_t {
    pub data: *mut xcb_arc_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_arc_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_arc_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_arc_iterator_t>() , 8usize);
}
impl Clone for xcb_arc_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_format_t {
    pub depth: u8,
    pub bits_per_pixel: u8,
    pub scanline_pad: u8,
    pub pad0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_xcb_format_t() {
    assert_eq!(::std::mem::size_of::<xcb_format_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_format_t>() , 1usize);
}
impl Clone for xcb_format_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_format_iterator_t {
    pub data: *mut xcb_format_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_format_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_format_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_format_iterator_t>() , 8usize);
}
impl Clone for xcb_format_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_visual_class_t {
    XCB_VISUAL_CLASS_STATIC_GRAY = 0,
    XCB_VISUAL_CLASS_GRAY_SCALE = 1,
    XCB_VISUAL_CLASS_STATIC_COLOR = 2,
    XCB_VISUAL_CLASS_PSEUDO_COLOR = 3,
    XCB_VISUAL_CLASS_TRUE_COLOR = 4,
    XCB_VISUAL_CLASS_DIRECT_COLOR = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_visualtype_t {
    pub visual_id: xcb_visualid_t,
    pub _class: u8,
    pub bits_per_rgb_value: u8,
    pub colormap_entries: u16,
    pub red_mask: u32,
    pub green_mask: u32,
    pub blue_mask: u32,
    pub pad0: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_visualtype_t() {
    assert_eq!(::std::mem::size_of::<xcb_visualtype_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_visualtype_t>() , 4usize);
}
impl Clone for xcb_visualtype_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_visualtype_iterator_t {
    pub data: *mut xcb_visualtype_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_visualtype_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_visualtype_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_visualtype_iterator_t>() , 8usize);
}
impl Clone for xcb_visualtype_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_depth_t {
    pub depth: u8,
    pub pad0: u8,
    pub visuals_len: u16,
    pub pad1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_depth_t() {
    assert_eq!(::std::mem::size_of::<xcb_depth_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_depth_t>() , 2usize);
}
impl Clone for xcb_depth_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_depth_iterator_t {
    pub data: *mut xcb_depth_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_depth_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_depth_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_depth_iterator_t>() , 8usize);
}
impl Clone for xcb_depth_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_event_mask_t {
    XCB_EVENT_MASK_NO_EVENT = 0,
    XCB_EVENT_MASK_KEY_PRESS = 1,
    XCB_EVENT_MASK_KEY_RELEASE = 2,
    XCB_EVENT_MASK_BUTTON_PRESS = 4,
    XCB_EVENT_MASK_BUTTON_RELEASE = 8,
    XCB_EVENT_MASK_ENTER_WINDOW = 16,
    XCB_EVENT_MASK_LEAVE_WINDOW = 32,
    XCB_EVENT_MASK_POINTER_MOTION = 64,
    XCB_EVENT_MASK_POINTER_MOTION_HINT = 128,
    XCB_EVENT_MASK_BUTTON_1_MOTION = 256,
    XCB_EVENT_MASK_BUTTON_2_MOTION = 512,
    XCB_EVENT_MASK_BUTTON_3_MOTION = 1024,
    XCB_EVENT_MASK_BUTTON_4_MOTION = 2048,
    XCB_EVENT_MASK_BUTTON_5_MOTION = 4096,
    XCB_EVENT_MASK_BUTTON_MOTION = 8192,
    XCB_EVENT_MASK_KEYMAP_STATE = 16384,
    XCB_EVENT_MASK_EXPOSURE = 32768,
    XCB_EVENT_MASK_VISIBILITY_CHANGE = 65536,
    XCB_EVENT_MASK_STRUCTURE_NOTIFY = 131072,
    XCB_EVENT_MASK_RESIZE_REDIRECT = 262144,
    XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY = 524288,
    XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT = 1048576,
    XCB_EVENT_MASK_FOCUS_CHANGE = 2097152,
    XCB_EVENT_MASK_PROPERTY_CHANGE = 4194304,
    XCB_EVENT_MASK_COLOR_MAP_CHANGE = 8388608,
    XCB_EVENT_MASK_OWNER_GRAB_BUTTON = 16777216,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_backing_store_t {
    XCB_BACKING_STORE_NOT_USEFUL = 0,
    XCB_BACKING_STORE_WHEN_MAPPED = 1,
    XCB_BACKING_STORE_ALWAYS = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_screen_t {
    pub root: xcb_window_t,
    pub default_colormap: xcb_colormap_t,
    pub white_pixel: u32,
    pub black_pixel: u32,
    pub current_input_masks: u32,
    pub width_in_pixels: u16,
    pub height_in_pixels: u16,
    pub width_in_millimeters: u16,
    pub height_in_millimeters: u16,
    pub min_installed_maps: u16,
    pub max_installed_maps: u16,
    pub root_visual: xcb_visualid_t,
    pub backing_stores: u8,
    pub save_unders: u8,
    pub root_depth: u8,
    pub allowed_depths_len: u8,
}
#[test]
fn bindgen_test_layout_xcb_screen_t() {
    assert_eq!(::std::mem::size_of::<xcb_screen_t>() , 40usize);
    assert_eq!(::std::mem::align_of::<xcb_screen_t>() , 4usize);
}
impl Clone for xcb_screen_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_screen_iterator_t {
    pub data: *mut xcb_screen_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_screen_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_screen_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_screen_iterator_t>() , 8usize);
}
impl Clone for xcb_screen_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_request_t {
    pub byte_order: u8,
    pub pad0: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub authorization_protocol_name_len: u16,
    pub authorization_protocol_data_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_setup_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_setup_request_t>() , 2usize);
}
impl Clone for xcb_setup_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_request_iterator_t {
    pub data: *mut xcb_setup_request_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_request_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_request_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_setup_request_iterator_t>() ,
               8usize);
}
impl Clone for xcb_setup_request_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_failed_t {
    pub status: u8,
    pub reason_len: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_setup_failed_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_failed_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_setup_failed_t>() , 2usize);
}
impl Clone for xcb_setup_failed_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_failed_iterator_t {
    pub data: *mut xcb_setup_failed_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_failed_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_failed_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_setup_failed_iterator_t>() ,
               8usize);
}
impl Clone for xcb_setup_failed_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_authenticate_t {
    pub status: u8,
    pub pad0: [u8; 5usize],
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_setup_authenticate_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_authenticate_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_setup_authenticate_t>() , 2usize);
}
impl Clone for xcb_setup_authenticate_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_authenticate_iterator_t {
    pub data: *mut xcb_setup_authenticate_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_authenticate_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_authenticate_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_setup_authenticate_iterator_t>() ,
               8usize);
}
impl Clone for xcb_setup_authenticate_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_image_order_t {
    XCB_IMAGE_ORDER_LSB_FIRST = 0,
    XCB_IMAGE_ORDER_MSB_FIRST = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_t {
    pub status: u8,
    pub pad0: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub length: u16,
    pub release_number: u32,
    pub resource_id_base: u32,
    pub resource_id_mask: u32,
    pub motion_buffer_size: u32,
    pub vendor_len: u16,
    pub maximum_request_length: u16,
    pub roots_len: u8,
    pub pixmap_formats_len: u8,
    pub image_byte_order: u8,
    pub bitmap_format_bit_order: u8,
    pub bitmap_format_scanline_unit: u8,
    pub bitmap_format_scanline_pad: u8,
    pub min_keycode: xcb_keycode_t,
    pub max_keycode: xcb_keycode_t,
    pub pad1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_setup_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_t>() , 40usize);
    assert_eq!(::std::mem::align_of::<xcb_setup_t>() , 4usize);
}
impl Clone for xcb_setup_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_iterator_t {
    pub data: *mut xcb_setup_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_setup_iterator_t>() , 8usize);
}
impl Clone for xcb_setup_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_mod_mask_t {
    XCB_MOD_MASK_SHIFT = 1,
    XCB_MOD_MASK_LOCK = 2,
    XCB_MOD_MASK_CONTROL = 4,
    XCB_MOD_MASK_1 = 8,
    XCB_MOD_MASK_2 = 16,
    XCB_MOD_MASK_3 = 32,
    XCB_MOD_MASK_4 = 64,
    XCB_MOD_MASK_5 = 128,
    XCB_MOD_MASK_ANY = 32768,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_key_but_mask_t {
    XCB_KEY_BUT_MASK_SHIFT = 1,
    XCB_KEY_BUT_MASK_LOCK = 2,
    XCB_KEY_BUT_MASK_CONTROL = 4,
    XCB_KEY_BUT_MASK_MOD_1 = 8,
    XCB_KEY_BUT_MASK_MOD_2 = 16,
    XCB_KEY_BUT_MASK_MOD_3 = 32,
    XCB_KEY_BUT_MASK_MOD_4 = 64,
    XCB_KEY_BUT_MASK_MOD_5 = 128,
    XCB_KEY_BUT_MASK_BUTTON_1 = 256,
    XCB_KEY_BUT_MASK_BUTTON_2 = 512,
    XCB_KEY_BUT_MASK_BUTTON_3 = 1024,
    XCB_KEY_BUT_MASK_BUTTON_4 = 2048,
    XCB_KEY_BUT_MASK_BUTTON_5 = 4096,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_window_enum_t { XCB_WINDOW_NONE = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_key_press_event_t {
    pub response_type: u8,
    pub detail: xcb_keycode_t,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_key_press_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_key_press_event_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_key_press_event_t>() , 4usize);
}
impl Clone for xcb_key_press_event_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_key_release_event_t = xcb_key_press_event_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_button_mask_t {
    XCB_BUTTON_MASK_1 = 256,
    XCB_BUTTON_MASK_2 = 512,
    XCB_BUTTON_MASK_3 = 1024,
    XCB_BUTTON_MASK_4 = 2048,
    XCB_BUTTON_MASK_5 = 4096,
    XCB_BUTTON_MASK_ANY = 32768,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_button_press_event_t {
    pub response_type: u8,
    pub detail: xcb_button_t,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_button_press_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_button_press_event_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_button_press_event_t>() , 4usize);
}
impl Clone for xcb_button_press_event_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_button_release_event_t = xcb_button_press_event_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_motion_t { XCB_MOTION_NORMAL = 0, XCB_MOTION_HINT = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_motion_notify_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_motion_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_motion_notify_event_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_motion_notify_event_t>() , 4usize);
}
impl Clone for xcb_motion_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_notify_detail_t {
    XCB_NOTIFY_DETAIL_ANCESTOR = 0,
    XCB_NOTIFY_DETAIL_VIRTUAL = 1,
    XCB_NOTIFY_DETAIL_INFERIOR = 2,
    XCB_NOTIFY_DETAIL_NONLINEAR = 3,
    XCB_NOTIFY_DETAIL_NONLINEAR_VIRTUAL = 4,
    XCB_NOTIFY_DETAIL_POINTER = 5,
    XCB_NOTIFY_DETAIL_POINTER_ROOT = 6,
    XCB_NOTIFY_DETAIL_NONE = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_notify_mode_t {
    XCB_NOTIFY_MODE_NORMAL = 0,
    XCB_NOTIFY_MODE_GRAB = 1,
    XCB_NOTIFY_MODE_UNGRAB = 2,
    XCB_NOTIFY_MODE_WHILE_GRABBED = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_enter_notify_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub mode: u8,
    pub same_screen_focus: u8,
}
#[test]
fn bindgen_test_layout_xcb_enter_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_enter_notify_event_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_enter_notify_event_t>() , 4usize);
}
impl Clone for xcb_enter_notify_event_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_leave_notify_event_t = xcb_enter_notify_event_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_focus_in_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub mode: u8,
    pub pad0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_focus_in_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_focus_in_event_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_focus_in_event_t>() , 4usize);
}
impl Clone for xcb_focus_in_event_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_focus_out_event_t = xcb_focus_in_event_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_keymap_notify_event_t {
    pub response_type: u8,
    pub keys: [u8; 31usize],
}
#[test]
fn bindgen_test_layout_xcb_keymap_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_keymap_notify_event_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_keymap_notify_event_t>() , 1usize);
}
impl Clone for xcb_keymap_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_expose_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
    pub count: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_expose_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_expose_event_t>() , 20usize);
    assert_eq!(::std::mem::align_of::<xcb_expose_event_t>() , 4usize);
}
impl Clone for xcb_expose_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_graphics_exposure_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub drawable: xcb_drawable_t,
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
    pub minor_opcode: u16,
    pub count: u16,
    pub major_opcode: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_graphics_exposure_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_graphics_exposure_event_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<xcb_graphics_exposure_event_t>() ,
               4usize);
}
impl Clone for xcb_graphics_exposure_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_no_exposure_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub drawable: xcb_drawable_t,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_no_exposure_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_no_exposure_event_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_no_exposure_event_t>() , 4usize);
}
impl Clone for xcb_no_exposure_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_visibility_t {
    XCB_VISIBILITY_UNOBSCURED = 0,
    XCB_VISIBILITY_PARTIALLY_OBSCURED = 1,
    XCB_VISIBILITY_FULLY_OBSCURED = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_visibility_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub state: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_visibility_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_visibility_notify_event_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_visibility_notify_event_t>() ,
               4usize);
}
impl Clone for xcb_visibility_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub override_redirect: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_create_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_notify_event_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_create_notify_event_t>() , 4usize);
}
impl Clone for xcb_create_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_destroy_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_destroy_notify_event_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_destroy_notify_event_t>() , 4usize);
}
impl Clone for xcb_destroy_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_unmap_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub from_configure: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_unmap_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_unmap_notify_event_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_unmap_notify_event_t>() , 4usize);
}
impl Clone for xcb_unmap_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_map_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub override_redirect: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_map_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_map_notify_event_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_map_notify_event_t>() , 4usize);
}
impl Clone for xcb_map_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_map_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_request_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_map_request_event_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_map_request_event_t>() , 4usize);
}
impl Clone for xcb_map_request_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_reparent_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub override_redirect: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_reparent_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_reparent_notify_event_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<xcb_reparent_notify_event_t>() ,
               4usize);
}
impl Clone for xcb_reparent_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_configure_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub above_sibling: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub override_redirect: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_configure_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_configure_notify_event_t>() ,
               28usize);
    assert_eq!(::std::mem::align_of::<xcb_configure_notify_event_t>() ,
               4usize);
}
impl Clone for xcb_configure_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_configure_request_event_t {
    pub response_type: u8,
    pub stack_mode: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
    pub sibling: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub value_mask: u16,
}
#[test]
fn bindgen_test_layout_xcb_configure_request_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_configure_request_event_t>() ,
               28usize);
    assert_eq!(::std::mem::align_of::<xcb_configure_request_event_t>() ,
               4usize);
}
impl Clone for xcb_configure_request_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_gravity_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_gravity_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_gravity_notify_event_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_gravity_notify_event_t>() , 4usize);
}
impl Clone for xcb_gravity_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_resize_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_resize_request_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_resize_request_event_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_resize_request_event_t>() , 4usize);
}
impl Clone for xcb_resize_request_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_place_t { XCB_PLACE_ON_TOP = 0, XCB_PLACE_ON_BOTTOM = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_circulate_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub pad1: [u8; 4usize],
    pub place: u8,
    pub pad2: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_circulate_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_circulate_notify_event_t>() ,
               20usize);
    assert_eq!(::std::mem::align_of::<xcb_circulate_notify_event_t>() ,
               4usize);
}
impl Clone for xcb_circulate_notify_event_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_circulate_request_event_t = xcb_circulate_notify_event_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_property_t {
    XCB_PROPERTY_NEW_VALUE = 0,
    XCB_PROPERTY_DELETE = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_property_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub atom: xcb_atom_t,
    pub time: xcb_timestamp_t,
    pub state: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_property_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_property_notify_event_t>() ,
               20usize);
    assert_eq!(::std::mem::align_of::<xcb_property_notify_event_t>() ,
               4usize);
}
impl Clone for xcb_property_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_selection_clear_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub owner: xcb_window_t,
    pub selection: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_clear_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_selection_clear_event_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_selection_clear_event_t>() ,
               4usize);
}
impl Clone for xcb_selection_clear_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_time_t { XCB_TIME_CURRENT_TIME = 0, }
pub const xcb_atom_enum_t_XCB_ATOM_ANY: xcb_atom_enum_t =
    xcb_atom_enum_t::XCB_ATOM_NONE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_atom_enum_t {
    XCB_ATOM_NONE = 0,
    XCB_ATOM_PRIMARY = 1,
    XCB_ATOM_SECONDARY = 2,
    XCB_ATOM_ARC = 3,
    XCB_ATOM_ATOM = 4,
    XCB_ATOM_BITMAP = 5,
    XCB_ATOM_CARDINAL = 6,
    XCB_ATOM_COLORMAP = 7,
    XCB_ATOM_CURSOR = 8,
    XCB_ATOM_CUT_BUFFER0 = 9,
    XCB_ATOM_CUT_BUFFER1 = 10,
    XCB_ATOM_CUT_BUFFER2 = 11,
    XCB_ATOM_CUT_BUFFER3 = 12,
    XCB_ATOM_CUT_BUFFER4 = 13,
    XCB_ATOM_CUT_BUFFER5 = 14,
    XCB_ATOM_CUT_BUFFER6 = 15,
    XCB_ATOM_CUT_BUFFER7 = 16,
    XCB_ATOM_DRAWABLE = 17,
    XCB_ATOM_FONT = 18,
    XCB_ATOM_INTEGER = 19,
    XCB_ATOM_PIXMAP = 20,
    XCB_ATOM_POINT = 21,
    XCB_ATOM_RECTANGLE = 22,
    XCB_ATOM_RESOURCE_MANAGER = 23,
    XCB_ATOM_RGB_COLOR_MAP = 24,
    XCB_ATOM_RGB_BEST_MAP = 25,
    XCB_ATOM_RGB_BLUE_MAP = 26,
    XCB_ATOM_RGB_DEFAULT_MAP = 27,
    XCB_ATOM_RGB_GRAY_MAP = 28,
    XCB_ATOM_RGB_GREEN_MAP = 29,
    XCB_ATOM_RGB_RED_MAP = 30,
    XCB_ATOM_STRING = 31,
    XCB_ATOM_VISUALID = 32,
    XCB_ATOM_WINDOW = 33,
    XCB_ATOM_WM_COMMAND = 34,
    XCB_ATOM_WM_HINTS = 35,
    XCB_ATOM_WM_CLIENT_MACHINE = 36,
    XCB_ATOM_WM_ICON_NAME = 37,
    XCB_ATOM_WM_ICON_SIZE = 38,
    XCB_ATOM_WM_NAME = 39,
    XCB_ATOM_WM_NORMAL_HINTS = 40,
    XCB_ATOM_WM_SIZE_HINTS = 41,
    XCB_ATOM_WM_ZOOM_HINTS = 42,
    XCB_ATOM_MIN_SPACE = 43,
    XCB_ATOM_NORM_SPACE = 44,
    XCB_ATOM_MAX_SPACE = 45,
    XCB_ATOM_END_SPACE = 46,
    XCB_ATOM_SUPERSCRIPT_X = 47,
    XCB_ATOM_SUPERSCRIPT_Y = 48,
    XCB_ATOM_SUBSCRIPT_X = 49,
    XCB_ATOM_SUBSCRIPT_Y = 50,
    XCB_ATOM_UNDERLINE_POSITION = 51,
    XCB_ATOM_UNDERLINE_THICKNESS = 52,
    XCB_ATOM_STRIKEOUT_ASCENT = 53,
    XCB_ATOM_STRIKEOUT_DESCENT = 54,
    XCB_ATOM_ITALIC_ANGLE = 55,
    XCB_ATOM_X_HEIGHT = 56,
    XCB_ATOM_QUAD_WIDTH = 57,
    XCB_ATOM_WEIGHT = 58,
    XCB_ATOM_POINT_SIZE = 59,
    XCB_ATOM_RESOLUTION = 60,
    XCB_ATOM_COPYRIGHT = 61,
    XCB_ATOM_NOTICE = 62,
    XCB_ATOM_FONT_NAME = 63,
    XCB_ATOM_FAMILY_NAME = 64,
    XCB_ATOM_FULL_NAME = 65,
    XCB_ATOM_CAP_HEIGHT = 66,
    XCB_ATOM_WM_CLASS = 67,
    XCB_ATOM_WM_TRANSIENT_FOR = 68,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_selection_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub owner: xcb_window_t,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_request_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_selection_request_event_t>() ,
               28usize);
    assert_eq!(::std::mem::align_of::<xcb_selection_request_event_t>() ,
               4usize);
}
impl Clone for xcb_selection_request_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_selection_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_selection_notify_event_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<xcb_selection_notify_event_t>() ,
               4usize);
}
impl Clone for xcb_selection_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_colormap_state_t {
    XCB_COLORMAP_STATE_UNINSTALLED = 0,
    XCB_COLORMAP_STATE_INSTALLED = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_colormap_enum_t { XCB_COLORMAP_NONE = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_colormap_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub colormap: xcb_colormap_t,
    pub _new: u8,
    pub state: u8,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_colormap_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_colormap_notify_event_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_colormap_notify_event_t>() ,
               4usize);
}
impl Clone for xcb_colormap_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_client_message_data_t {
    pub data8: __BindgenUnionField<[u8; 20usize]>,
    pub data16: __BindgenUnionField<[u16; 10usize]>,
    pub data32: __BindgenUnionField<[u32; 5usize]>,
    pub bindgen_union_field: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_xcb_client_message_data_t() {
    assert_eq!(::std::mem::size_of::<xcb_client_message_data_t>() , 20usize);
    assert_eq!(::std::mem::align_of::<xcb_client_message_data_t>() , 4usize);
}
impl Clone for xcb_client_message_data_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_client_message_data_iterator_t {
    pub data: *mut xcb_client_message_data_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_client_message_data_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_client_message_data_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_client_message_data_iterator_t>() ,
               8usize);
}
impl Clone for xcb_client_message_data_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_client_message_event_t {
    pub response_type: u8,
    pub format: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub type_: xcb_atom_t,
    pub data: xcb_client_message_data_t,
}
#[test]
fn bindgen_test_layout_xcb_client_message_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_client_message_event_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_client_message_event_t>() , 4usize);
}
impl Clone for xcb_client_message_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_mapping_t {
    XCB_MAPPING_MODIFIER = 0,
    XCB_MAPPING_KEYBOARD = 1,
    XCB_MAPPING_POINTER = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_mapping_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub request: u8,
    pub first_keycode: xcb_keycode_t,
    pub count: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_mapping_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_mapping_notify_event_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_mapping_notify_event_t>() , 2usize);
}
impl Clone for xcb_mapping_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ge_generic_event_t {
    pub response_type: u8,
    pub extension: u8,
    pub sequence: u16,
    pub length: u32,
    pub event_type: u16,
    pub pad0: [u8; 22usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_ge_generic_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_ge_generic_event_t>() , 36usize);
    assert_eq!(::std::mem::align_of::<xcb_ge_generic_event_t>() , 4usize);
}
impl Clone for xcb_ge_generic_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_request_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub bad_value: u32,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_request_error_t() {
    assert_eq!(::std::mem::size_of::<xcb_request_error_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_request_error_t>() , 4usize);
}
impl Clone for xcb_request_error_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_value_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub bad_value: u32,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_value_error_t() {
    assert_eq!(::std::mem::size_of::<xcb_value_error_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_value_error_t>() , 4usize);
}
impl Clone for xcb_value_error_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_window_error_t = xcb_value_error_t;
pub type xcb_pixmap_error_t = xcb_value_error_t;
pub type xcb_atom_error_t = xcb_value_error_t;
pub type xcb_cursor_error_t = xcb_value_error_t;
pub type xcb_font_error_t = xcb_value_error_t;
pub type xcb_match_error_t = xcb_request_error_t;
pub type xcb_drawable_error_t = xcb_value_error_t;
pub type xcb_access_error_t = xcb_request_error_t;
pub type xcb_alloc_error_t = xcb_request_error_t;
pub type xcb_colormap_error_t = xcb_value_error_t;
pub type xcb_g_context_error_t = xcb_value_error_t;
pub type xcb_id_choice_error_t = xcb_value_error_t;
pub type xcb_name_error_t = xcb_request_error_t;
pub type xcb_length_error_t = xcb_request_error_t;
pub type xcb_implementation_error_t = xcb_request_error_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_window_class_t {
    XCB_WINDOW_CLASS_COPY_FROM_PARENT = 0,
    XCB_WINDOW_CLASS_INPUT_OUTPUT = 1,
    XCB_WINDOW_CLASS_INPUT_ONLY = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_cw_t {
    XCB_CW_BACK_PIXMAP = 1,
    XCB_CW_BACK_PIXEL = 2,
    XCB_CW_BORDER_PIXMAP = 4,
    XCB_CW_BORDER_PIXEL = 8,
    XCB_CW_BIT_GRAVITY = 16,
    XCB_CW_WIN_GRAVITY = 32,
    XCB_CW_BACKING_STORE = 64,
    XCB_CW_BACKING_PLANES = 128,
    XCB_CW_BACKING_PIXEL = 256,
    XCB_CW_OVERRIDE_REDIRECT = 512,
    XCB_CW_SAVE_UNDER = 1024,
    XCB_CW_EVENT_MASK = 2048,
    XCB_CW_DONT_PROPAGATE = 4096,
    XCB_CW_COLORMAP = 8192,
    XCB_CW_CURSOR = 16384,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_back_pixmap_t {
    XCB_BACK_PIXMAP_NONE = 0,
    XCB_BACK_PIXMAP_PARENT_RELATIVE = 1,
}
pub const xcb_gravity_t_XCB_GRAVITY_WIN_UNMAP: xcb_gravity_t =
    xcb_gravity_t::XCB_GRAVITY_BIT_FORGET;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_gravity_t {
    XCB_GRAVITY_BIT_FORGET = 0,
    XCB_GRAVITY_NORTH_WEST = 1,
    XCB_GRAVITY_NORTH = 2,
    XCB_GRAVITY_NORTH_EAST = 3,
    XCB_GRAVITY_WEST = 4,
    XCB_GRAVITY_CENTER = 5,
    XCB_GRAVITY_EAST = 6,
    XCB_GRAVITY_SOUTH_WEST = 7,
    XCB_GRAVITY_SOUTH = 8,
    XCB_GRAVITY_SOUTH_EAST = 9,
    XCB_GRAVITY_STATIC = 10,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_window_value_list_t {
    pub background_pixmap: xcb_pixmap_t,
    pub background_pixel: u32,
    pub border_pixmap: xcb_pixmap_t,
    pub border_pixel: u32,
    pub bit_gravity: u32,
    pub win_gravity: u32,
    pub backing_store: u32,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub override_redirect: xcb_bool32_t,
    pub save_under: xcb_bool32_t,
    pub event_mask: u32,
    pub do_not_propogate_mask: u32,
    pub colormap: xcb_colormap_t,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_create_window_value_list_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_window_value_list_t>() ,
               60usize);
    assert_eq!(::std::mem::align_of::<xcb_create_window_value_list_t>() ,
               4usize);
}
impl Clone for xcb_create_window_value_list_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_window_request_t {
    pub major_opcode: u8,
    pub depth: u8,
    pub length: u16,
    pub wid: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub _class: u16,
    pub visual: xcb_visualid_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_window_request_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_create_window_request_t>() ,
               4usize);
}
impl Clone for xcb_create_window_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_window_attributes_value_list_t {
    pub background_pixmap: xcb_pixmap_t,
    pub background_pixel: u32,
    pub border_pixmap: xcb_pixmap_t,
    pub border_pixel: u32,
    pub bit_gravity: u32,
    pub win_gravity: u32,
    pub backing_store: u32,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub override_redirect: xcb_bool32_t,
    pub save_under: xcb_bool32_t,
    pub event_mask: u32,
    pub do_not_propogate_mask: u32,
    pub colormap: xcb_colormap_t,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_change_window_attributes_value_list_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_window_attributes_value_list_t>()
               , 60usize);
    assert_eq!(::std::mem::align_of::<xcb_change_window_attributes_value_list_t>()
               , 4usize);
}
impl Clone for xcb_change_window_attributes_value_list_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_window_attributes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_window_attributes_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_window_attributes_request_t>()
               , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_change_window_attributes_request_t>()
               , 4usize);
}
impl Clone for xcb_change_window_attributes_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_map_state_t {
    XCB_MAP_STATE_UNMAPPED = 0,
    XCB_MAP_STATE_UNVIEWABLE = 1,
    XCB_MAP_STATE_VIEWABLE = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_window_attributes_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_window_attributes_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_window_attributes_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_window_attributes_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_window_attributes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_window_attributes_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_get_window_attributes_request_t>() ,
               4usize);
}
impl Clone for xcb_get_window_attributes_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_window_attributes_reply_t {
    pub response_type: u8,
    pub backing_store: u8,
    pub sequence: u16,
    pub length: u32,
    pub visual: xcb_visualid_t,
    pub _class: u16,
    pub bit_gravity: u8,
    pub win_gravity: u8,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub save_under: u8,
    pub map_is_installed: u8,
    pub map_state: u8,
    pub override_redirect: u8,
    pub colormap: xcb_colormap_t,
    pub all_event_masks: u32,
    pub your_event_mask: u32,
    pub do_not_propagate_mask: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_window_attributes_reply_t>() ,
               44usize);
    assert_eq!(::std::mem::align_of::<xcb_get_window_attributes_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_window_attributes_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_destroy_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_destroy_window_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_destroy_window_request_t>() ,
               4usize);
}
impl Clone for xcb_destroy_window_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_destroy_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_subwindows_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_destroy_subwindows_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_destroy_subwindows_request_t>() ,
               4usize);
}
impl Clone for xcb_destroy_subwindows_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_set_mode_t { XCB_SET_MODE_INSERT = 0, XCB_SET_MODE_DELETE = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_save_set_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_change_save_set_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_save_set_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_change_save_set_request_t>() ,
               4usize);
}
impl Clone for xcb_change_save_set_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_reparent_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_reparent_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_reparent_window_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_reparent_window_request_t>() ,
               4usize);
}
impl Clone for xcb_reparent_window_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_map_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_map_window_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_map_window_request_t>() , 4usize);
}
impl Clone for xcb_map_window_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_map_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_subwindows_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_map_subwindows_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_map_subwindows_request_t>() ,
               4usize);
}
impl Clone for xcb_map_subwindows_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_unmap_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_unmap_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_unmap_window_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_unmap_window_request_t>() , 4usize);
}
impl Clone for xcb_unmap_window_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_unmap_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_unmap_subwindows_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_unmap_subwindows_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_unmap_subwindows_request_t>() ,
               4usize);
}
impl Clone for xcb_unmap_subwindows_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_config_window_t {
    XCB_CONFIG_WINDOW_X = 1,
    XCB_CONFIG_WINDOW_Y = 2,
    XCB_CONFIG_WINDOW_WIDTH = 4,
    XCB_CONFIG_WINDOW_HEIGHT = 8,
    XCB_CONFIG_WINDOW_BORDER_WIDTH = 16,
    XCB_CONFIG_WINDOW_SIBLING = 32,
    XCB_CONFIG_WINDOW_STACK_MODE = 64,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_stack_mode_t {
    XCB_STACK_MODE_ABOVE = 0,
    XCB_STACK_MODE_BELOW = 1,
    XCB_STACK_MODE_TOP_IF = 2,
    XCB_STACK_MODE_BOTTOM_IF = 3,
    XCB_STACK_MODE_OPPOSITE = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_configure_window_value_list_t {
    pub x: i32,
    pub y: i32,
    pub width: u32,
    pub height: u32,
    pub border_width: u32,
    pub sibling: xcb_window_t,
    pub stack_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_configure_window_value_list_t() {
    assert_eq!(::std::mem::size_of::<xcb_configure_window_value_list_t>() ,
               28usize);
    assert_eq!(::std::mem::align_of::<xcb_configure_window_value_list_t>() ,
               4usize);
}
impl Clone for xcb_configure_window_value_list_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_configure_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub value_mask: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_configure_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_configure_window_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_configure_window_request_t>() ,
               4usize);
}
impl Clone for xcb_configure_window_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_circulate_t {
    XCB_CIRCULATE_RAISE_LOWEST = 0,
    XCB_CIRCULATE_LOWER_HIGHEST = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_circulate_window_request_t {
    pub major_opcode: u8,
    pub direction: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_circulate_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_circulate_window_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_circulate_window_request_t>() ,
               4usize);
}
impl Clone for xcb_circulate_window_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_geometry_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_geometry_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_geometry_cookie_t>() , 4usize);
}
impl Clone for xcb_get_geometry_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_geometry_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_geometry_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_get_geometry_request_t>() , 4usize);
}
impl Clone for xcb_get_geometry_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_geometry_reply_t {
    pub response_type: u8,
    pub depth: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_geometry_reply_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_get_geometry_reply_t>() , 4usize);
}
impl Clone for xcb_get_geometry_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_tree_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_tree_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_tree_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_tree_cookie_t>() , 4usize);
}
impl Clone for xcb_query_tree_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_tree_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_query_tree_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_tree_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_query_tree_request_t>() , 4usize);
}
impl Clone for xcb_query_tree_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_tree_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub parent: xcb_window_t,
    pub children_len: u16,
    pub pad1: [u8; 14usize],
}
#[test]
fn bindgen_test_layout_xcb_query_tree_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_tree_reply_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_query_tree_reply_t>() , 4usize);
}
impl Clone for xcb_query_tree_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_intern_atom_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_intern_atom_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_intern_atom_cookie_t>() , 4usize);
}
impl Clone for xcb_intern_atom_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_intern_atom_request_t {
    pub major_opcode: u8,
    pub only_if_exists: u8,
    pub length: u16,
    pub name_len: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_intern_atom_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_intern_atom_request_t>() , 2usize);
}
impl Clone for xcb_intern_atom_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_intern_atom_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub atom: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_intern_atom_reply_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_intern_atom_reply_t>() , 4usize);
}
impl Clone for xcb_intern_atom_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_atom_name_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_atom_name_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_atom_name_cookie_t>() , 4usize);
}
impl Clone for xcb_get_atom_name_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_atom_name_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub atom: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_atom_name_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_get_atom_name_request_t>() ,
               4usize);
}
impl Clone for xcb_get_atom_name_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_atom_name_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub name_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_atom_name_reply_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_atom_name_reply_t>() , 4usize);
}
impl Clone for xcb_get_atom_name_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_prop_mode_t {
    XCB_PROP_MODE_REPLACE = 0,
    XCB_PROP_MODE_PREPEND = 1,
    XCB_PROP_MODE_APPEND = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_property_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
    pub type_: xcb_atom_t,
    pub format: u8,
    pub pad0: [u8; 3usize],
    pub data_len: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_property_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_property_request_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<xcb_change_property_request_t>() ,
               4usize);
}
impl Clone for xcb_change_property_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_delete_property_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_delete_property_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_delete_property_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_delete_property_request_t>() ,
               4usize);
}
impl Clone for xcb_delete_property_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_get_property_type_t { XCB_GET_PROPERTY_TYPE_ANY = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_property_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_property_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_property_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_property_cookie_t>() , 4usize);
}
impl Clone for xcb_get_property_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_property_request_t {
    pub major_opcode: u8,
    pub _delete: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
    pub type_: xcb_atom_t,
    pub long_offset: u32,
    pub long_length: u32,
}
#[test]
fn bindgen_test_layout_xcb_get_property_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_property_request_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_get_property_request_t>() , 4usize);
}
impl Clone for xcb_get_property_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_property_reply_t {
    pub response_type: u8,
    pub format: u8,
    pub sequence: u16,
    pub length: u32,
    pub type_: xcb_atom_t,
    pub bytes_after: u32,
    pub value_len: u32,
    pub pad0: [u8; 12usize],
}
#[test]
fn bindgen_test_layout_xcb_get_property_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_property_reply_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_property_reply_t>() , 4usize);
}
impl Clone for xcb_get_property_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_properties_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_properties_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_properties_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_list_properties_cookie_t>() ,
               4usize);
}
impl Clone for xcb_list_properties_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_properties_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_list_properties_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_properties_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_list_properties_request_t>() ,
               4usize);
}
impl Clone for xcb_list_properties_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_properties_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub atoms_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_properties_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_properties_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_list_properties_reply_t>() ,
               4usize);
}
impl Clone for xcb_list_properties_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_selection_owner_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub owner: xcb_window_t,
    pub selection: xcb_atom_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_set_selection_owner_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_selection_owner_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_set_selection_owner_request_t>() ,
               4usize);
}
impl Clone for xcb_set_selection_owner_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_selection_owner_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_selection_owner_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_selection_owner_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_selection_owner_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_selection_owner_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub selection: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_selection_owner_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_get_selection_owner_request_t>() ,
               4usize);
}
impl Clone for xcb_get_selection_owner_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_selection_owner_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub owner: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_selection_owner_reply_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_get_selection_owner_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_selection_owner_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_convert_selection_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_convert_selection_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_convert_selection_request_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<xcb_convert_selection_request_t>() ,
               4usize);
}
impl Clone for xcb_convert_selection_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_send_event_dest_t {
    XCB_SEND_EVENT_DEST_POINTER_WINDOW = 0,
    XCB_SEND_EVENT_DEST_ITEM_FOCUS = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_send_event_request_t {
    pub major_opcode: u8,
    pub propagate: u8,
    pub length: u16,
    pub destination: xcb_window_t,
    pub event_mask: u32,
    pub event: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_send_event_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_send_event_request_t>() , 44usize);
    assert_eq!(::std::mem::align_of::<xcb_send_event_request_t>() , 4usize);
}
impl Clone for xcb_send_event_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_grab_mode_t { XCB_GRAB_MODE_SYNC = 0, XCB_GRAB_MODE_ASYNC = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_grab_status_t {
    XCB_GRAB_STATUS_SUCCESS = 0,
    XCB_GRAB_STATUS_ALREADY_GRABBED = 1,
    XCB_GRAB_STATUS_INVALID_TIME = 2,
    XCB_GRAB_STATUS_NOT_VIEWABLE = 3,
    XCB_GRAB_STATUS_FROZEN = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_cursor_enum_t { XCB_CURSOR_NONE = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_pointer_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_pointer_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_pointer_cookie_t>() , 4usize);
}
impl Clone for xcb_grab_pointer_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_pointer_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub event_mask: u16,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub confine_to: xcb_window_t,
    pub cursor: xcb_cursor_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_pointer_request_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_pointer_request_t>() , 4usize);
}
impl Clone for xcb_grab_pointer_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_pointer_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_pointer_reply_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_pointer_reply_t>() , 4usize);
}
impl Clone for xcb_grab_pointer_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ungrab_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_pointer_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_ungrab_pointer_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_ungrab_pointer_request_t>() ,
               4usize);
}
impl Clone for xcb_ungrab_pointer_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_button_index_t {
    XCB_BUTTON_INDEX_ANY = 0,
    XCB_BUTTON_INDEX_1 = 1,
    XCB_BUTTON_INDEX_2 = 2,
    XCB_BUTTON_INDEX_3 = 3,
    XCB_BUTTON_INDEX_4 = 4,
    XCB_BUTTON_INDEX_5 = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_button_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub event_mask: u16,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub confine_to: xcb_window_t,
    pub cursor: xcb_cursor_t,
    pub button: u8,
    pub pad0: u8,
    pub modifiers: u16,
}
#[test]
fn bindgen_test_layout_xcb_grab_button_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_button_request_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_button_request_t>() , 4usize);
}
impl Clone for xcb_grab_button_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ungrab_button_request_t {
    pub major_opcode: u8,
    pub button: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_ungrab_button_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_ungrab_button_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_ungrab_button_request_t>() ,
               4usize);
}
impl Clone for xcb_ungrab_button_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_active_pointer_grab_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
    pub time: xcb_timestamp_t,
    pub event_mask: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_change_active_pointer_grab_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_active_pointer_grab_request_t>()
               , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_change_active_pointer_grab_request_t>()
               , 4usize);
}
impl Clone for xcb_change_active_pointer_grab_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_keyboard_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_keyboard_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_keyboard_cookie_t>() , 4usize);
}
impl Clone for xcb_grab_keyboard_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_keyboard_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub time: xcb_timestamp_t,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_keyboard_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_keyboard_request_t>() ,
               4usize);
}
impl Clone for xcb_grab_keyboard_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_keyboard_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_keyboard_reply_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_keyboard_reply_t>() , 4usize);
}
impl Clone for xcb_grab_keyboard_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ungrab_keyboard_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_keyboard_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_ungrab_keyboard_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_ungrab_keyboard_request_t>() ,
               4usize);
}
impl Clone for xcb_ungrab_keyboard_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_grab_t { XCB_GRAB_ANY = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_key_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub key: xcb_keycode_t,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub pad0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_grab_key_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_key_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_key_request_t>() , 4usize);
}
impl Clone for xcb_grab_key_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ungrab_key_request_t {
    pub major_opcode: u8,
    pub key: xcb_keycode_t,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_ungrab_key_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_ungrab_key_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_ungrab_key_request_t>() , 4usize);
}
impl Clone for xcb_ungrab_key_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_allow_t {
    XCB_ALLOW_ASYNC_POINTER = 0,
    XCB_ALLOW_SYNC_POINTER = 1,
    XCB_ALLOW_REPLAY_POINTER = 2,
    XCB_ALLOW_ASYNC_KEYBOARD = 3,
    XCB_ALLOW_SYNC_KEYBOARD = 4,
    XCB_ALLOW_REPLAY_KEYBOARD = 5,
    XCB_ALLOW_ASYNC_BOTH = 6,
    XCB_ALLOW_SYNC_BOTH = 7,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_allow_events_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_allow_events_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_allow_events_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_allow_events_request_t>() , 4usize);
}
impl Clone for xcb_allow_events_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_server_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_grab_server_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_server_request_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_server_request_t>() , 2usize);
}
impl Clone for xcb_grab_server_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ungrab_server_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_server_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_ungrab_server_request_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_ungrab_server_request_t>() ,
               2usize);
}
impl Clone for xcb_ungrab_server_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_pointer_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_pointer_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_pointer_cookie_t>() , 4usize);
}
impl Clone for xcb_query_pointer_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_pointer_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_query_pointer_request_t>() ,
               4usize);
}
impl Clone for xcb_query_pointer_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_pointer_reply_t {
    pub response_type: u8,
    pub same_screen: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub win_x: i16,
    pub win_y: i16,
    pub mask: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_pointer_reply_t>() , 28usize);
    assert_eq!(::std::mem::align_of::<xcb_query_pointer_reply_t>() , 4usize);
}
impl Clone for xcb_query_pointer_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_timecoord_t {
    pub time: xcb_timestamp_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_timecoord_t() {
    assert_eq!(::std::mem::size_of::<xcb_timecoord_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_timecoord_t>() , 4usize);
}
impl Clone for xcb_timecoord_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_timecoord_iterator_t {
    pub data: *mut xcb_timecoord_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_timecoord_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_timecoord_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_timecoord_iterator_t>() , 8usize);
}
impl Clone for xcb_timecoord_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_motion_events_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_motion_events_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_motion_events_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_motion_events_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_motion_events_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub start: xcb_timestamp_t,
    pub stop: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_motion_events_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_get_motion_events_request_t>() ,
               4usize);
}
impl Clone for xcb_get_motion_events_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_motion_events_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub events_len: u32,
    pub pad1: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_motion_events_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_motion_events_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_motion_events_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_translate_coordinates_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_translate_coordinates_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_translate_coordinates_cookie_t>() ,
               4usize);
}
impl Clone for xcb_translate_coordinates_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_translate_coordinates_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_window: xcb_window_t,
    pub dst_window: xcb_window_t,
    pub src_x: i16,
    pub src_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_translate_coordinates_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_translate_coordinates_request_t>() ,
               4usize);
}
impl Clone for xcb_translate_coordinates_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_translate_coordinates_reply_t {
    pub response_type: u8,
    pub same_screen: u8,
    pub sequence: u16,
    pub length: u32,
    pub child: xcb_window_t,
    pub dst_x: i16,
    pub dst_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_translate_coordinates_reply_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_translate_coordinates_reply_t>() ,
               4usize);
}
impl Clone for xcb_translate_coordinates_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_warp_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_window: xcb_window_t,
    pub dst_window: xcb_window_t,
    pub src_x: i16,
    pub src_y: i16,
    pub src_width: u16,
    pub src_height: u16,
    pub dst_x: i16,
    pub dst_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_warp_pointer_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_warp_pointer_request_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_warp_pointer_request_t>() , 4usize);
}
impl Clone for xcb_warp_pointer_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_input_focus_t {
    XCB_INPUT_FOCUS_NONE = 0,
    XCB_INPUT_FOCUS_POINTER_ROOT = 1,
    XCB_INPUT_FOCUS_PARENT = 2,
    XCB_INPUT_FOCUS_FOLLOW_KEYBOARD = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_input_focus_request_t {
    pub major_opcode: u8,
    pub revert_to: u8,
    pub length: u16,
    pub focus: xcb_window_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_set_input_focus_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_input_focus_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_set_input_focus_request_t>() ,
               4usize);
}
impl Clone for xcb_set_input_focus_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_input_focus_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_input_focus_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_input_focus_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_input_focus_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_input_focus_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_input_focus_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_input_focus_request_t>() ,
               2usize);
}
impl Clone for xcb_get_input_focus_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_input_focus_reply_t {
    pub response_type: u8,
    pub revert_to: u8,
    pub sequence: u16,
    pub length: u32,
    pub focus: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_input_focus_reply_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_get_input_focus_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_input_focus_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_keymap_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_keymap_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_keymap_cookie_t>() , 4usize);
}
impl Clone for xcb_query_keymap_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_keymap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_keymap_request_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_keymap_request_t>() , 2usize);
}
impl Clone for xcb_query_keymap_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_keymap_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub keys: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_keymap_reply_t>() , 40usize);
    assert_eq!(::std::mem::align_of::<xcb_query_keymap_reply_t>() , 4usize);
}
impl Clone for xcb_query_keymap_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_open_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub fid: xcb_font_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_open_font_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_open_font_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_open_font_request_t>() , 4usize);
}
impl Clone for xcb_open_font_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_close_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font: xcb_font_t,
}
#[test]
fn bindgen_test_layout_xcb_close_font_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_close_font_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_close_font_request_t>() , 4usize);
}
impl Clone for xcb_close_font_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_font_draw_t {
    XCB_FONT_DRAW_LEFT_TO_RIGHT = 0,
    XCB_FONT_DRAW_RIGHT_TO_LEFT = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_fontprop_t {
    pub name: xcb_atom_t,
    pub value: u32,
}
#[test]
fn bindgen_test_layout_xcb_fontprop_t() {
    assert_eq!(::std::mem::size_of::<xcb_fontprop_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_fontprop_t>() , 4usize);
}
impl Clone for xcb_fontprop_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_fontprop_iterator_t {
    pub data: *mut xcb_fontprop_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_fontprop_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_fontprop_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_fontprop_iterator_t>() , 8usize);
}
impl Clone for xcb_fontprop_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_charinfo_t {
    pub left_side_bearing: i16,
    pub right_side_bearing: i16,
    pub character_width: i16,
    pub ascent: i16,
    pub descent: i16,
    pub attributes: u16,
}
#[test]
fn bindgen_test_layout_xcb_charinfo_t() {
    assert_eq!(::std::mem::size_of::<xcb_charinfo_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_charinfo_t>() , 2usize);
}
impl Clone for xcb_charinfo_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_charinfo_iterator_t {
    pub data: *mut xcb_charinfo_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_charinfo_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_charinfo_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_charinfo_iterator_t>() , 8usize);
}
impl Clone for xcb_charinfo_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_font_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_font_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_font_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_font_cookie_t>() , 4usize);
}
impl Clone for xcb_query_font_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font: xcb_fontable_t,
}
#[test]
fn bindgen_test_layout_xcb_query_font_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_font_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_query_font_request_t>() , 4usize);
}
impl Clone for xcb_query_font_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_font_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub min_bounds: xcb_charinfo_t,
    pub pad1: [u8; 4usize],
    pub max_bounds: xcb_charinfo_t,
    pub pad2: [u8; 4usize],
    pub min_char_or_byte2: u16,
    pub max_char_or_byte2: u16,
    pub default_char: u16,
    pub properties_len: u16,
    pub draw_direction: u8,
    pub min_byte1: u8,
    pub max_byte1: u8,
    pub all_chars_exist: u8,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub char_infos_len: u32,
}
#[test]
fn bindgen_test_layout_xcb_query_font_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_font_reply_t>() , 60usize);
    assert_eq!(::std::mem::align_of::<xcb_query_font_reply_t>() , 4usize);
}
impl Clone for xcb_query_font_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_text_extents_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_text_extents_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_text_extents_cookie_t>() ,
               4usize);
}
impl Clone for xcb_query_text_extents_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_text_extents_request_t {
    pub major_opcode: u8,
    pub odd_length: u8,
    pub length: u16,
    pub font: xcb_fontable_t,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_text_extents_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_query_text_extents_request_t>() ,
               4usize);
}
impl Clone for xcb_query_text_extents_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_text_extents_reply_t {
    pub response_type: u8,
    pub draw_direction: u8,
    pub sequence: u16,
    pub length: u32,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub overall_ascent: i16,
    pub overall_descent: i16,
    pub overall_width: i32,
    pub overall_left: i32,
    pub overall_right: i32,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_text_extents_reply_t>() ,
               28usize);
    assert_eq!(::std::mem::align_of::<xcb_query_text_extents_reply_t>() ,
               4usize);
}
impl Clone for xcb_query_text_extents_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_str_t {
    pub name_len: u8,
}
#[test]
fn bindgen_test_layout_xcb_str_t() {
    assert_eq!(::std::mem::size_of::<xcb_str_t>() , 1usize);
    assert_eq!(::std::mem::align_of::<xcb_str_t>() , 1usize);
}
impl Clone for xcb_str_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_str_iterator_t {
    pub data: *mut xcb_str_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_str_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_str_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_str_iterator_t>() , 8usize);
}
impl Clone for xcb_str_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_list_fonts_cookie_t>() , 4usize);
}
impl Clone for xcb_list_fonts_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub max_names: u16,
    pub pattern_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_list_fonts_request_t>() , 2usize);
}
impl Clone for xcb_list_fonts_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub names_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_reply_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_list_fonts_reply_t>() , 4usize);
}
impl Clone for xcb_list_fonts_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_with_info_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_with_info_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_list_fonts_with_info_cookie_t>() ,
               4usize);
}
impl Clone for xcb_list_fonts_with_info_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_with_info_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub max_names: u16,
    pub pattern_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_with_info_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_list_fonts_with_info_request_t>() ,
               2usize);
}
impl Clone for xcb_list_fonts_with_info_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_with_info_reply_t {
    pub response_type: u8,
    pub name_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub min_bounds: xcb_charinfo_t,
    pub pad0: [u8; 4usize],
    pub max_bounds: xcb_charinfo_t,
    pub pad1: [u8; 4usize],
    pub min_char_or_byte2: u16,
    pub max_char_or_byte2: u16,
    pub default_char: u16,
    pub properties_len: u16,
    pub draw_direction: u8,
    pub min_byte1: u8,
    pub max_byte1: u8,
    pub all_chars_exist: u8,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub replies_hint: u32,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_with_info_reply_t>() ,
               60usize);
    assert_eq!(::std::mem::align_of::<xcb_list_fonts_with_info_reply_t>() ,
               4usize);
}
impl Clone for xcb_list_fonts_with_info_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_font_path_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font_qty: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_set_font_path_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_font_path_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_set_font_path_request_t>() ,
               2usize);
}
impl Clone for xcb_set_font_path_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_font_path_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_font_path_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_font_path_cookie_t>() , 4usize);
}
impl Clone for xcb_get_font_path_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_font_path_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_font_path_request_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_font_path_request_t>() ,
               2usize);
}
impl Clone for xcb_get_font_path_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_font_path_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub path_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_font_path_reply_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_font_path_reply_t>() , 4usize);
}
impl Clone for xcb_get_font_path_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_pixmap_request_t {
    pub major_opcode: u8,
    pub depth: u8,
    pub length: u16,
    pub pid: xcb_pixmap_t,
    pub drawable: xcb_drawable_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_pixmap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_pixmap_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_create_pixmap_request_t>() ,
               4usize);
}
impl Clone for xcb_create_pixmap_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_free_pixmap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub pixmap: xcb_pixmap_t,
}
#[test]
fn bindgen_test_layout_xcb_free_pixmap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_free_pixmap_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_free_pixmap_request_t>() , 4usize);
}
impl Clone for xcb_free_pixmap_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_gc_t {
    XCB_GC_FUNCTION = 1,
    XCB_GC_PLANE_MASK = 2,
    XCB_GC_FOREGROUND = 4,
    XCB_GC_BACKGROUND = 8,
    XCB_GC_LINE_WIDTH = 16,
    XCB_GC_LINE_STYLE = 32,
    XCB_GC_CAP_STYLE = 64,
    XCB_GC_JOIN_STYLE = 128,
    XCB_GC_FILL_STYLE = 256,
    XCB_GC_FILL_RULE = 512,
    XCB_GC_TILE = 1024,
    XCB_GC_STIPPLE = 2048,
    XCB_GC_TILE_STIPPLE_ORIGIN_X = 4096,
    XCB_GC_TILE_STIPPLE_ORIGIN_Y = 8192,
    XCB_GC_FONT = 16384,
    XCB_GC_SUBWINDOW_MODE = 32768,
    XCB_GC_GRAPHICS_EXPOSURES = 65536,
    XCB_GC_CLIP_ORIGIN_X = 131072,
    XCB_GC_CLIP_ORIGIN_Y = 262144,
    XCB_GC_CLIP_MASK = 524288,
    XCB_GC_DASH_OFFSET = 1048576,
    XCB_GC_DASH_LIST = 2097152,
    XCB_GC_ARC_MODE = 4194304,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_gx_t {
    XCB_GX_CLEAR = 0,
    XCB_GX_AND = 1,
    XCB_GX_AND_REVERSE = 2,
    XCB_GX_COPY = 3,
    XCB_GX_AND_INVERTED = 4,
    XCB_GX_NOOP = 5,
    XCB_GX_XOR = 6,
    XCB_GX_OR = 7,
    XCB_GX_NOR = 8,
    XCB_GX_EQUIV = 9,
    XCB_GX_INVERT = 10,
    XCB_GX_OR_REVERSE = 11,
    XCB_GX_COPY_INVERTED = 12,
    XCB_GX_OR_INVERTED = 13,
    XCB_GX_NAND = 14,
    XCB_GX_SET = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_line_style_t {
    XCB_LINE_STYLE_SOLID = 0,
    XCB_LINE_STYLE_ON_OFF_DASH = 1,
    XCB_LINE_STYLE_DOUBLE_DASH = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_cap_style_t {
    XCB_CAP_STYLE_NOT_LAST = 0,
    XCB_CAP_STYLE_BUTT = 1,
    XCB_CAP_STYLE_ROUND = 2,
    XCB_CAP_STYLE_PROJECTING = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_join_style_t {
    XCB_JOIN_STYLE_MITER = 0,
    XCB_JOIN_STYLE_ROUND = 1,
    XCB_JOIN_STYLE_BEVEL = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_fill_style_t {
    XCB_FILL_STYLE_SOLID = 0,
    XCB_FILL_STYLE_TILED = 1,
    XCB_FILL_STYLE_STIPPLED = 2,
    XCB_FILL_STYLE_OPAQUE_STIPPLED = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_fill_rule_t {
    XCB_FILL_RULE_EVEN_ODD = 0,
    XCB_FILL_RULE_WINDING = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_subwindow_mode_t {
    XCB_SUBWINDOW_MODE_CLIP_BY_CHILDREN = 0,
    XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_arc_mode_t {
    XCB_ARC_MODE_CHORD = 0,
    XCB_ARC_MODE_PIE_SLICE = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_gc_value_list_t {
    pub function: u32,
    pub plane_mask: u32,
    pub foreground: u32,
    pub background: u32,
    pub line_width: u32,
    pub line_style: u32,
    pub cap_style: u32,
    pub join_style: u32,
    pub fill_style: u32,
    pub fill_rule: u32,
    pub tile: xcb_pixmap_t,
    pub stipple: xcb_pixmap_t,
    pub tile_stipple_x_origin: i32,
    pub tile_stipple_y_origin: i32,
    pub font: xcb_font_t,
    pub subwindow_mode: u32,
    pub graphics_exposures: xcb_bool32_t,
    pub clip_x_origin: i32,
    pub clip_y_origin: i32,
    pub clip_mask: xcb_pixmap_t,
    pub dash_offset: u32,
    pub dashes: u32,
    pub arc_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_gc_value_list_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_gc_value_list_t>() , 92usize);
    assert_eq!(::std::mem::align_of::<xcb_create_gc_value_list_t>() , 4usize);
}
impl Clone for xcb_create_gc_value_list_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_gcontext_t,
    pub drawable: xcb_drawable_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_gc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_gc_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_create_gc_request_t>() , 4usize);
}
impl Clone for xcb_create_gc_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_gc_value_list_t {
    pub function: u32,
    pub plane_mask: u32,
    pub foreground: u32,
    pub background: u32,
    pub line_width: u32,
    pub line_style: u32,
    pub cap_style: u32,
    pub join_style: u32,
    pub fill_style: u32,
    pub fill_rule: u32,
    pub tile: xcb_pixmap_t,
    pub stipple: xcb_pixmap_t,
    pub tile_stipple_x_origin: i32,
    pub tile_stipple_y_origin: i32,
    pub font: xcb_font_t,
    pub subwindow_mode: u32,
    pub graphics_exposures: xcb_bool32_t,
    pub clip_x_origin: i32,
    pub clip_y_origin: i32,
    pub clip_mask: xcb_pixmap_t,
    pub dash_offset: u32,
    pub dashes: u32,
    pub arc_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_gc_value_list_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_gc_value_list_t>() , 92usize);
    assert_eq!(::std::mem::align_of::<xcb_change_gc_value_list_t>() , 4usize);
}
impl Clone for xcb_change_gc_value_list_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_gc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_gc_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_change_gc_request_t>() , 4usize);
}
impl Clone for xcb_change_gc_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_copy_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_gc: xcb_gcontext_t,
    pub dst_gc: xcb_gcontext_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_copy_gc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_copy_gc_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_copy_gc_request_t>() , 4usize);
}
impl Clone for xcb_copy_gc_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_dashes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub dash_offset: u16,
    pub dashes_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_dashes_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_dashes_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_set_dashes_request_t>() , 4usize);
}
impl Clone for xcb_set_dashes_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_clip_ordering_t {
    XCB_CLIP_ORDERING_UNSORTED = 0,
    XCB_CLIP_ORDERING_Y_SORTED = 1,
    XCB_CLIP_ORDERING_YX_SORTED = 2,
    XCB_CLIP_ORDERING_YX_BANDED = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_clip_rectangles_request_t {
    pub major_opcode: u8,
    pub ordering: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub clip_x_origin: i16,
    pub clip_y_origin: i16,
}
#[test]
fn bindgen_test_layout_xcb_set_clip_rectangles_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_clip_rectangles_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_set_clip_rectangles_request_t>() ,
               4usize);
}
impl Clone for xcb_set_clip_rectangles_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_free_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_free_gc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_free_gc_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_free_gc_request_t>() , 4usize);
}
impl Clone for xcb_free_gc_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_clear_area_request_t {
    pub major_opcode: u8,
    pub exposures: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_clear_area_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_clear_area_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_clear_area_request_t>() , 4usize);
}
impl Clone for xcb_clear_area_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_copy_area_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_drawable: xcb_drawable_t,
    pub dst_drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub src_x: i16,
    pub src_y: i16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_copy_area_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_copy_area_request_t>() , 28usize);
    assert_eq!(::std::mem::align_of::<xcb_copy_area_request_t>() , 4usize);
}
impl Clone for xcb_copy_area_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_copy_plane_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_drawable: xcb_drawable_t,
    pub dst_drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub src_x: i16,
    pub src_y: i16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub width: u16,
    pub height: u16,
    pub bit_plane: u32,
}
#[test]
fn bindgen_test_layout_xcb_copy_plane_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_copy_plane_request_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_copy_plane_request_t>() , 4usize);
}
impl Clone for xcb_copy_plane_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_coord_mode_t {
    XCB_COORD_MODE_ORIGIN = 0,
    XCB_COORD_MODE_PREVIOUS = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_point_request_t {
    pub major_opcode: u8,
    pub coordinate_mode: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_point_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_point_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_point_request_t>() , 4usize);
}
impl Clone for xcb_poly_point_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_line_request_t {
    pub major_opcode: u8,
    pub coordinate_mode: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_line_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_line_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_line_request_t>() , 4usize);
}
impl Clone for xcb_poly_line_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_segment_t {
    pub x1: i16,
    pub y1: i16,
    pub x2: i16,
    pub y2: i16,
}
#[test]
fn bindgen_test_layout_xcb_segment_t() {
    assert_eq!(::std::mem::size_of::<xcb_segment_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_segment_t>() , 2usize);
}
impl Clone for xcb_segment_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_segment_iterator_t {
    pub data: *mut xcb_segment_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_segment_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_segment_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_segment_iterator_t>() , 8usize);
}
impl Clone for xcb_segment_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_segment_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_segment_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_segment_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_segment_request_t>() , 4usize);
}
impl Clone for xcb_poly_segment_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_rectangle_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_rectangle_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_rectangle_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_rectangle_request_t>() ,
               4usize);
}
impl Clone for xcb_poly_rectangle_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_arc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_arc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_arc_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_arc_request_t>() , 4usize);
}
impl Clone for xcb_poly_arc_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_poly_shape_t {
    XCB_POLY_SHAPE_COMPLEX = 0,
    XCB_POLY_SHAPE_NONCONVEX = 1,
    XCB_POLY_SHAPE_CONVEX = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_fill_poly_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub shape: u8,
    pub coordinate_mode: u8,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_fill_poly_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_fill_poly_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_fill_poly_request_t>() , 4usize);
}
impl Clone for xcb_fill_poly_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_fill_rectangle_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_fill_rectangle_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_fill_rectangle_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_fill_rectangle_request_t>() ,
               4usize);
}
impl Clone for xcb_poly_fill_rectangle_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_fill_arc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_fill_arc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_fill_arc_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_fill_arc_request_t>() ,
               4usize);
}
impl Clone for xcb_poly_fill_arc_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_image_format_t {
    XCB_IMAGE_FORMAT_XY_BITMAP = 0,
    XCB_IMAGE_FORMAT_XY_PIXMAP = 1,
    XCB_IMAGE_FORMAT_Z_PIXMAP = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_put_image_request_t {
    pub major_opcode: u8,
    pub format: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub width: u16,
    pub height: u16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub left_pad: u8,
    pub depth: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_put_image_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_put_image_request_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_put_image_request_t>() , 4usize);
}
impl Clone for xcb_put_image_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_image_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_image_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_image_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_image_cookie_t>() , 4usize);
}
impl Clone for xcb_get_image_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_image_request_t {
    pub major_opcode: u8,
    pub format: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub plane_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_get_image_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_image_request_t>() , 20usize);
    assert_eq!(::std::mem::align_of::<xcb_get_image_request_t>() , 4usize);
}
impl Clone for xcb_get_image_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_image_reply_t {
    pub response_type: u8,
    pub depth: u8,
    pub sequence: u16,
    pub length: u32,
    pub visual: xcb_visualid_t,
    pub pad0: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_get_image_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_image_reply_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_image_reply_t>() , 4usize);
}
impl Clone for xcb_get_image_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_text_8_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_poly_text_8_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_text_8_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_text_8_request_t>() , 4usize);
}
impl Clone for xcb_poly_text_8_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_text_16_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_poly_text_16_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_text_16_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_text_16_request_t>() , 4usize);
}
impl Clone for xcb_poly_text_16_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_image_text_8_request_t {
    pub major_opcode: u8,
    pub string_len: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_image_text_8_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_image_text_8_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_image_text_8_request_t>() , 4usize);
}
impl Clone for xcb_image_text_8_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_image_text_16_request_t {
    pub major_opcode: u8,
    pub string_len: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_image_text_16_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_image_text_16_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_image_text_16_request_t>() ,
               4usize);
}
impl Clone for xcb_image_text_16_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_colormap_alloc_t {
    XCB_COLORMAP_ALLOC_NONE = 0,
    XCB_COLORMAP_ALLOC_ALL = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_colormap_request_t {
    pub major_opcode: u8,
    pub alloc: u8,
    pub length: u16,
    pub mid: xcb_colormap_t,
    pub window: xcb_window_t,
    pub visual: xcb_visualid_t,
}
#[test]
fn bindgen_test_layout_xcb_create_colormap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_colormap_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_create_colormap_request_t>() ,
               4usize);
}
impl Clone for xcb_create_colormap_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_free_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_free_colormap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_free_colormap_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_free_colormap_request_t>() ,
               4usize);
}
impl Clone for xcb_free_colormap_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_copy_colormap_and_free_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub mid: xcb_colormap_t,
    pub src_cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_copy_colormap_and_free_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_copy_colormap_and_free_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_copy_colormap_and_free_request_t>()
               , 4usize);
}
impl Clone for xcb_copy_colormap_and_free_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_install_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_install_colormap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_install_colormap_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_install_colormap_request_t>() ,
               4usize);
}
impl Clone for xcb_install_colormap_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_uninstall_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_uninstall_colormap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_uninstall_colormap_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_uninstall_colormap_request_t>() ,
               4usize);
}
impl Clone for xcb_uninstall_colormap_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_installed_colormaps_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_installed_colormaps_cookie_t>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_list_installed_colormaps_cookie_t>()
               , 4usize);
}
impl Clone for xcb_list_installed_colormaps_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_installed_colormaps_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_installed_colormaps_request_t>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_list_installed_colormaps_request_t>()
               , 4usize);
}
impl Clone for xcb_list_installed_colormaps_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_installed_colormaps_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub cmaps_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_installed_colormaps_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_list_installed_colormaps_reply_t>()
               , 4usize);
}
impl Clone for xcb_list_installed_colormaps_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_cookie_t>() , 4usize);
}
impl Clone for xcb_alloc_color_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_request_t>() , 4usize);
}
impl Clone for xcb_alloc_color_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad1: [u8; 2usize],
    pub pixel: u32,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_reply_t>() , 20usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_reply_t>() , 4usize);
}
impl Clone for xcb_alloc_color_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_named_color_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_named_color_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_named_color_cookie_t>() ,
               4usize);
}
impl Clone for xcb_alloc_named_color_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_named_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_named_color_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_named_color_request_t>() ,
               4usize);
}
impl Clone for xcb_alloc_named_color_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_named_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixel: u32,
    pub exact_red: u16,
    pub exact_green: u16,
    pub exact_blue: u16,
    pub visual_red: u16,
    pub visual_green: u16,
    pub visual_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_named_color_reply_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_named_color_reply_t>() ,
               4usize);
}
impl Clone for xcb_alloc_named_color_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_cells_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_cells_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_cells_cookie_t>() ,
               4usize);
}
impl Clone for xcb_alloc_color_cells_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_cells_request_t {
    pub major_opcode: u8,
    pub contiguous: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub colors: u16,
    pub planes: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_cells_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_cells_request_t>() ,
               4usize);
}
impl Clone for xcb_alloc_color_cells_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_cells_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixels_len: u16,
    pub masks_len: u16,
    pub pad1: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_cells_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_cells_reply_t>() ,
               4usize);
}
impl Clone for xcb_alloc_color_cells_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_planes_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_planes_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_planes_cookie_t>() ,
               4usize);
}
impl Clone for xcb_alloc_color_planes_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_planes_request_t {
    pub major_opcode: u8,
    pub contiguous: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub colors: u16,
    pub reds: u16,
    pub greens: u16,
    pub blues: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_planes_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_planes_request_t>() ,
               4usize);
}
impl Clone for xcb_alloc_color_planes_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_planes_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixels_len: u16,
    pub pad1: [u8; 2usize],
    pub red_mask: u32,
    pub green_mask: u32,
    pub blue_mask: u32,
    pub pad2: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_planes_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_planes_reply_t>() ,
               4usize);
}
impl Clone for xcb_alloc_color_planes_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_free_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub plane_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_free_colors_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_free_colors_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_free_colors_request_t>() , 4usize);
}
impl Clone for xcb_free_colors_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_color_flag_t {
    XCB_COLOR_FLAG_RED = 1,
    XCB_COLOR_FLAG_GREEN = 2,
    XCB_COLOR_FLAG_BLUE = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_coloritem_t {
    pub pixel: u32,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub flags: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_coloritem_t() {
    assert_eq!(::std::mem::size_of::<xcb_coloritem_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_coloritem_t>() , 4usize);
}
impl Clone for xcb_coloritem_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_coloritem_iterator_t {
    pub data: *mut xcb_coloritem_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_coloritem_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_coloritem_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_coloritem_iterator_t>() , 8usize);
}
impl Clone for xcb_coloritem_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_store_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_store_colors_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_store_colors_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_store_colors_request_t>() , 4usize);
}
impl Clone for xcb_store_colors_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_store_named_color_request_t {
    pub major_opcode: u8,
    pub flags: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub pixel: u32,
    pub name_len: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_store_named_color_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_store_named_color_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_store_named_color_request_t>() ,
               4usize);
}
impl Clone for xcb_store_named_color_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_rgb_t {
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_rgb_t() {
    assert_eq!(::std::mem::size_of::<xcb_rgb_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_rgb_t>() , 2usize);
}
impl Clone for xcb_rgb_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_rgb_iterator_t {
    pub data: *mut xcb_rgb_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_rgb_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_rgb_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_rgb_iterator_t>() , 8usize);
}
impl Clone for xcb_rgb_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_colors_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_colors_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_colors_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_colors_cookie_t>() , 4usize);
}
impl Clone for xcb_query_colors_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_query_colors_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_colors_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_query_colors_request_t>() , 4usize);
}
impl Clone for xcb_query_colors_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_colors_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub colors_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_query_colors_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_colors_reply_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_query_colors_reply_t>() , 4usize);
}
impl Clone for xcb_query_colors_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_lookup_color_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_lookup_color_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_lookup_color_cookie_t>() , 4usize);
}
impl Clone for xcb_lookup_color_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_lookup_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_lookup_color_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_lookup_color_request_t>() , 4usize);
}
impl Clone for xcb_lookup_color_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_lookup_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub exact_red: u16,
    pub exact_green: u16,
    pub exact_blue: u16,
    pub visual_red: u16,
    pub visual_green: u16,
    pub visual_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_lookup_color_reply_t>() , 20usize);
    assert_eq!(::std::mem::align_of::<xcb_lookup_color_reply_t>() , 4usize);
}
impl Clone for xcb_lookup_color_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_pixmap_enum_t { XCB_PIXMAP_NONE = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_cursor_t,
    pub source: xcb_pixmap_t,
    pub mask: xcb_pixmap_t,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
    pub x: u16,
    pub y: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_cursor_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_cursor_request_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_create_cursor_request_t>() ,
               4usize);
}
impl Clone for xcb_create_cursor_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_font_enum_t { XCB_FONT_NONE = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_glyph_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_cursor_t,
    pub source_font: xcb_font_t,
    pub mask_font: xcb_font_t,
    pub source_char: u16,
    pub mask_char: u16,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_glyph_cursor_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_glyph_cursor_request_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_create_glyph_cursor_request_t>() ,
               4usize);
}
impl Clone for xcb_create_glyph_cursor_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_free_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_free_cursor_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_free_cursor_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_free_cursor_request_t>() , 4usize);
}
impl Clone for xcb_free_cursor_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_recolor_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_recolor_cursor_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_recolor_cursor_request_t>() ,
               20usize);
    assert_eq!(::std::mem::align_of::<xcb_recolor_cursor_request_t>() ,
               4usize);
}
impl Clone for xcb_recolor_cursor_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_query_shape_of_t {
    XCB_QUERY_SHAPE_OF_LARGEST_CURSOR = 0,
    XCB_QUERY_SHAPE_OF_FASTEST_TILE = 1,
    XCB_QUERY_SHAPE_OF_FASTEST_STIPPLE = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_best_size_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_best_size_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_best_size_cookie_t>() ,
               4usize);
}
impl Clone for xcb_query_best_size_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_best_size_request_t {
    pub major_opcode: u8,
    pub _class: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_best_size_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_query_best_size_request_t>() ,
               4usize);
}
impl Clone for xcb_query_best_size_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_best_size_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_best_size_reply_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_query_best_size_reply_t>() ,
               4usize);
}
impl Clone for xcb_query_best_size_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_extension_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_extension_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_extension_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_extension_cookie_t>() ,
               4usize);
}
impl Clone for xcb_query_extension_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_extension_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_query_extension_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_extension_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_query_extension_request_t>() ,
               2usize);
}
impl Clone for xcb_query_extension_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_extension_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub present: u8,
    pub major_opcode: u8,
    pub first_event: u8,
    pub first_error: u8,
}
#[test]
fn bindgen_test_layout_xcb_query_extension_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_extension_reply_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_query_extension_reply_t>() ,
               4usize);
}
impl Clone for xcb_query_extension_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_extensions_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_extensions_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_list_extensions_cookie_t>() ,
               4usize);
}
impl Clone for xcb_list_extensions_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_extensions_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_extensions_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_list_extensions_request_t>() ,
               2usize);
}
impl Clone for xcb_list_extensions_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_extensions_reply_t {
    pub response_type: u8,
    pub names_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_extensions_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_list_extensions_reply_t>() ,
               4usize);
}
impl Clone for xcb_list_extensions_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_keyboard_mapping_request_t {
    pub major_opcode: u8,
    pub keycode_count: u8,
    pub length: u16,
    pub first_keycode: xcb_keycode_t,
    pub keysyms_per_keycode: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_keyboard_mapping_request_t>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_change_keyboard_mapping_request_t>()
               , 2usize);
}
impl Clone for xcb_change_keyboard_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_mapping_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_mapping_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_keyboard_mapping_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_keyboard_mapping_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub first_keycode: xcb_keycode_t,
    pub count: u8,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_mapping_request_t>() ,
               6usize);
    assert_eq!(::std::mem::align_of::<xcb_get_keyboard_mapping_request_t>() ,
               2usize);
}
impl Clone for xcb_get_keyboard_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_mapping_reply_t {
    pub response_type: u8,
    pub keysyms_per_keycode: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_mapping_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_keyboard_mapping_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_keyboard_mapping_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_kb_t {
    XCB_KB_KEY_CLICK_PERCENT = 1,
    XCB_KB_BELL_PERCENT = 2,
    XCB_KB_BELL_PITCH = 4,
    XCB_KB_BELL_DURATION = 8,
    XCB_KB_LED = 16,
    XCB_KB_LED_MODE = 32,
    XCB_KB_KEY = 64,
    XCB_KB_AUTO_REPEAT_MODE = 128,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_led_mode_t { XCB_LED_MODE_OFF = 0, XCB_LED_MODE_ON = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_auto_repeat_mode_t {
    XCB_AUTO_REPEAT_MODE_OFF = 0,
    XCB_AUTO_REPEAT_MODE_ON = 1,
    XCB_AUTO_REPEAT_MODE_DEFAULT = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_keyboard_control_value_list_t {
    pub key_click_percent: i32,
    pub bell_percent: i32,
    pub bell_pitch: i32,
    pub bell_duration: i32,
    pub led: u32,
    pub led_mode: u32,
    pub key: xcb_keycode32_t,
    pub auto_repeat_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_control_value_list_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_keyboard_control_value_list_t>()
               , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_change_keyboard_control_value_list_t>()
               , 4usize);
}
impl Clone for xcb_change_keyboard_control_value_list_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_keyboard_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_control_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_keyboard_control_request_t>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_change_keyboard_control_request_t>()
               , 4usize);
}
impl Clone for xcb_change_keyboard_control_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_control_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_control_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_keyboard_control_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_keyboard_control_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_control_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_keyboard_control_request_t>() ,
               2usize);
}
impl Clone for xcb_get_keyboard_control_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_control_reply_t {
    pub response_type: u8,
    pub global_auto_repeat: u8,
    pub sequence: u16,
    pub length: u32,
    pub led_mask: u32,
    pub key_click_percent: u8,
    pub bell_percent: u8,
    pub bell_pitch: u16,
    pub bell_duration: u16,
    pub pad0: [u8; 2usize],
    pub auto_repeats: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_control_reply_t>() ,
               52usize);
    assert_eq!(::std::mem::align_of::<xcb_get_keyboard_control_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_keyboard_control_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_bell_request_t {
    pub major_opcode: u8,
    pub percent: i8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_bell_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_bell_request_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_bell_request_t>() , 2usize);
}
impl Clone for xcb_bell_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_pointer_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub acceleration_numerator: i16,
    pub acceleration_denominator: i16,
    pub threshold: i16,
    pub do_acceleration: u8,
    pub do_threshold: u8,
}
#[test]
fn bindgen_test_layout_xcb_change_pointer_control_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_pointer_control_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_change_pointer_control_request_t>()
               , 2usize);
}
impl Clone for xcb_change_pointer_control_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_control_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_control_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_pointer_control_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_pointer_control_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_control_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_pointer_control_request_t>() ,
               2usize);
}
impl Clone for xcb_get_pointer_control_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_control_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub acceleration_numerator: u16,
    pub acceleration_denominator: u16,
    pub threshold: u16,
    pub pad1: [u8; 18usize],
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_control_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_pointer_control_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_pointer_control_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_blanking_t {
    XCB_BLANKING_NOT_PREFERRED = 0,
    XCB_BLANKING_PREFERRED = 1,
    XCB_BLANKING_DEFAULT = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_exposures_t {
    XCB_EXPOSURES_NOT_ALLOWED = 0,
    XCB_EXPOSURES_ALLOWED = 1,
    XCB_EXPOSURES_DEFAULT = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_screen_saver_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub timeout: i16,
    pub interval: i16,
    pub prefer_blanking: u8,
    pub allow_exposures: u8,
}
#[test]
fn bindgen_test_layout_xcb_set_screen_saver_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_screen_saver_request_t>() ,
               10usize);
    assert_eq!(::std::mem::align_of::<xcb_set_screen_saver_request_t>() ,
               2usize);
}
impl Clone for xcb_set_screen_saver_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_screen_saver_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_screen_saver_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_screen_saver_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_screen_saver_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_screen_saver_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_screen_saver_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_screen_saver_request_t>() ,
               2usize);
}
impl Clone for xcb_get_screen_saver_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_screen_saver_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub timeout: u16,
    pub interval: u16,
    pub prefer_blanking: u8,
    pub allow_exposures: u8,
    pub pad1: [u8; 18usize],
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_screen_saver_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_screen_saver_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_screen_saver_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_host_mode_t {
    XCB_HOST_MODE_INSERT = 0,
    XCB_HOST_MODE_DELETE = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_family_t {
    XCB_FAMILY_INTERNET = 0,
    XCB_FAMILY_DECNET = 1,
    XCB_FAMILY_CHAOS = 2,
    XCB_FAMILY_SERVER_INTERPRETED = 5,
    XCB_FAMILY_INTERNET_6 = 6,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_hosts_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub family: u8,
    pub pad0: u8,
    pub address_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_change_hosts_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_hosts_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_change_hosts_request_t>() , 2usize);
}
impl Clone for xcb_change_hosts_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_host_t {
    pub family: u8,
    pub pad0: u8,
    pub address_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_host_t() {
    assert_eq!(::std::mem::size_of::<xcb_host_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_host_t>() , 2usize);
}
impl Clone for xcb_host_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_host_iterator_t {
    pub data: *mut xcb_host_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_host_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_host_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_host_iterator_t>() , 8usize);
}
impl Clone for xcb_host_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_hosts_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_hosts_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_list_hosts_cookie_t>() , 4usize);
}
impl Clone for xcb_list_hosts_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_hosts_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_hosts_request_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_list_hosts_request_t>() , 2usize);
}
impl Clone for xcb_list_hosts_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_hosts_reply_t {
    pub response_type: u8,
    pub mode: u8,
    pub sequence: u16,
    pub length: u32,
    pub hosts_len: u16,
    pub pad0: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_hosts_reply_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_list_hosts_reply_t>() , 4usize);
}
impl Clone for xcb_list_hosts_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_access_control_t {
    XCB_ACCESS_CONTROL_DISABLE = 0,
    XCB_ACCESS_CONTROL_ENABLE = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_access_control_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_access_control_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_access_control_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_set_access_control_request_t>() ,
               2usize);
}
impl Clone for xcb_set_access_control_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_close_down_t {
    XCB_CLOSE_DOWN_DESTROY_ALL = 0,
    XCB_CLOSE_DOWN_RETAIN_PERMANENT = 1,
    XCB_CLOSE_DOWN_RETAIN_TEMPORARY = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_close_down_mode_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_close_down_mode_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_close_down_mode_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_set_close_down_mode_request_t>() ,
               2usize);
}
impl Clone for xcb_set_close_down_mode_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_kill_t { XCB_KILL_ALL_TEMPORARY = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_kill_client_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub resource: u32,
}
#[test]
fn bindgen_test_layout_xcb_kill_client_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_kill_client_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_kill_client_request_t>() , 4usize);
}
impl Clone for xcb_kill_client_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_rotate_properties_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub atoms_len: u16,
    pub delta: i16,
}
#[test]
fn bindgen_test_layout_xcb_rotate_properties_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_rotate_properties_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_rotate_properties_request_t>() ,
               4usize);
}
impl Clone for xcb_rotate_properties_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_screen_saver_t {
    XCB_SCREEN_SAVER_RESET = 0,
    XCB_SCREEN_SAVER_ACTIVE = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_force_screen_saver_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_force_screen_saver_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_force_screen_saver_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_force_screen_saver_request_t>() ,
               2usize);
}
impl Clone for xcb_force_screen_saver_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_mapping_status_t {
    XCB_MAPPING_STATUS_SUCCESS = 0,
    XCB_MAPPING_STATUS_BUSY = 1,
    XCB_MAPPING_STATUS_FAILURE = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_pointer_mapping_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_pointer_mapping_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_set_pointer_mapping_cookie_t>() ,
               4usize);
}
impl Clone for xcb_set_pointer_mapping_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_pointer_mapping_request_t {
    pub major_opcode: u8,
    pub map_len: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_pointer_mapping_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_set_pointer_mapping_request_t>() ,
               2usize);
}
impl Clone for xcb_set_pointer_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_pointer_mapping_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_pointer_mapping_reply_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_set_pointer_mapping_reply_t>() ,
               4usize);
}
impl Clone for xcb_set_pointer_mapping_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_mapping_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_mapping_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_pointer_mapping_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_pointer_mapping_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_mapping_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_pointer_mapping_request_t>() ,
               2usize);
}
impl Clone for xcb_get_pointer_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_mapping_reply_t {
    pub response_type: u8,
    pub map_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_mapping_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_pointer_mapping_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_pointer_mapping_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_map_index_t {
    XCB_MAP_INDEX_SHIFT = 0,
    XCB_MAP_INDEX_LOCK = 1,
    XCB_MAP_INDEX_CONTROL = 2,
    XCB_MAP_INDEX_1 = 3,
    XCB_MAP_INDEX_2 = 4,
    XCB_MAP_INDEX_3 = 5,
    XCB_MAP_INDEX_4 = 6,
    XCB_MAP_INDEX_5 = 7,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_modifier_mapping_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_modifier_mapping_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_set_modifier_mapping_cookie_t>() ,
               4usize);
}
impl Clone for xcb_set_modifier_mapping_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_modifier_mapping_request_t {
    pub major_opcode: u8,
    pub keycodes_per_modifier: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_modifier_mapping_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_set_modifier_mapping_request_t>() ,
               2usize);
}
impl Clone for xcb_set_modifier_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_modifier_mapping_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_modifier_mapping_reply_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_set_modifier_mapping_reply_t>() ,
               4usize);
}
impl Clone for xcb_set_modifier_mapping_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_modifier_mapping_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_modifier_mapping_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_modifier_mapping_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_modifier_mapping_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_modifier_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_modifier_mapping_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_modifier_mapping_request_t>() ,
               2usize);
}
impl Clone for xcb_get_modifier_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_modifier_mapping_reply_t {
    pub response_type: u8,
    pub keycodes_per_modifier: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_modifier_mapping_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_modifier_mapping_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_modifier_mapping_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_no_operation_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_no_operation_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_no_operation_request_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_no_operation_request_t>() , 2usize);
}
impl Clone for xcb_no_operation_request_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn xcb_char2b_next(i: *mut xcb_char2b_iterator_t);
}
extern "C" {
    pub fn xcb_char2b_end(i: xcb_char2b_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_window_next(i: *mut xcb_window_iterator_t);
}
extern "C" {
    pub fn xcb_window_end(i: xcb_window_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_pixmap_next(i: *mut xcb_pixmap_iterator_t);
}
extern "C" {
    pub fn xcb_pixmap_end(i: xcb_pixmap_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_cursor_next(i: *mut xcb_cursor_iterator_t);
}
extern "C" {
    pub fn xcb_cursor_end(i: xcb_cursor_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_font_next(i: *mut xcb_font_iterator_t);
}
extern "C" {
    pub fn xcb_font_end(i: xcb_font_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_gcontext_next(i: *mut xcb_gcontext_iterator_t);
}
extern "C" {
    pub fn xcb_gcontext_end(i: xcb_gcontext_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_colormap_next(i: *mut xcb_colormap_iterator_t);
}
extern "C" {
    pub fn xcb_colormap_end(i: xcb_colormap_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_atom_next(i: *mut xcb_atom_iterator_t);
}
extern "C" {
    pub fn xcb_atom_end(i: xcb_atom_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_drawable_next(i: *mut xcb_drawable_iterator_t);
}
extern "C" {
    pub fn xcb_drawable_end(i: xcb_drawable_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_fontable_next(i: *mut xcb_fontable_iterator_t);
}
extern "C" {
    pub fn xcb_fontable_end(i: xcb_fontable_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_bool32_next(i: *mut xcb_bool32_iterator_t);
}
extern "C" {
    pub fn xcb_bool32_end(i: xcb_bool32_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_visualid_next(i: *mut xcb_visualid_iterator_t);
}
extern "C" {
    pub fn xcb_visualid_end(i: xcb_visualid_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_timestamp_next(i: *mut xcb_timestamp_iterator_t);
}
extern "C" {
    pub fn xcb_timestamp_end(i: xcb_timestamp_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_keysym_next(i: *mut xcb_keysym_iterator_t);
}
extern "C" {
    pub fn xcb_keysym_end(i: xcb_keysym_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_keycode_next(i: *mut xcb_keycode_iterator_t);
}
extern "C" {
    pub fn xcb_keycode_end(i: xcb_keycode_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_keycode32_next(i: *mut xcb_keycode32_iterator_t);
}
extern "C" {
    pub fn xcb_keycode32_end(i: xcb_keycode32_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_button_next(i: *mut xcb_button_iterator_t);
}
extern "C" {
    pub fn xcb_button_end(i: xcb_button_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_point_next(i: *mut xcb_point_iterator_t);
}
extern "C" {
    pub fn xcb_point_end(i: xcb_point_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_rectangle_next(i: *mut xcb_rectangle_iterator_t);
}
extern "C" {
    pub fn xcb_rectangle_end(i: xcb_rectangle_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_arc_next(i: *mut xcb_arc_iterator_t);
}
extern "C" {
    pub fn xcb_arc_end(i: xcb_arc_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_format_next(i: *mut xcb_format_iterator_t);
}
extern "C" {
    pub fn xcb_format_end(i: xcb_format_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_visualtype_next(i: *mut xcb_visualtype_iterator_t);
}
extern "C" {
    pub fn xcb_visualtype_end(i: xcb_visualtype_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_depth_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_depth_visuals(R: *const xcb_depth_t) -> *mut xcb_visualtype_t;
}
extern "C" {
    pub fn xcb_depth_visuals_length(R: *const xcb_depth_t) -> libc::c_int;
}
extern "C" {
    pub fn xcb_depth_visuals_iterator(R: *const xcb_depth_t)
     -> xcb_visualtype_iterator_t;
}
extern "C" {
    pub fn xcb_depth_next(i: *mut xcb_depth_iterator_t);
}
extern "C" {
    pub fn xcb_depth_end(i: xcb_depth_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_screen_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_screen_allowed_depths_length(R: *const xcb_screen_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_screen_allowed_depths_iterator(R: *const xcb_screen_t)
     -> xcb_depth_iterator_t;
}
extern "C" {
    pub fn xcb_screen_next(i: *mut xcb_screen_iterator_t);
}
extern "C" {
    pub fn xcb_screen_end(i: xcb_screen_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name(R:
                                                             *const xcb_setup_request_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name_length(R:
                                                                    *const xcb_setup_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name_end(R:
                                                                 *const xcb_setup_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data(R:
                                                             *const xcb_setup_request_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data_length(R:
                                                                    *const xcb_setup_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data_end(R:
                                                                 *const xcb_setup_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_next(i: *mut xcb_setup_request_iterator_t);
}
extern "C" {
    pub fn xcb_setup_request_end(i: xcb_setup_request_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_failed_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_failed_reason(R: *const xcb_setup_failed_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_setup_failed_reason_length(R: *const xcb_setup_failed_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_failed_reason_end(R: *const xcb_setup_failed_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_failed_next(i: *mut xcb_setup_failed_iterator_t);
}
extern "C" {
    pub fn xcb_setup_failed_end(i: xcb_setup_failed_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_authenticate_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason(R: *const xcb_setup_authenticate_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason_length(R:
                                                    *const xcb_setup_authenticate_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason_end(R:
                                                 *const xcb_setup_authenticate_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_authenticate_next(i:
                                           *mut xcb_setup_authenticate_iterator_t);
}
extern "C" {
    pub fn xcb_setup_authenticate_end(i: xcb_setup_authenticate_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_vendor(R: *const xcb_setup_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_setup_vendor_length(R: *const xcb_setup_t) -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_vendor_end(R: *const xcb_setup_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats(R: *const xcb_setup_t)
     -> *mut xcb_format_t;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats_length(R: *const xcb_setup_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats_iterator(R: *const xcb_setup_t)
     -> xcb_format_iterator_t;
}
extern "C" {
    pub fn xcb_setup_roots_length(R: *const xcb_setup_t) -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_roots_iterator(R: *const xcb_setup_t)
     -> xcb_screen_iterator_t;
}
extern "C" {
    pub fn xcb_setup_next(i: *mut xcb_setup_iterator_t);
}
extern "C" {
    pub fn xcb_setup_end(i: xcb_setup_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_client_message_data_next(i:
                                            *mut xcb_client_message_data_iterator_t);
}
extern "C" {
    pub fn xcb_client_message_data_end(i: xcb_client_message_data_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_create_window_value_list_serialize(_buffer:
                                                      *mut *mut libc::c_void,
                                                  value_mask: u32,
                                                  _aux:
                                                      *const xcb_create_window_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_create_window_value_list_unpack(_buffer: *const libc::c_void,
                                               value_mask: u32,
                                               _aux:
                                                   *mut xcb_create_window_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_create_window_value_list_sizeof(_buffer: *const libc::c_void,
                                               value_mask: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_create_window_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_create_window_checked(c: *mut xcb_connection_t, depth: u8,
                                     wid: xcb_window_t, parent: xcb_window_t,
                                     x: i16, y: i16, width: u16, height: u16,
                                     border_width: u16, _class: u16,
                                     visual: xcb_visualid_t, value_mask: u32,
                                     value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window(c: *mut xcb_connection_t, depth: u8,
                             wid: xcb_window_t, parent: xcb_window_t, x: i16,
                             y: i16, width: u16, height: u16,
                             border_width: u16, _class: u16,
                             visual: xcb_visualid_t, value_mask: u32,
                             value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window_aux_checked(c: *mut xcb_connection_t, depth: u8,
                                         wid: xcb_window_t,
                                         parent: xcb_window_t, x: i16, y: i16,
                                         width: u16, height: u16,
                                         border_width: u16, _class: u16,
                                         visual: xcb_visualid_t,
                                         value_mask: u32,
                                         value_list:
                                             *const xcb_create_window_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window_aux(c: *mut xcb_connection_t, depth: u8,
                                 wid: xcb_window_t, parent: xcb_window_t,
                                 x: i16, y: i16, width: u16, height: u16,
                                 border_width: u16, _class: u16,
                                 visual: xcb_visualid_t, value_mask: u32,
                                 value_list:
                                     *const xcb_create_window_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window_value_list(R: *const xcb_create_window_request_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_serialize(_buffer:
                                                                 *mut *mut libc::c_void,
                                                             value_mask: u32,
                                                             _aux:
                                                                 *const xcb_change_window_attributes_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_unpack(_buffer:
                                                              *const libc::c_void,
                                                          value_mask: u32,
                                                          _aux:
                                                              *mut xcb_change_window_attributes_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_sizeof(_buffer:
                                                              *const libc::c_void,
                                                          value_mask: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_checked(c: *mut xcb_connection_t,
                                                window: xcb_window_t,
                                                value_mask: u32,
                                                value_list:
                                                    *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes(c: *mut xcb_connection_t,
                                        window: xcb_window_t, value_mask: u32,
                                        value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_aux_checked(c: *mut xcb_connection_t,
                                                    window: xcb_window_t,
                                                    value_mask: u32,
                                                    value_list:
                                                        *const xcb_change_window_attributes_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_aux(c: *mut xcb_connection_t,
                                            window: xcb_window_t,
                                            value_mask: u32,
                                            value_list:
                                                *const xcb_change_window_attributes_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list(R:
                                                       *const xcb_change_window_attributes_request_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_get_window_attributes(c: *mut xcb_connection_t,
                                     window: xcb_window_t)
     -> xcb_get_window_attributes_cookie_t;
}
extern "C" {
    pub fn xcb_get_window_attributes_unchecked(c: *mut xcb_connection_t,
                                               window: xcb_window_t)
     -> xcb_get_window_attributes_cookie_t;
}
extern "C" {
    pub fn xcb_get_window_attributes_reply(c: *mut xcb_connection_t,
                                           cookie:
                                               xcb_get_window_attributes_cookie_t,
                                           e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_window_attributes_reply_t;
}
extern "C" {
    pub fn xcb_destroy_window_checked(c: *mut xcb_connection_t,
                                      window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_destroy_window(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_destroy_subwindows_checked(c: *mut xcb_connection_t,
                                          window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_destroy_subwindows(c: *mut xcb_connection_t,
                                  window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_save_set_checked(c: *mut xcb_connection_t, mode: u8,
                                       window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_save_set(c: *mut xcb_connection_t, mode: u8,
                               window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_reparent_window_checked(c: *mut xcb_connection_t,
                                       window: xcb_window_t,
                                       parent: xcb_window_t, x: i16, y: i16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_reparent_window(c: *mut xcb_connection_t, window: xcb_window_t,
                               parent: xcb_window_t, x: i16, y: i16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_window_checked(c: *mut xcb_connection_t,
                                  window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_window(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_subwindows_checked(c: *mut xcb_connection_t,
                                      window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_subwindows(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_window_checked(c: *mut xcb_connection_t,
                                    window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_window(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_subwindows_checked(c: *mut xcb_connection_t,
                                        window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_subwindows(c: *mut xcb_connection_t,
                                window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_value_list_serialize(_buffer:
                                                         *mut *mut libc::c_void,
                                                     value_mask: u16,
                                                     _aux:
                                                         *const xcb_configure_window_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_configure_window_value_list_unpack(_buffer:
                                                      *const libc::c_void,
                                                  value_mask: u16,
                                                  _aux:
                                                      *mut xcb_configure_window_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_configure_window_value_list_sizeof(_buffer:
                                                      *const libc::c_void,
                                                  value_mask: u16)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_configure_window_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_configure_window_checked(c: *mut xcb_connection_t,
                                        window: xcb_window_t, value_mask: u16,
                                        value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window(c: *mut xcb_connection_t,
                                window: xcb_window_t, value_mask: u16,
                                value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_aux_checked(c: *mut xcb_connection_t,
                                            window: xcb_window_t,
                                            value_mask: u16,
                                            value_list:
                                                *const xcb_configure_window_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_aux(c: *mut xcb_connection_t,
                                    window: xcb_window_t, value_mask: u16,
                                    value_list:
                                        *const xcb_configure_window_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_value_list(R:
                                               *const xcb_configure_window_request_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_circulate_window_checked(c: *mut xcb_connection_t,
                                        direction: u8, window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_circulate_window(c: *mut xcb_connection_t, direction: u8,
                                window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_geometry(c: *mut xcb_connection_t,
                            drawable: xcb_drawable_t)
     -> xcb_get_geometry_cookie_t;
}
extern "C" {
    pub fn xcb_get_geometry_unchecked(c: *mut xcb_connection_t,
                                      drawable: xcb_drawable_t)
     -> xcb_get_geometry_cookie_t;
}
extern "C" {
    pub fn xcb_get_geometry_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_get_geometry_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_geometry_reply_t;
}
extern "C" {
    pub fn xcb_query_tree_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_tree(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_query_tree_cookie_t;
}
extern "C" {
    pub fn xcb_query_tree_unchecked(c: *mut xcb_connection_t,
                                    window: xcb_window_t)
     -> xcb_query_tree_cookie_t;
}
extern "C" {
    pub fn xcb_query_tree_children(R: *const xcb_query_tree_reply_t)
     -> *mut xcb_window_t;
}
extern "C" {
    pub fn xcb_query_tree_children_length(R: *const xcb_query_tree_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_tree_children_end(R: *const xcb_query_tree_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_tree_reply(c: *mut xcb_connection_t,
                                cookie: xcb_query_tree_cookie_t,
                                e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_tree_reply_t;
}
extern "C" {
    pub fn xcb_intern_atom_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_intern_atom(c: *mut xcb_connection_t, only_if_exists: u8,
                           name_len: u16, name: *const libc::c_char)
     -> xcb_intern_atom_cookie_t;
}
extern "C" {
    pub fn xcb_intern_atom_unchecked(c: *mut xcb_connection_t,
                                     only_if_exists: u8, name_len: u16,
                                     name: *const libc::c_char)
     -> xcb_intern_atom_cookie_t;
}
extern "C" {
    pub fn xcb_intern_atom_reply(c: *mut xcb_connection_t,
                                 cookie: xcb_intern_atom_cookie_t,
                                 e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_intern_atom_reply_t;
}
extern "C" {
    pub fn xcb_get_atom_name_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_atom_name(c: *mut xcb_connection_t, atom: xcb_atom_t)
     -> xcb_get_atom_name_cookie_t;
}
extern "C" {
    pub fn xcb_get_atom_name_unchecked(c: *mut xcb_connection_t,
                                       atom: xcb_atom_t)
     -> xcb_get_atom_name_cookie_t;
}
extern "C" {
    pub fn xcb_get_atom_name_name(R: *const xcb_get_atom_name_reply_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_get_atom_name_name_length(R: *const xcb_get_atom_name_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_atom_name_name_end(R: *const xcb_get_atom_name_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_atom_name_reply(c: *mut xcb_connection_t,
                                   cookie: xcb_get_atom_name_cookie_t,
                                   e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_atom_name_reply_t;
}
extern "C" {
    pub fn xcb_change_property_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_property_checked(c: *mut xcb_connection_t, mode: u8,
                                       window: xcb_window_t,
                                       property: xcb_atom_t,
                                       type_: xcb_atom_t, format: u8,
                                       data_len: u32,
                                       data: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_property(c: *mut xcb_connection_t, mode: u8,
                               window: xcb_window_t, property: xcb_atom_t,
                               type_: xcb_atom_t, format: u8, data_len: u32,
                               data: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_property_data(R: *const xcb_change_property_request_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_change_property_data_length(R:
                                               *const xcb_change_property_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_property_data_end(R:
                                            *const xcb_change_property_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_delete_property_checked(c: *mut xcb_connection_t,
                                       window: xcb_window_t,
                                       property: xcb_atom_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_delete_property(c: *mut xcb_connection_t, window: xcb_window_t,
                               property: xcb_atom_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_property(c: *mut xcb_connection_t, _delete: u8,
                            window: xcb_window_t, property: xcb_atom_t,
                            type_: xcb_atom_t, long_offset: u32,
                            long_length: u32) -> xcb_get_property_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_unchecked(c: *mut xcb_connection_t, _delete: u8,
                                      window: xcb_window_t,
                                      property: xcb_atom_t, type_: xcb_atom_t,
                                      long_offset: u32, long_length: u32)
     -> xcb_get_property_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_value(R: *const xcb_get_property_reply_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_get_property_value_length(R: *const xcb_get_property_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_property_value_end(R: *const xcb_get_property_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_property_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_get_property_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_property_reply_t;
}
extern "C" {
    pub fn xcb_list_properties_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_properties(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_list_properties_cookie_t;
}
extern "C" {
    pub fn xcb_list_properties_unchecked(c: *mut xcb_connection_t,
                                         window: xcb_window_t)
     -> xcb_list_properties_cookie_t;
}
extern "C" {
    pub fn xcb_list_properties_atoms(R: *const xcb_list_properties_reply_t)
     -> *mut xcb_atom_t;
}
extern "C" {
    pub fn xcb_list_properties_atoms_length(R:
                                                *const xcb_list_properties_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_properties_atoms_end(R:
                                             *const xcb_list_properties_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_properties_reply(c: *mut xcb_connection_t,
                                     cookie: xcb_list_properties_cookie_t,
                                     e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_properties_reply_t;
}
extern "C" {
    pub fn xcb_set_selection_owner_checked(c: *mut xcb_connection_t,
                                           owner: xcb_window_t,
                                           selection: xcb_atom_t,
                                           time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_selection_owner(c: *mut xcb_connection_t,
                                   owner: xcb_window_t, selection: xcb_atom_t,
                                   time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_selection_owner(c: *mut xcb_connection_t,
                                   selection: xcb_atom_t)
     -> xcb_get_selection_owner_cookie_t;
}
extern "C" {
    pub fn xcb_get_selection_owner_unchecked(c: *mut xcb_connection_t,
                                             selection: xcb_atom_t)
     -> xcb_get_selection_owner_cookie_t;
}
extern "C" {
    pub fn xcb_get_selection_owner_reply(c: *mut xcb_connection_t,
                                         cookie:
                                             xcb_get_selection_owner_cookie_t,
                                         e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_selection_owner_reply_t;
}
extern "C" {
    pub fn xcb_convert_selection_checked(c: *mut xcb_connection_t,
                                         requestor: xcb_window_t,
                                         selection: xcb_atom_t,
                                         target: xcb_atom_t,
                                         property: xcb_atom_t,
                                         time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_convert_selection(c: *mut xcb_connection_t,
                                 requestor: xcb_window_t,
                                 selection: xcb_atom_t, target: xcb_atom_t,
                                 property: xcb_atom_t, time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_send_event_checked(c: *mut xcb_connection_t, propagate: u8,
                                  destination: xcb_window_t, event_mask: u32,
                                  event: *const libc::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_send_event(c: *mut xcb_connection_t, propagate: u8,
                          destination: xcb_window_t, event_mask: u32,
                          event: *const libc::c_char) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_pointer(c: *mut xcb_connection_t, owner_events: u8,
                            grab_window: xcb_window_t, event_mask: u16,
                            pointer_mode: u8, keyboard_mode: u8,
                            confine_to: xcb_window_t, cursor: xcb_cursor_t,
                            time: xcb_timestamp_t)
     -> xcb_grab_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_grab_pointer_unchecked(c: *mut xcb_connection_t,
                                      owner_events: u8,
                                      grab_window: xcb_window_t,
                                      event_mask: u16, pointer_mode: u8,
                                      keyboard_mode: u8,
                                      confine_to: xcb_window_t,
                                      cursor: xcb_cursor_t,
                                      time: xcb_timestamp_t)
     -> xcb_grab_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_grab_pointer_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_grab_pointer_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_grab_pointer_reply_t;
}
extern "C" {
    pub fn xcb_ungrab_pointer_checked(c: *mut xcb_connection_t,
                                      time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_pointer(c: *mut xcb_connection_t, time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_button_checked(c: *mut xcb_connection_t, owner_events: u8,
                                   grab_window: xcb_window_t, event_mask: u16,
                                   pointer_mode: u8, keyboard_mode: u8,
                                   confine_to: xcb_window_t,
                                   cursor: xcb_cursor_t, button: u8,
                                   modifiers: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_button(c: *mut xcb_connection_t, owner_events: u8,
                           grab_window: xcb_window_t, event_mask: u16,
                           pointer_mode: u8, keyboard_mode: u8,
                           confine_to: xcb_window_t, cursor: xcb_cursor_t,
                           button: u8, modifiers: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_button_checked(c: *mut xcb_connection_t, button: u8,
                                     grab_window: xcb_window_t,
                                     modifiers: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_button(c: *mut xcb_connection_t, button: u8,
                             grab_window: xcb_window_t, modifiers: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_active_pointer_grab_checked(c: *mut xcb_connection_t,
                                                  cursor: xcb_cursor_t,
                                                  time: xcb_timestamp_t,
                                                  event_mask: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_active_pointer_grab(c: *mut xcb_connection_t,
                                          cursor: xcb_cursor_t,
                                          time: xcb_timestamp_t,
                                          event_mask: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_keyboard(c: *mut xcb_connection_t, owner_events: u8,
                             grab_window: xcb_window_t, time: xcb_timestamp_t,
                             pointer_mode: u8, keyboard_mode: u8)
     -> xcb_grab_keyboard_cookie_t;
}
extern "C" {
    pub fn xcb_grab_keyboard_unchecked(c: *mut xcb_connection_t,
                                       owner_events: u8,
                                       grab_window: xcb_window_t,
                                       time: xcb_timestamp_t,
                                       pointer_mode: u8, keyboard_mode: u8)
     -> xcb_grab_keyboard_cookie_t;
}
extern "C" {
    pub fn xcb_grab_keyboard_reply(c: *mut xcb_connection_t,
                                   cookie: xcb_grab_keyboard_cookie_t,
                                   e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_grab_keyboard_reply_t;
}
extern "C" {
    pub fn xcb_ungrab_keyboard_checked(c: *mut xcb_connection_t,
                                       time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_keyboard(c: *mut xcb_connection_t,
                               time: xcb_timestamp_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_key_checked(c: *mut xcb_connection_t, owner_events: u8,
                                grab_window: xcb_window_t, modifiers: u16,
                                key: xcb_keycode_t, pointer_mode: u8,
                                keyboard_mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_key(c: *mut xcb_connection_t, owner_events: u8,
                        grab_window: xcb_window_t, modifiers: u16,
                        key: xcb_keycode_t, pointer_mode: u8,
                        keyboard_mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_key_checked(c: *mut xcb_connection_t,
                                  key: xcb_keycode_t,
                                  grab_window: xcb_window_t, modifiers: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_key(c: *mut xcb_connection_t, key: xcb_keycode_t,
                          grab_window: xcb_window_t, modifiers: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_allow_events_checked(c: *mut xcb_connection_t, mode: u8,
                                    time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_allow_events(c: *mut xcb_connection_t, mode: u8,
                            time: xcb_timestamp_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_server_checked(c: *mut xcb_connection_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_server(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_server_checked(c: *mut xcb_connection_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_server(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_query_pointer(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_query_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_query_pointer_unchecked(c: *mut xcb_connection_t,
                                       window: xcb_window_t)
     -> xcb_query_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_query_pointer_reply(c: *mut xcb_connection_t,
                                   cookie: xcb_query_pointer_cookie_t,
                                   e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_pointer_reply_t;
}
extern "C" {
    pub fn xcb_timecoord_next(i: *mut xcb_timecoord_iterator_t);
}
extern "C" {
    pub fn xcb_timecoord_end(i: xcb_timecoord_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_motion_events_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_motion_events(c: *mut xcb_connection_t,
                                 window: xcb_window_t, start: xcb_timestamp_t,
                                 stop: xcb_timestamp_t)
     -> xcb_get_motion_events_cookie_t;
}
extern "C" {
    pub fn xcb_get_motion_events_unchecked(c: *mut xcb_connection_t,
                                           window: xcb_window_t,
                                           start: xcb_timestamp_t,
                                           stop: xcb_timestamp_t)
     -> xcb_get_motion_events_cookie_t;
}
extern "C" {
    pub fn xcb_get_motion_events_events(R:
                                            *const xcb_get_motion_events_reply_t)
     -> *mut xcb_timecoord_t;
}
extern "C" {
    pub fn xcb_get_motion_events_events_length(R:
                                                   *const xcb_get_motion_events_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_motion_events_events_iterator(R:
                                                     *const xcb_get_motion_events_reply_t)
     -> xcb_timecoord_iterator_t;
}
extern "C" {
    pub fn xcb_get_motion_events_reply(c: *mut xcb_connection_t,
                                       cookie: xcb_get_motion_events_cookie_t,
                                       e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_motion_events_reply_t;
}
extern "C" {
    pub fn xcb_translate_coordinates(c: *mut xcb_connection_t,
                                     src_window: xcb_window_t,
                                     dst_window: xcb_window_t, src_x: i16,
                                     src_y: i16)
     -> xcb_translate_coordinates_cookie_t;
}
extern "C" {
    pub fn xcb_translate_coordinates_unchecked(c: *mut xcb_connection_t,
                                               src_window: xcb_window_t,
                                               dst_window: xcb_window_t,
                                               src_x: i16, src_y: i16)
     -> xcb_translate_coordinates_cookie_t;
}
extern "C" {
    pub fn xcb_translate_coordinates_reply(c: *mut xcb_connection_t,
                                           cookie:
                                               xcb_translate_coordinates_cookie_t,
                                           e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_translate_coordinates_reply_t;
}
extern "C" {
    pub fn xcb_warp_pointer_checked(c: *mut xcb_connection_t,
                                    src_window: xcb_window_t,
                                    dst_window: xcb_window_t, src_x: i16,
                                    src_y: i16, src_width: u16,
                                    src_height: u16, dst_x: i16, dst_y: i16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_warp_pointer(c: *mut xcb_connection_t,
                            src_window: xcb_window_t,
                            dst_window: xcb_window_t, src_x: i16, src_y: i16,
                            src_width: u16, src_height: u16, dst_x: i16,
                            dst_y: i16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_input_focus_checked(c: *mut xcb_connection_t,
                                       revert_to: u8, focus: xcb_window_t,
                                       time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_input_focus(c: *mut xcb_connection_t, revert_to: u8,
                               focus: xcb_window_t, time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_input_focus(c: *mut xcb_connection_t)
     -> xcb_get_input_focus_cookie_t;
}
extern "C" {
    pub fn xcb_get_input_focus_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_input_focus_cookie_t;
}
extern "C" {
    pub fn xcb_get_input_focus_reply(c: *mut xcb_connection_t,
                                     cookie: xcb_get_input_focus_cookie_t,
                                     e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_input_focus_reply_t;
}
extern "C" {
    pub fn xcb_query_keymap(c: *mut xcb_connection_t)
     -> xcb_query_keymap_cookie_t;
}
extern "C" {
    pub fn xcb_query_keymap_unchecked(c: *mut xcb_connection_t)
     -> xcb_query_keymap_cookie_t;
}
extern "C" {
    pub fn xcb_query_keymap_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_query_keymap_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_keymap_reply_t;
}
extern "C" {
    pub fn xcb_open_font_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_open_font_checked(c: *mut xcb_connection_t, fid: xcb_font_t,
                                 name_len: u16, name: *const libc::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_open_font(c: *mut xcb_connection_t, fid: xcb_font_t,
                         name_len: u16, name: *const libc::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_open_font_name(R: *const xcb_open_font_request_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_open_font_name_length(R: *const xcb_open_font_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_open_font_name_end(R: *const xcb_open_font_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_close_font_checked(c: *mut xcb_connection_t, font: xcb_font_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_close_font(c: *mut xcb_connection_t, font: xcb_font_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fontprop_next(i: *mut xcb_fontprop_iterator_t);
}
extern "C" {
    pub fn xcb_fontprop_end(i: xcb_fontprop_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_charinfo_next(i: *mut xcb_charinfo_iterator_t);
}
extern "C" {
    pub fn xcb_charinfo_end(i: xcb_charinfo_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_font(c: *mut xcb_connection_t, font: xcb_fontable_t)
     -> xcb_query_font_cookie_t;
}
extern "C" {
    pub fn xcb_query_font_unchecked(c: *mut xcb_connection_t,
                                    font: xcb_fontable_t)
     -> xcb_query_font_cookie_t;
}
extern "C" {
    pub fn xcb_query_font_properties(R: *const xcb_query_font_reply_t)
     -> *mut xcb_fontprop_t;
}
extern "C" {
    pub fn xcb_query_font_properties_length(R: *const xcb_query_font_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_font_properties_iterator(R:
                                                  *const xcb_query_font_reply_t)
     -> xcb_fontprop_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_char_infos(R: *const xcb_query_font_reply_t)
     -> *mut xcb_charinfo_t;
}
extern "C" {
    pub fn xcb_query_font_char_infos_length(R: *const xcb_query_font_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_font_char_infos_iterator(R:
                                                  *const xcb_query_font_reply_t)
     -> xcb_charinfo_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_reply(c: *mut xcb_connection_t,
                                cookie: xcb_query_font_cookie_t,
                                e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_font_reply_t;
}
extern "C" {
    pub fn xcb_query_text_extents_sizeof(_buffer: *const libc::c_void,
                                         string_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_text_extents(c: *mut xcb_connection_t,
                                  font: xcb_fontable_t, string_len: u32,
                                  string: *const xcb_char2b_t)
     -> xcb_query_text_extents_cookie_t;
}
extern "C" {
    pub fn xcb_query_text_extents_unchecked(c: *mut xcb_connection_t,
                                            font: xcb_fontable_t,
                                            string_len: u32,
                                            string: *const xcb_char2b_t)
     -> xcb_query_text_extents_cookie_t;
}
extern "C" {
    pub fn xcb_query_text_extents_reply(c: *mut xcb_connection_t,
                                        cookie:
                                            xcb_query_text_extents_cookie_t,
                                        e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_text_extents_reply_t;
}
extern "C" {
    pub fn xcb_str_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_str_name(R: *const xcb_str_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_str_name_length(R: *const xcb_str_t) -> libc::c_int;
}
extern "C" {
    pub fn xcb_str_name_end(R: *const xcb_str_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_str_next(i: *mut xcb_str_iterator_t);
}
extern "C" {
    pub fn xcb_str_end(i: xcb_str_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_fonts(c: *mut xcb_connection_t, max_names: u16,
                          pattern_len: u16, pattern: *const libc::c_char)
     -> xcb_list_fonts_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_unchecked(c: *mut xcb_connection_t, max_names: u16,
                                    pattern_len: u16,
                                    pattern: *const libc::c_char)
     -> xcb_list_fonts_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_names_length(R: *const xcb_list_fonts_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_names_iterator(R: *const xcb_list_fonts_reply_t)
     -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_reply(c: *mut xcb_connection_t,
                                cookie: xcb_list_fonts_cookie_t,
                                e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_fonts_reply_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info(c: *mut xcb_connection_t, max_names: u16,
                                    pattern_len: u16,
                                    pattern: *const libc::c_char)
     -> xcb_list_fonts_with_info_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_unchecked(c: *mut xcb_connection_t,
                                              max_names: u16,
                                              pattern_len: u16,
                                              pattern: *const libc::c_char)
     -> xcb_list_fonts_with_info_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties(R:
                                                   *const xcb_list_fonts_with_info_reply_t)
     -> *mut xcb_fontprop_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties_length(R:
                                                          *const xcb_list_fonts_with_info_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties_iterator(R:
                                                            *const xcb_list_fonts_with_info_reply_t)
     -> xcb_fontprop_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name(R:
                                             *const xcb_list_fonts_with_info_reply_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name_length(R:
                                                    *const xcb_list_fonts_with_info_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name_end(R:
                                                 *const xcb_list_fonts_with_info_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_list_fonts_with_info_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_fonts_with_info_reply_t;
}
extern "C" {
    pub fn xcb_set_font_path_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_set_font_path_checked(c: *mut xcb_connection_t, font_qty: u16,
                                     font: *const xcb_str_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_font_path(c: *mut xcb_connection_t, font_qty: u16,
                             font: *const xcb_str_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_font_path_font_length(R:
                                             *const xcb_set_font_path_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_set_font_path_font_iterator(R:
                                               *const xcb_set_font_path_request_t)
     -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_get_font_path_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_font_path(c: *mut xcb_connection_t)
     -> xcb_get_font_path_cookie_t;
}
extern "C" {
    pub fn xcb_get_font_path_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_font_path_cookie_t;
}
extern "C" {
    pub fn xcb_get_font_path_path_length(R: *const xcb_get_font_path_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_font_path_path_iterator(R:
                                               *const xcb_get_font_path_reply_t)
     -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_get_font_path_reply(c: *mut xcb_connection_t,
                                   cookie: xcb_get_font_path_cookie_t,
                                   e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_font_path_reply_t;
}
extern "C" {
    pub fn xcb_create_pixmap_checked(c: *mut xcb_connection_t, depth: u8,
                                     pid: xcb_pixmap_t,
                                     drawable: xcb_drawable_t, width: u16,
                                     height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_pixmap(c: *mut xcb_connection_t, depth: u8,
                             pid: xcb_pixmap_t, drawable: xcb_drawable_t,
                             width: u16, height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_pixmap_checked(c: *mut xcb_connection_t,
                                   pixmap: xcb_pixmap_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_pixmap(c: *mut xcb_connection_t, pixmap: xcb_pixmap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_value_list_serialize(_buffer: *mut *mut libc::c_void,
                                              value_mask: u32,
                                              _aux:
                                                  *const xcb_create_gc_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_create_gc_value_list_unpack(_buffer: *const libc::c_void,
                                           value_mask: u32,
                                           _aux:
                                               *mut xcb_create_gc_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_create_gc_value_list_sizeof(_buffer: *const libc::c_void,
                                           value_mask: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_create_gc_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_create_gc_checked(c: *mut xcb_connection_t,
                                 cid: xcb_gcontext_t,
                                 drawable: xcb_drawable_t, value_mask: u32,
                                 value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc(c: *mut xcb_connection_t, cid: xcb_gcontext_t,
                         drawable: xcb_drawable_t, value_mask: u32,
                         value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_aux_checked(c: *mut xcb_connection_t,
                                     cid: xcb_gcontext_t,
                                     drawable: xcb_drawable_t,
                                     value_mask: u32,
                                     value_list:
                                         *const xcb_create_gc_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_aux(c: *mut xcb_connection_t, cid: xcb_gcontext_t,
                             drawable: xcb_drawable_t, value_mask: u32,
                             value_list: *const xcb_create_gc_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_value_list(R: *const xcb_create_gc_request_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_change_gc_value_list_serialize(_buffer: *mut *mut libc::c_void,
                                              value_mask: u32,
                                              _aux:
                                                  *const xcb_change_gc_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_gc_value_list_unpack(_buffer: *const libc::c_void,
                                           value_mask: u32,
                                           _aux:
                                               *mut xcb_change_gc_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_gc_value_list_sizeof(_buffer: *const libc::c_void,
                                           value_mask: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_gc_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_gc_checked(c: *mut xcb_connection_t, gc: xcb_gcontext_t,
                                 value_mask: u32,
                                 value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc(c: *mut xcb_connection_t, gc: xcb_gcontext_t,
                         value_mask: u32, value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_aux_checked(c: *mut xcb_connection_t,
                                     gc: xcb_gcontext_t, value_mask: u32,
                                     value_list:
                                         *const xcb_change_gc_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_aux(c: *mut xcb_connection_t, gc: xcb_gcontext_t,
                             value_mask: u32,
                             value_list: *const xcb_change_gc_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_value_list(R: *const xcb_change_gc_request_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_copy_gc_checked(c: *mut xcb_connection_t,
                               src_gc: xcb_gcontext_t, dst_gc: xcb_gcontext_t,
                               value_mask: u32) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_gc(c: *mut xcb_connection_t, src_gc: xcb_gcontext_t,
                       dst_gc: xcb_gcontext_t, value_mask: u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_set_dashes_checked(c: *mut xcb_connection_t,
                                  gc: xcb_gcontext_t, dash_offset: u16,
                                  dashes_len: u16, dashes: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes(c: *mut xcb_connection_t, gc: xcb_gcontext_t,
                          dash_offset: u16, dashes_len: u16,
                          dashes: *const u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes_dashes(R: *const xcb_set_dashes_request_t)
     -> *mut u8;
}
extern "C" {
    pub fn xcb_set_dashes_dashes_length(R: *const xcb_set_dashes_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_set_dashes_dashes_end(R: *const xcb_set_dashes_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_sizeof(_buffer: *const libc::c_void,
                                          rectangles_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_checked(c: *mut xcb_connection_t,
                                           ordering: u8, gc: xcb_gcontext_t,
                                           clip_x_origin: i16,
                                           clip_y_origin: i16,
                                           rectangles_len: u32,
                                           rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles(c: *mut xcb_connection_t, ordering: u8,
                                   gc: xcb_gcontext_t, clip_x_origin: i16,
                                   clip_y_origin: i16, rectangles_len: u32,
                                   rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles(R:
                                                  *const xcb_set_clip_rectangles_request_t)
     -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles_length(R:
                                                         *const xcb_set_clip_rectangles_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles_iterator(R:
                                                           *const xcb_set_clip_rectangles_request_t)
     -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_free_gc_checked(c: *mut xcb_connection_t, gc: xcb_gcontext_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_gc(c: *mut xcb_connection_t, gc: xcb_gcontext_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_clear_area_checked(c: *mut xcb_connection_t, exposures: u8,
                                  window: xcb_window_t, x: i16, y: i16,
                                  width: u16, height: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_clear_area(c: *mut xcb_connection_t, exposures: u8,
                          window: xcb_window_t, x: i16, y: i16, width: u16,
                          height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_area_checked(c: *mut xcb_connection_t,
                                 src_drawable: xcb_drawable_t,
                                 dst_drawable: xcb_drawable_t,
                                 gc: xcb_gcontext_t, src_x: i16, src_y: i16,
                                 dst_x: i16, dst_y: i16, width: u16,
                                 height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_area(c: *mut xcb_connection_t,
                         src_drawable: xcb_drawable_t,
                         dst_drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                         src_x: i16, src_y: i16, dst_x: i16, dst_y: i16,
                         width: u16, height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_plane_checked(c: *mut xcb_connection_t,
                                  src_drawable: xcb_drawable_t,
                                  dst_drawable: xcb_drawable_t,
                                  gc: xcb_gcontext_t, src_x: i16, src_y: i16,
                                  dst_x: i16, dst_y: i16, width: u16,
                                  height: u16, bit_plane: u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_plane(c: *mut xcb_connection_t,
                          src_drawable: xcb_drawable_t,
                          dst_drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                          src_x: i16, src_y: i16, dst_x: i16, dst_y: i16,
                          width: u16, height: u16, bit_plane: u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point_sizeof(_buffer: *const libc::c_void,
                                 points_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_point_checked(c: *mut xcb_connection_t,
                                  coordinate_mode: u8,
                                  drawable: xcb_drawable_t,
                                  gc: xcb_gcontext_t, points_len: u32,
                                  points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point(c: *mut xcb_connection_t, coordinate_mode: u8,
                          drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                          points_len: u32, points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point_points(R: *const xcb_poly_point_request_t)
     -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_poly_point_points_length(R: *const xcb_poly_point_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_point_points_iterator(R: *const xcb_poly_point_request_t)
     -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_poly_line_sizeof(_buffer: *const libc::c_void, points_len: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_line_checked(c: *mut xcb_connection_t,
                                 coordinate_mode: u8,
                                 drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                                 points_len: u32, points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_line(c: *mut xcb_connection_t, coordinate_mode: u8,
                         drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                         points_len: u32, points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_line_points(R: *const xcb_poly_line_request_t)
     -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_poly_line_points_length(R: *const xcb_poly_line_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_line_points_iterator(R: *const xcb_poly_line_request_t)
     -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_segment_next(i: *mut xcb_segment_iterator_t);
}
extern "C" {
    pub fn xcb_segment_end(i: xcb_segment_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_poly_segment_sizeof(_buffer: *const libc::c_void,
                                   segments_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_segment_checked(c: *mut xcb_connection_t,
                                    drawable: xcb_drawable_t,
                                    gc: xcb_gcontext_t, segments_len: u32,
                                    segments: *const xcb_segment_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_segment(c: *mut xcb_connection_t,
                            drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                            segments_len: u32, segments: *const xcb_segment_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_segment_segments(R: *const xcb_poly_segment_request_t)
     -> *mut xcb_segment_t;
}
extern "C" {
    pub fn xcb_poly_segment_segments_length(R:
                                                *const xcb_poly_segment_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_segment_segments_iterator(R:
                                                  *const xcb_poly_segment_request_t)
     -> xcb_segment_iterator_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_sizeof(_buffer: *const libc::c_void,
                                     rectangles_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_rectangle_checked(c: *mut xcb_connection_t,
                                      drawable: xcb_drawable_t,
                                      gc: xcb_gcontext_t, rectangles_len: u32,
                                      rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_rectangle(c: *mut xcb_connection_t,
                              drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                              rectangles_len: u32,
                              rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles(R:
                                             *const xcb_poly_rectangle_request_t)
     -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles_length(R:
                                                    *const xcb_poly_rectangle_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles_iterator(R:
                                                      *const xcb_poly_rectangle_request_t)
     -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_poly_arc_sizeof(_buffer: *const libc::c_void, arcs_len: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_arc_checked(c: *mut xcb_connection_t,
                                drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                                arcs_len: u32, arcs: *const xcb_arc_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_arc(c: *mut xcb_connection_t, drawable: xcb_drawable_t,
                        gc: xcb_gcontext_t, arcs_len: u32,
                        arcs: *const xcb_arc_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_arc_arcs(R: *const xcb_poly_arc_request_t)
     -> *mut xcb_arc_t;
}
extern "C" {
    pub fn xcb_poly_arc_arcs_length(R: *const xcb_poly_arc_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_arc_arcs_iterator(R: *const xcb_poly_arc_request_t)
     -> xcb_arc_iterator_t;
}
extern "C" {
    pub fn xcb_fill_poly_sizeof(_buffer: *const libc::c_void, points_len: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_fill_poly_checked(c: *mut xcb_connection_t,
                                 drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                                 shape: u8, coordinate_mode: u8,
                                 points_len: u32, points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fill_poly(c: *mut xcb_connection_t, drawable: xcb_drawable_t,
                         gc: xcb_gcontext_t, shape: u8, coordinate_mode: u8,
                         points_len: u32, points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fill_poly_points(R: *const xcb_fill_poly_request_t)
     -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_fill_poly_points_length(R: *const xcb_fill_poly_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_fill_poly_points_iterator(R: *const xcb_fill_poly_request_t)
     -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_sizeof(_buffer: *const libc::c_void,
                                          rectangles_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_checked(c: *mut xcb_connection_t,
                                           drawable: xcb_drawable_t,
                                           gc: xcb_gcontext_t,
                                           rectangles_len: u32,
                                           rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle(c: *mut xcb_connection_t,
                                   drawable: xcb_drawable_t,
                                   gc: xcb_gcontext_t, rectangles_len: u32,
                                   rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles(R:
                                                  *const xcb_poly_fill_rectangle_request_t)
     -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles_length(R:
                                                         *const xcb_poly_fill_rectangle_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles_iterator(R:
                                                           *const xcb_poly_fill_rectangle_request_t)
     -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_sizeof(_buffer: *const libc::c_void,
                                    arcs_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_arc_checked(c: *mut xcb_connection_t,
                                     drawable: xcb_drawable_t,
                                     gc: xcb_gcontext_t, arcs_len: u32,
                                     arcs: *const xcb_arc_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc(c: *mut xcb_connection_t,
                             drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                             arcs_len: u32, arcs: *const xcb_arc_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs(R: *const xcb_poly_fill_arc_request_t)
     -> *mut xcb_arc_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs_length(R:
                                             *const xcb_poly_fill_arc_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs_iterator(R:
                                               *const xcb_poly_fill_arc_request_t)
     -> xcb_arc_iterator_t;
}
extern "C" {
    pub fn xcb_put_image_sizeof(_buffer: *const libc::c_void, data_len: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_put_image_checked(c: *mut xcb_connection_t, format: u8,
                                 drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                                 width: u16, height: u16, dst_x: i16,
                                 dst_y: i16, left_pad: u8, depth: u8,
                                 data_len: u32, data: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_put_image(c: *mut xcb_connection_t, format: u8,
                         drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                         width: u16, height: u16, dst_x: i16, dst_y: i16,
                         left_pad: u8, depth: u8, data_len: u32,
                         data: *const u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_put_image_data(R: *const xcb_put_image_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_put_image_data_length(R: *const xcb_put_image_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_put_image_data_end(R: *const xcb_put_image_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_image_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_image(c: *mut xcb_connection_t, format: u8,
                         drawable: xcb_drawable_t, x: i16, y: i16, width: u16,
                         height: u16, plane_mask: u32)
     -> xcb_get_image_cookie_t;
}
extern "C" {
    pub fn xcb_get_image_unchecked(c: *mut xcb_connection_t, format: u8,
                                   drawable: xcb_drawable_t, x: i16, y: i16,
                                   width: u16, height: u16, plane_mask: u32)
     -> xcb_get_image_cookie_t;
}
extern "C" {
    pub fn xcb_get_image_data(R: *const xcb_get_image_reply_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_get_image_data_length(R: *const xcb_get_image_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_image_data_end(R: *const xcb_get_image_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_image_reply(c: *mut xcb_connection_t,
                               cookie: xcb_get_image_cookie_t,
                               e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_image_reply_t;
}
extern "C" {
    pub fn xcb_poly_text_8_sizeof(_buffer: *const libc::c_void,
                                  items_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_text_8_checked(c: *mut xcb_connection_t,
                                   drawable: xcb_drawable_t,
                                   gc: xcb_gcontext_t, x: i16, y: i16,
                                   items_len: u32, items: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_8(c: *mut xcb_connection_t, drawable: xcb_drawable_t,
                           gc: xcb_gcontext_t, x: i16, y: i16, items_len: u32,
                           items: *const u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_8_items(R: *const xcb_poly_text_8_request_t)
     -> *mut u8;
}
extern "C" {
    pub fn xcb_poly_text_8_items_length(R: *const xcb_poly_text_8_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_text_8_items_end(R: *const xcb_poly_text_8_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_poly_text_16_sizeof(_buffer: *const libc::c_void,
                                   items_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_text_16_checked(c: *mut xcb_connection_t,
                                    drawable: xcb_drawable_t,
                                    gc: xcb_gcontext_t, x: i16, y: i16,
                                    items_len: u32, items: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_16(c: *mut xcb_connection_t,
                            drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                            x: i16, y: i16, items_len: u32, items: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_16_items(R: *const xcb_poly_text_16_request_t)
     -> *mut u8;
}
extern "C" {
    pub fn xcb_poly_text_16_items_length(R: *const xcb_poly_text_16_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_text_16_items_end(R: *const xcb_poly_text_16_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_image_text_8_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_image_text_8_checked(c: *mut xcb_connection_t, string_len: u8,
                                    drawable: xcb_drawable_t,
                                    gc: xcb_gcontext_t, x: i16, y: i16,
                                    string: *const libc::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_8(c: *mut xcb_connection_t, string_len: u8,
                            drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                            x: i16, y: i16, string: *const libc::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_8_string(R: *const xcb_image_text_8_request_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_image_text_8_string_length(R:
                                              *const xcb_image_text_8_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_image_text_8_string_end(R: *const xcb_image_text_8_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_image_text_16_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_image_text_16_checked(c: *mut xcb_connection_t, string_len: u8,
                                     drawable: xcb_drawable_t,
                                     gc: xcb_gcontext_t, x: i16, y: i16,
                                     string: *const xcb_char2b_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_16(c: *mut xcb_connection_t, string_len: u8,
                             drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                             x: i16, y: i16, string: *const xcb_char2b_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_16_string(R: *const xcb_image_text_16_request_t)
     -> *mut xcb_char2b_t;
}
extern "C" {
    pub fn xcb_image_text_16_string_length(R:
                                               *const xcb_image_text_16_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_image_text_16_string_iterator(R:
                                                 *const xcb_image_text_16_request_t)
     -> xcb_char2b_iterator_t;
}
extern "C" {
    pub fn xcb_create_colormap_checked(c: *mut xcb_connection_t, alloc: u8,
                                       mid: xcb_colormap_t,
                                       window: xcb_window_t,
                                       visual: xcb_visualid_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_colormap(c: *mut xcb_connection_t, alloc: u8,
                               mid: xcb_colormap_t, window: xcb_window_t,
                               visual: xcb_visualid_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colormap_checked(c: *mut xcb_connection_t,
                                     cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colormap(c: *mut xcb_connection_t, cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_colormap_and_free_checked(c: *mut xcb_connection_t,
                                              mid: xcb_colormap_t,
                                              src_cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_colormap_and_free(c: *mut xcb_connection_t,
                                      mid: xcb_colormap_t,
                                      src_cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_install_colormap_checked(c: *mut xcb_connection_t,
                                        cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_install_colormap(c: *mut xcb_connection_t,
                                cmap: xcb_colormap_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_uninstall_colormap_checked(c: *mut xcb_connection_t,
                                          cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_uninstall_colormap(c: *mut xcb_connection_t,
                                  cmap: xcb_colormap_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_installed_colormaps(c: *mut xcb_connection_t,
                                        window: xcb_window_t)
     -> xcb_list_installed_colormaps_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_unchecked(c: *mut xcb_connection_t,
                                                  window: xcb_window_t)
     -> xcb_list_installed_colormaps_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps(R:
                                                  *const xcb_list_installed_colormaps_reply_t)
     -> *mut xcb_colormap_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps_length(R:
                                                         *const xcb_list_installed_colormaps_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps_end(R:
                                                      *const xcb_list_installed_colormaps_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_reply(c: *mut xcb_connection_t,
                                              cookie:
                                                  xcb_list_installed_colormaps_cookie_t,
                                              e:
                                                  *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_installed_colormaps_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color(c: *mut xcb_connection_t, cmap: xcb_colormap_t,
                           red: u16, green: u16, blue: u16)
     -> xcb_alloc_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_unchecked(c: *mut xcb_connection_t,
                                     cmap: xcb_colormap_t, red: u16,
                                     green: u16, blue: u16)
     -> xcb_alloc_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_reply(c: *mut xcb_connection_t,
                                 cookie: xcb_alloc_color_cookie_t,
                                 e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_alloc_color_reply_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_alloc_named_color(c: *mut xcb_connection_t,
                                 cmap: xcb_colormap_t, name_len: u16,
                                 name: *const libc::c_char)
     -> xcb_alloc_named_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_unchecked(c: *mut xcb_connection_t,
                                           cmap: xcb_colormap_t,
                                           name_len: u16,
                                           name: *const libc::c_char)
     -> xcb_alloc_named_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_reply(c: *mut xcb_connection_t,
                                       cookie: xcb_alloc_named_color_cookie_t,
                                       e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_alloc_named_color_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells(c: *mut xcb_connection_t, contiguous: u8,
                                 cmap: xcb_colormap_t, colors: u16,
                                 planes: u16)
     -> xcb_alloc_color_cells_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_unchecked(c: *mut xcb_connection_t,
                                           contiguous: u8,
                                           cmap: xcb_colormap_t, colors: u16,
                                           planes: u16)
     -> xcb_alloc_color_cells_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels(R:
                                            *const xcb_alloc_color_cells_reply_t)
     -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels_length(R:
                                                   *const xcb_alloc_color_cells_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels_end(R:
                                                *const xcb_alloc_color_cells_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks(R:
                                           *const xcb_alloc_color_cells_reply_t)
     -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks_length(R:
                                                  *const xcb_alloc_color_cells_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks_end(R:
                                               *const xcb_alloc_color_cells_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_reply(c: *mut xcb_connection_t,
                                       cookie: xcb_alloc_color_cells_cookie_t,
                                       e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_alloc_color_cells_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_planes(c: *mut xcb_connection_t, contiguous: u8,
                                  cmap: xcb_colormap_t, colors: u16,
                                  reds: u16, greens: u16, blues: u16)
     -> xcb_alloc_color_planes_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_unchecked(c: *mut xcb_connection_t,
                                            contiguous: u8,
                                            cmap: xcb_colormap_t, colors: u16,
                                            reds: u16, greens: u16,
                                            blues: u16)
     -> xcb_alloc_color_planes_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels(R:
                                             *const xcb_alloc_color_planes_reply_t)
     -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels_length(R:
                                                    *const xcb_alloc_color_planes_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels_end(R:
                                                 *const xcb_alloc_color_planes_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_reply(c: *mut xcb_connection_t,
                                        cookie:
                                            xcb_alloc_color_planes_cookie_t,
                                        e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_alloc_color_planes_reply_t;
}
extern "C" {
    pub fn xcb_free_colors_sizeof(_buffer: *const libc::c_void,
                                  pixels_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_free_colors_checked(c: *mut xcb_connection_t,
                                   cmap: xcb_colormap_t, plane_mask: u32,
                                   pixels_len: u32, pixels: *const u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colors(c: *mut xcb_connection_t, cmap: xcb_colormap_t,
                           plane_mask: u32, pixels_len: u32,
                           pixels: *const u32) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colors_pixels(R: *const xcb_free_colors_request_t)
     -> *mut u32;
}
extern "C" {
    pub fn xcb_free_colors_pixels_length(R: *const xcb_free_colors_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_free_colors_pixels_end(R: *const xcb_free_colors_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_coloritem_next(i: *mut xcb_coloritem_iterator_t);
}
extern "C" {
    pub fn xcb_coloritem_end(i: xcb_coloritem_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_store_colors_sizeof(_buffer: *const libc::c_void,
                                   items_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_store_colors_checked(c: *mut xcb_connection_t,
                                    cmap: xcb_colormap_t, items_len: u32,
                                    items: *const xcb_coloritem_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_colors(c: *mut xcb_connection_t, cmap: xcb_colormap_t,
                            items_len: u32, items: *const xcb_coloritem_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_colors_items(R: *const xcb_store_colors_request_t)
     -> *mut xcb_coloritem_t;
}
extern "C" {
    pub fn xcb_store_colors_items_length(R: *const xcb_store_colors_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_store_colors_items_iterator(R:
                                               *const xcb_store_colors_request_t)
     -> xcb_coloritem_iterator_t;
}
extern "C" {
    pub fn xcb_store_named_color_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_store_named_color_checked(c: *mut xcb_connection_t, flags: u8,
                                         cmap: xcb_colormap_t, pixel: u32,
                                         name_len: u16,
                                         name: *const libc::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_named_color(c: *mut xcb_connection_t, flags: u8,
                                 cmap: xcb_colormap_t, pixel: u32,
                                 name_len: u16, name: *const libc::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_named_color_name(R:
                                          *const xcb_store_named_color_request_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_store_named_color_name_length(R:
                                                 *const xcb_store_named_color_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_store_named_color_name_end(R:
                                              *const xcb_store_named_color_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_rgb_next(i: *mut xcb_rgb_iterator_t);
}
extern "C" {
    pub fn xcb_rgb_end(i: xcb_rgb_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_colors_sizeof(_buffer: *const libc::c_void,
                                   pixels_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_colors(c: *mut xcb_connection_t, cmap: xcb_colormap_t,
                            pixels_len: u32, pixels: *const u32)
     -> xcb_query_colors_cookie_t;
}
extern "C" {
    pub fn xcb_query_colors_unchecked(c: *mut xcb_connection_t,
                                      cmap: xcb_colormap_t, pixels_len: u32,
                                      pixels: *const u32)
     -> xcb_query_colors_cookie_t;
}
extern "C" {
    pub fn xcb_query_colors_colors(R: *const xcb_query_colors_reply_t)
     -> *mut xcb_rgb_t;
}
extern "C" {
    pub fn xcb_query_colors_colors_length(R: *const xcb_query_colors_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_colors_colors_iterator(R:
                                                *const xcb_query_colors_reply_t)
     -> xcb_rgb_iterator_t;
}
extern "C" {
    pub fn xcb_query_colors_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_query_colors_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_colors_reply_t;
}
extern "C" {
    pub fn xcb_lookup_color_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_lookup_color(c: *mut xcb_connection_t, cmap: xcb_colormap_t,
                            name_len: u16, name: *const libc::c_char)
     -> xcb_lookup_color_cookie_t;
}
extern "C" {
    pub fn xcb_lookup_color_unchecked(c: *mut xcb_connection_t,
                                      cmap: xcb_colormap_t, name_len: u16,
                                      name: *const libc::c_char)
     -> xcb_lookup_color_cookie_t;
}
extern "C" {
    pub fn xcb_lookup_color_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_lookup_color_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_lookup_color_reply_t;
}
extern "C" {
    pub fn xcb_create_cursor_checked(c: *mut xcb_connection_t,
                                     cid: xcb_cursor_t, source: xcb_pixmap_t,
                                     mask: xcb_pixmap_t, fore_red: u16,
                                     fore_green: u16, fore_blue: u16,
                                     back_red: u16, back_green: u16,
                                     back_blue: u16, x: u16, y: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_cursor(c: *mut xcb_connection_t, cid: xcb_cursor_t,
                             source: xcb_pixmap_t, mask: xcb_pixmap_t,
                             fore_red: u16, fore_green: u16, fore_blue: u16,
                             back_red: u16, back_green: u16, back_blue: u16,
                             x: u16, y: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_glyph_cursor_checked(c: *mut xcb_connection_t,
                                           cid: xcb_cursor_t,
                                           source_font: xcb_font_t,
                                           mask_font: xcb_font_t,
                                           source_char: u16, mask_char: u16,
                                           fore_red: u16, fore_green: u16,
                                           fore_blue: u16, back_red: u16,
                                           back_green: u16, back_blue: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_glyph_cursor(c: *mut xcb_connection_t,
                                   cid: xcb_cursor_t, source_font: xcb_font_t,
                                   mask_font: xcb_font_t, source_char: u16,
                                   mask_char: u16, fore_red: u16,
                                   fore_green: u16, fore_blue: u16,
                                   back_red: u16, back_green: u16,
                                   back_blue: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_cursor_checked(c: *mut xcb_connection_t,
                                   cursor: xcb_cursor_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_cursor(c: *mut xcb_connection_t, cursor: xcb_cursor_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_recolor_cursor_checked(c: *mut xcb_connection_t,
                                      cursor: xcb_cursor_t, fore_red: u16,
                                      fore_green: u16, fore_blue: u16,
                                      back_red: u16, back_green: u16,
                                      back_blue: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_recolor_cursor(c: *mut xcb_connection_t, cursor: xcb_cursor_t,
                              fore_red: u16, fore_green: u16, fore_blue: u16,
                              back_red: u16, back_green: u16, back_blue: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_query_best_size(c: *mut xcb_connection_t, _class: u8,
                               drawable: xcb_drawable_t, width: u16,
                               height: u16) -> xcb_query_best_size_cookie_t;
}
extern "C" {
    pub fn xcb_query_best_size_unchecked(c: *mut xcb_connection_t, _class: u8,
                                         drawable: xcb_drawable_t, width: u16,
                                         height: u16)
     -> xcb_query_best_size_cookie_t;
}
extern "C" {
    pub fn xcb_query_best_size_reply(c: *mut xcb_connection_t,
                                     cookie: xcb_query_best_size_cookie_t,
                                     e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_best_size_reply_t;
}
extern "C" {
    pub fn xcb_query_extension_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_extension(c: *mut xcb_connection_t, name_len: u16,
                               name: *const libc::c_char)
     -> xcb_query_extension_cookie_t;
}
extern "C" {
    pub fn xcb_query_extension_unchecked(c: *mut xcb_connection_t,
                                         name_len: u16,
                                         name: *const libc::c_char)
     -> xcb_query_extension_cookie_t;
}
extern "C" {
    pub fn xcb_query_extension_reply(c: *mut xcb_connection_t,
                                     cookie: xcb_query_extension_cookie_t,
                                     e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_extension_reply_t;
}
extern "C" {
    pub fn xcb_list_extensions_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_extensions(c: *mut xcb_connection_t)
     -> xcb_list_extensions_cookie_t;
}
extern "C" {
    pub fn xcb_list_extensions_unchecked(c: *mut xcb_connection_t)
     -> xcb_list_extensions_cookie_t;
}
extern "C" {
    pub fn xcb_list_extensions_names_length(R:
                                                *const xcb_list_extensions_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_extensions_names_iterator(R:
                                                  *const xcb_list_extensions_reply_t)
     -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_list_extensions_reply(c: *mut xcb_connection_t,
                                     cookie: xcb_list_extensions_cookie_t,
                                     e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_extensions_reply_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_checked(c: *mut xcb_connection_t,
                                               keycode_count: u8,
                                               first_keycode: xcb_keycode_t,
                                               keysyms_per_keycode: u8,
                                               keysyms: *const xcb_keysym_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping(c: *mut xcb_connection_t,
                                       keycode_count: u8,
                                       first_keycode: xcb_keycode_t,
                                       keysyms_per_keycode: u8,
                                       keysyms: *const xcb_keysym_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms(R:
                                                   *const xcb_change_keyboard_mapping_request_t)
     -> *mut xcb_keysym_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms_length(R:
                                                          *const xcb_change_keyboard_mapping_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms_end(R:
                                                       *const xcb_change_keyboard_mapping_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping(c: *mut xcb_connection_t,
                                    first_keycode: xcb_keycode_t, count: u8)
     -> xcb_get_keyboard_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_unchecked(c: *mut xcb_connection_t,
                                              first_keycode: xcb_keycode_t,
                                              count: u8)
     -> xcb_get_keyboard_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms(R:
                                                *const xcb_get_keyboard_mapping_reply_t)
     -> *mut xcb_keysym_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms_length(R:
                                                       *const xcb_get_keyboard_mapping_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms_end(R:
                                                    *const xcb_get_keyboard_mapping_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_get_keyboard_mapping_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_keyboard_mapping_reply_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_serialize(_buffer:
                                                                *mut *mut libc::c_void,
                                                            value_mask: u32,
                                                            _aux:
                                                                *const xcb_change_keyboard_control_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_unpack(_buffer:
                                                             *const libc::c_void,
                                                         value_mask: u32,
                                                         _aux:
                                                             *mut xcb_change_keyboard_control_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_sizeof(_buffer:
                                                             *const libc::c_void,
                                                         value_mask: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_checked(c: *mut xcb_connection_t,
                                               value_mask: u32,
                                               value_list:
                                                   *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control(c: *mut xcb_connection_t,
                                       value_mask: u32,
                                       value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_aux_checked(c: *mut xcb_connection_t,
                                                   value_mask: u32,
                                                   value_list:
                                                       *const xcb_change_keyboard_control_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_aux(c: *mut xcb_connection_t,
                                           value_mask: u32,
                                           value_list:
                                               *const xcb_change_keyboard_control_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list(R:
                                                      *const xcb_change_keyboard_control_request_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_get_keyboard_control(c: *mut xcb_connection_t)
     -> xcb_get_keyboard_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_control_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_keyboard_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_control_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_get_keyboard_control_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_keyboard_control_reply_t;
}
extern "C" {
    pub fn xcb_bell_checked(c: *mut xcb_connection_t, percent: i8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_bell(c: *mut xcb_connection_t, percent: i8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_pointer_control_checked(c: *mut xcb_connection_t,
                                              acceleration_numerator: i16,
                                              acceleration_denominator: i16,
                                              threshold: i16,
                                              do_acceleration: u8,
                                              do_threshold: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_pointer_control(c: *mut xcb_connection_t,
                                      acceleration_numerator: i16,
                                      acceleration_denominator: i16,
                                      threshold: i16, do_acceleration: u8,
                                      do_threshold: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_control(c: *mut xcb_connection_t)
     -> xcb_get_pointer_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_control_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_pointer_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_control_reply(c: *mut xcb_connection_t,
                                         cookie:
                                             xcb_get_pointer_control_cookie_t,
                                         e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_pointer_control_reply_t;
}
extern "C" {
    pub fn xcb_set_screen_saver_checked(c: *mut xcb_connection_t,
                                        timeout: i16, interval: i16,
                                        prefer_blanking: u8,
                                        allow_exposures: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_screen_saver(c: *mut xcb_connection_t, timeout: i16,
                                interval: i16, prefer_blanking: u8,
                                allow_exposures: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_screen_saver(c: *mut xcb_connection_t)
     -> xcb_get_screen_saver_cookie_t;
}
extern "C" {
    pub fn xcb_get_screen_saver_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_screen_saver_cookie_t;
}
extern "C" {
    pub fn xcb_get_screen_saver_reply(c: *mut xcb_connection_t,
                                      cookie: xcb_get_screen_saver_cookie_t,
                                      e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_screen_saver_reply_t;
}
extern "C" {
    pub fn xcb_change_hosts_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_hosts_checked(c: *mut xcb_connection_t, mode: u8,
                                    family: u8, address_len: u16,
                                    address: *const u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_hosts(c: *mut xcb_connection_t, mode: u8, family: u8,
                            address_len: u16, address: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_hosts_address(R: *const xcb_change_hosts_request_t)
     -> *mut u8;
}
extern "C" {
    pub fn xcb_change_hosts_address_length(R:
                                               *const xcb_change_hosts_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_hosts_address_end(R: *const xcb_change_hosts_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_host_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_host_address(R: *const xcb_host_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_host_address_length(R: *const xcb_host_t) -> libc::c_int;
}
extern "C" {
    pub fn xcb_host_address_end(R: *const xcb_host_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_host_next(i: *mut xcb_host_iterator_t);
}
extern "C" {
    pub fn xcb_host_end(i: xcb_host_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_hosts_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_hosts(c: *mut xcb_connection_t)
     -> xcb_list_hosts_cookie_t;
}
extern "C" {
    pub fn xcb_list_hosts_unchecked(c: *mut xcb_connection_t)
     -> xcb_list_hosts_cookie_t;
}
extern "C" {
    pub fn xcb_list_hosts_hosts_length(R: *const xcb_list_hosts_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_hosts_hosts_iterator(R: *const xcb_list_hosts_reply_t)
     -> xcb_host_iterator_t;
}
extern "C" {
    pub fn xcb_list_hosts_reply(c: *mut xcb_connection_t,
                                cookie: xcb_list_hosts_cookie_t,
                                e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_hosts_reply_t;
}
extern "C" {
    pub fn xcb_set_access_control_checked(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_access_control(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_close_down_mode_checked(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_close_down_mode(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_kill_client_checked(c: *mut xcb_connection_t, resource: u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_kill_client(c: *mut xcb_connection_t, resource: u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_rotate_properties_checked(c: *mut xcb_connection_t,
                                         window: xcb_window_t, atoms_len: u16,
                                         delta: i16, atoms: *const xcb_atom_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties(c: *mut xcb_connection_t,
                                 window: xcb_window_t, atoms_len: u16,
                                 delta: i16, atoms: *const xcb_atom_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms(R:
                                           *const xcb_rotate_properties_request_t)
     -> *mut xcb_atom_t;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms_length(R:
                                                  *const xcb_rotate_properties_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms_end(R:
                                               *const xcb_rotate_properties_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_force_screen_saver_checked(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_force_screen_saver(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_set_pointer_mapping(c: *mut xcb_connection_t, map_len: u8,
                                   map: *const u8)
     -> xcb_set_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_unchecked(c: *mut xcb_connection_t,
                                             map_len: u8, map: *const u8)
     -> xcb_set_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_reply(c: *mut xcb_connection_t,
                                         cookie:
                                             xcb_set_pointer_mapping_cookie_t,
                                         e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_set_pointer_mapping_reply_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_pointer_mapping(c: *mut xcb_connection_t)
     -> xcb_get_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map(R:
                                           *const xcb_get_pointer_mapping_reply_t)
     -> *mut u8;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map_length(R:
                                                  *const xcb_get_pointer_mapping_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map_end(R:
                                               *const xcb_get_pointer_mapping_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_reply(c: *mut xcb_connection_t,
                                         cookie:
                                             xcb_get_pointer_mapping_cookie_t,
                                         e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_pointer_mapping_reply_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_set_modifier_mapping(c: *mut xcb_connection_t,
                                    keycodes_per_modifier: u8,
                                    keycodes: *const xcb_keycode_t)
     -> xcb_set_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_unchecked(c: *mut xcb_connection_t,
                                              keycodes_per_modifier: u8,
                                              keycodes: *const xcb_keycode_t)
     -> xcb_set_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_set_modifier_mapping_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_set_modifier_mapping_reply_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_modifier_mapping(c: *mut xcb_connection_t)
     -> xcb_get_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes(R:
                                                 *const xcb_get_modifier_mapping_reply_t)
     -> *mut xcb_keycode_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes_length(R:
                                                        *const xcb_get_modifier_mapping_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes_end(R:
                                                     *const xcb_get_modifier_mapping_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_get_modifier_mapping_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_modifier_mapping_reply_t;
}
extern "C" {
    pub fn xcb_no_operation_checked(c: *mut xcb_connection_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_no_operation(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_auth_info_t {
    pub namelen: libc::c_int,
    pub name: *mut libc::c_char,
    pub datalen: libc::c_int,
    pub data: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_xcb_auth_info_t() {
    assert_eq!(::std::mem::size_of::<xcb_auth_info_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_auth_info_t>() , 8usize);
}
impl Clone for xcb_auth_info_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn xcb_flush(c: *mut xcb_connection_t) -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_maximum_request_length(c: *mut xcb_connection_t) -> u32;
}
extern "C" {
    pub fn xcb_prefetch_maximum_request_length(c: *mut xcb_connection_t);
}
extern "C" {
    pub fn xcb_wait_for_event(c: *mut xcb_connection_t)
     -> *mut xcb_generic_event_t;
}
extern "C" {
    pub fn xcb_poll_for_event(c: *mut xcb_connection_t)
     -> *mut xcb_generic_event_t;
}
extern "C" {
    pub fn xcb_poll_for_queued_event(c: *mut xcb_connection_t)
     -> *mut xcb_generic_event_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_special_event([u8; 0]);
pub type xcb_special_event_t = xcb_special_event;
extern "C" {
    pub fn xcb_poll_for_special_event(c: *mut xcb_connection_t,
                                      se: *mut xcb_special_event_t)
     -> *mut xcb_generic_event_t;
}
extern "C" {
    pub fn xcb_wait_for_special_event(c: *mut xcb_connection_t,
                                      se: *mut xcb_special_event_t)
     -> *mut xcb_generic_event_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_extension_t([u8; 0]);
extern "C" {
    pub fn xcb_register_for_special_xge(c: *mut xcb_connection_t,
                                        ext: *mut xcb_extension_t, eid: u32,
                                        stamp: *mut u32)
     -> *mut xcb_special_event_t;
}
extern "C" {
    pub fn xcb_unregister_for_special_event(c: *mut xcb_connection_t,
                                            se: *mut xcb_special_event_t);
}
extern "C" {
    pub fn xcb_request_check(c: *mut xcb_connection_t,
                             cookie: xcb_void_cookie_t)
     -> *mut xcb_generic_error_t;
}
extern "C" {
    pub fn xcb_discard_reply(c: *mut xcb_connection_t,
                             sequence: libc::c_uint);
}
extern "C" {
    pub fn xcb_discard_reply64(c: *mut xcb_connection_t, sequence: u64);
}
extern "C" {
    pub fn xcb_get_extension_data(c: *mut xcb_connection_t,
                                  ext: *mut xcb_extension_t)
     -> *const xcb_query_extension_reply_t;
}
extern "C" {
    pub fn xcb_prefetch_extension_data(c: *mut xcb_connection_t,
                                       ext: *mut xcb_extension_t);
}
extern "C" {
    pub fn xcb_get_setup(c: *mut xcb_connection_t) -> *const xcb_setup_t;
}
extern "C" {
    pub fn xcb_get_file_descriptor(c: *mut xcb_connection_t) -> libc::c_int;
}
extern "C" {
    pub fn xcb_connection_has_error(c: *mut xcb_connection_t) -> libc::c_int;
}
extern "C" {
    pub fn xcb_connect_to_fd(fd: libc::c_int, auth_info: *mut xcb_auth_info_t)
     -> *mut xcb_connection_t;
}
extern "C" {
    pub fn xcb_disconnect(c: *mut xcb_connection_t);
}
extern "C" {
    pub fn xcb_parse_display(name: *const libc::c_char,
                             host: *mut *mut libc::c_char,
                             display: *mut libc::c_int,
                             screen: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn xcb_connect(displayname: *const libc::c_char,
                       screenp: *mut libc::c_int) -> *mut xcb_connection_t;
}
extern "C" {
    pub fn xcb_connect_to_display_with_auth_info(display: *const libc::c_char,
                                                 auth: *mut xcb_auth_info_t,
                                                 screen: *mut libc::c_int)
     -> *mut xcb_connection_t;
}
extern "C" {
    pub fn xcb_generate_id(c: *mut xcb_connection_t) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SnDisplay([u8; 0]);
pub type SnDisplayErrorTrapPush =
    ::std::option::Option<unsafe extern "C" fn(display: *mut SnDisplay,
                                               xdisplay: *mut Display)>;
pub type SnDisplayErrorTrapPop =
    ::std::option::Option<unsafe extern "C" fn(display: *mut SnDisplay,
                                               xdisplay: *mut Display)>;
pub type SnXcbDisplayErrorTrapPush =
    ::std::option::Option<unsafe extern "C" fn(display: *mut SnDisplay,
                                               xconnection:
                                                   *mut xcb_connection_t)>;
pub type SnXcbDisplayErrorTrapPop =
    ::std::option::Option<unsafe extern "C" fn(display: *mut SnDisplay,
                                               xconnection:
                                                   *mut xcb_connection_t)>;
extern "C" {
    pub fn sn_display_new(xdisplay: *mut Display,
                          push_trap_func: SnDisplayErrorTrapPush,
                          pop_trap_func: SnDisplayErrorTrapPop)
     -> *mut SnDisplay;
}
extern "C" {
    pub fn sn_xcb_display_new(xconnection: *mut xcb_connection_t,
                              push_trap_func: SnXcbDisplayErrorTrapPush,
                              pop_trap_func: SnXcbDisplayErrorTrapPop)
     -> *mut SnDisplay;
}
extern "C" {
    pub fn sn_display_ref(display: *mut SnDisplay);
}
extern "C" {
    pub fn sn_display_unref(display: *mut SnDisplay);
}
extern "C" {
    pub fn sn_display_get_x_display(display: *mut SnDisplay) -> *mut Display;
}
extern "C" {
    pub fn sn_display_get_x_connection(display: *mut SnDisplay)
     -> *mut xcb_connection_t;
}
extern "C" {
    pub fn sn_display_process_event(display: *mut SnDisplay,
                                    xevent: *mut XEvent) -> sn_bool_t;
}
extern "C" {
    pub fn sn_xcb_display_process_event(display: *mut SnDisplay,
                                        xevent: *mut xcb_generic_event_t)
     -> sn_bool_t;
}
extern "C" {
    pub fn sn_display_error_trap_push(display: *mut SnDisplay);
}
extern "C" {
    pub fn sn_display_error_trap_pop(display: *mut SnDisplay);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SnLauncheeContext([u8; 0]);
extern "C" {
    pub fn sn_launchee_context_new(display: *mut SnDisplay,
                                   screen: libc::c_int,
                                   startup_id: *const libc::c_char)
     -> *mut SnLauncheeContext;
}
extern "C" {
    pub fn sn_launchee_context_new_from_environment(display: *mut SnDisplay,
                                                    screen: libc::c_int)
     -> *mut SnLauncheeContext;
}
extern "C" {
    pub fn sn_launchee_context_ref(context: *mut SnLauncheeContext);
}
extern "C" {
    pub fn sn_launchee_context_unref(context: *mut SnLauncheeContext);
}
extern "C" {
    pub fn sn_launchee_context_get_startup_id(context: *mut SnLauncheeContext)
     -> *const libc::c_char;
}
extern "C" {
    pub fn sn_launchee_context_get_id_has_timestamp(context:
                                                        *mut SnLauncheeContext)
     -> libc::c_int;
}
extern "C" {
    pub fn sn_launchee_context_get_timestamp(context: *mut SnLauncheeContext)
     -> Time;
}
extern "C" {
    pub fn sn_launchee_context_complete(context: *mut SnLauncheeContext);
}
extern "C" {
    pub fn sn_launchee_context_setup_window(context: *mut SnLauncheeContext,
                                            xwindow: Window);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SnLauncherContext([u8; 0]);
extern "C" {
    pub fn sn_launcher_context_new(display: *mut SnDisplay,
                                   screen: libc::c_int)
     -> *mut SnLauncherContext;
}
extern "C" {
    pub fn sn_launcher_context_ref(context: *mut SnLauncherContext);
}
extern "C" {
    pub fn sn_launcher_context_unref(context: *mut SnLauncherContext);
}
extern "C" {
    pub fn sn_launcher_context_initiate(context: *mut SnLauncherContext,
                                        launcher_name: *const libc::c_char,
                                        launchee_name: *const libc::c_char,
                                        timestamp: Time);
}
extern "C" {
    pub fn sn_launcher_context_complete(context: *mut SnLauncherContext);
}
extern "C" {
    pub fn sn_launcher_context_get_startup_id(context: *mut SnLauncherContext)
     -> *const libc::c_char;
}
extern "C" {
    pub fn sn_launcher_context_get_initiated(context: *mut SnLauncherContext)
     -> sn_bool_t;
}
extern "C" {
    pub fn sn_launcher_context_setup_child_process(context:
                                                       *mut SnLauncherContext);
}
extern "C" {
    pub fn sn_launcher_context_set_name(context: *mut SnLauncherContext,
                                        name: *const libc::c_char);
}
extern "C" {
    pub fn sn_launcher_context_set_description(context:
                                                   *mut SnLauncherContext,
                                               description:
                                                   *const libc::c_char);
}
extern "C" {
    pub fn sn_launcher_context_set_workspace(context: *mut SnLauncherContext,
                                             workspace: libc::c_int);
}
extern "C" {
    pub fn sn_launcher_context_set_wmclass(context: *mut SnLauncherContext,
                                           klass: *const libc::c_char);
}
extern "C" {
    pub fn sn_launcher_context_set_binary_name(context:
                                                   *mut SnLauncherContext,
                                               name: *const libc::c_char);
}
extern "C" {
    pub fn sn_launcher_context_set_icon_name(context: *mut SnLauncherContext,
                                             name: *const libc::c_char);
}
extern "C" {
    pub fn sn_launcher_context_set_application_id(context:
                                                      *mut SnLauncherContext,
                                                  desktop_file:
                                                      *const libc::c_char);
}
extern "C" {
    pub fn sn_launcher_context_set_extra_property(context:
                                                      *mut SnLauncherContext,
                                                  name: *const libc::c_char,
                                                  value: *const libc::c_char);
}
extern "C" {
    pub fn sn_launcher_context_get_initiated_time(context:
                                                      *mut SnLauncherContext,
                                                  tv_sec: *mut libc::c_long,
                                                  tv_usec: *mut libc::c_long);
}
extern "C" {
    pub fn sn_launcher_context_get_last_active_time(context:
                                                        *mut SnLauncherContext,
                                                    tv_sec: *mut libc::c_long,
                                                    tv_usec:
                                                        *mut libc::c_long);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SnMonitorContext([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SnMonitorEvent([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SnStartupSequence([u8; 0]);
pub type SnMonitorEventFunc =
    ::std::option::Option<unsafe extern "C" fn(event: *mut SnMonitorEvent,
                                               user_data: *mut libc::c_void)>;
pub const SN_MONITOR_EVENT_INITIATED: _bindgen_ty_108 =
    _bindgen_ty_108::SN_MONITOR_EVENT_INITIATED;
pub const SN_MONITOR_EVENT_COMPLETED: _bindgen_ty_108 =
    _bindgen_ty_108::SN_MONITOR_EVENT_COMPLETED;
pub const SN_MONITOR_EVENT_CHANGED: _bindgen_ty_108 =
    _bindgen_ty_108::SN_MONITOR_EVENT_CHANGED;
pub const SN_MONITOR_EVENT_CANCELED: _bindgen_ty_108 =
    _bindgen_ty_108::SN_MONITOR_EVENT_CANCELED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_108 {
    SN_MONITOR_EVENT_INITIATED = 0,
    SN_MONITOR_EVENT_COMPLETED = 1,
    SN_MONITOR_EVENT_CHANGED = 2,
    SN_MONITOR_EVENT_CANCELED = 3,
}
pub use self::_bindgen_ty_108 as SnMonitorEventType;
extern "C" {
    pub fn sn_monitor_context_new(display: *mut SnDisplay,
                                  screen: libc::c_int,
                                  event_func: SnMonitorEventFunc,
                                  event_func_data: *mut libc::c_void,
                                  free_data_func: SnFreeFunc)
     -> *mut SnMonitorContext;
}
extern "C" {
    pub fn sn_monitor_context_ref(context: *mut SnMonitorContext);
}
extern "C" {
    pub fn sn_monitor_context_unref(context: *mut SnMonitorContext);
}
extern "C" {
    pub fn sn_monitor_event_ref(event: *mut SnMonitorEvent);
}
extern "C" {
    pub fn sn_monitor_event_unref(event: *mut SnMonitorEvent);
}
extern "C" {
    pub fn sn_monitor_event_copy(event: *mut SnMonitorEvent)
     -> *mut SnMonitorEvent;
}
extern "C" {
    pub fn sn_monitor_event_get_type(event: *mut SnMonitorEvent)
     -> SnMonitorEventType;
}
extern "C" {
    pub fn sn_monitor_event_get_startup_sequence(event: *mut SnMonitorEvent)
     -> *mut SnStartupSequence;
}
extern "C" {
    pub fn sn_monitor_event_get_context(event: *mut SnMonitorEvent)
     -> *mut SnMonitorContext;
}
extern "C" {
    pub fn sn_startup_sequence_ref(sequence: *mut SnStartupSequence);
}
extern "C" {
    pub fn sn_startup_sequence_unref(sequence: *mut SnStartupSequence);
}
extern "C" {
    pub fn sn_startup_sequence_get_id(sequence: *mut SnStartupSequence)
     -> *const libc::c_char;
}
extern "C" {
    pub fn sn_startup_sequence_get_completed(sequence: *mut SnStartupSequence)
     -> sn_bool_t;
}
extern "C" {
    pub fn sn_startup_sequence_get_name(sequence: *mut SnStartupSequence)
     -> *const libc::c_char;
}
extern "C" {
    pub fn sn_startup_sequence_get_description(sequence:
                                                   *mut SnStartupSequence)
     -> *const libc::c_char;
}
extern "C" {
    pub fn sn_startup_sequence_get_workspace(sequence: *mut SnStartupSequence)
     -> libc::c_int;
}
extern "C" {
    pub fn sn_startup_sequence_get_timestamp(sequence: *mut SnStartupSequence)
     -> Time;
}
extern "C" {
    pub fn sn_startup_sequence_get_wmclass(sequence: *mut SnStartupSequence)
     -> *const libc::c_char;
}
extern "C" {
    pub fn sn_startup_sequence_get_binary_name(sequence:
                                                   *mut SnStartupSequence)
     -> *const libc::c_char;
}
extern "C" {
    pub fn sn_startup_sequence_get_icon_name(sequence: *mut SnStartupSequence)
     -> *const libc::c_char;
}
extern "C" {
    pub fn sn_startup_sequence_get_application_id(sequence:
                                                      *mut SnStartupSequence)
     -> *const libc::c_char;
}
extern "C" {
    pub fn sn_startup_sequence_get_screen(sequence: *mut SnStartupSequence)
     -> libc::c_int;
}
extern "C" {
    pub fn sn_startup_sequence_get_initiated_time(sequence:
                                                      *mut SnStartupSequence,
                                                  tv_sec: *mut libc::c_long,
                                                  tv_usec: *mut libc::c_long);
}
extern "C" {
    pub fn sn_startup_sequence_get_last_active_time(sequence:
                                                        *mut SnStartupSequence,
                                                    tv_sec: *mut libc::c_long,
                                                    tv_usec:
                                                        *mut libc::c_long);
}
extern "C" {
    pub fn sn_startup_sequence_complete(sequence: *mut SnStartupSequence);
}
